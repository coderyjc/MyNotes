## 概述-BigTable

google大数据解决方案：

- Google文件系统 GFS
- 分布式计算编程模型MapReduce分布式并行计算模型来处理海量数据
- 分布式锁服务Chubby提供协同服务管理
- 分布式结构化数据存储系统Bigtable等。

<img src="R:\GITHUB\MyNotes\_Typora\BigData\HBase\HBase.imgs\image-20210415210721990.png" alt="image-20210415210721990" style="zoom: 50%;" />



Bigtable是一个分布式多维映射表，表中的数据通过一个行关键字、一个列关键字以及一个时间戳进行索引 ： (row:string, column:string, time:int64)→string

Bigtable对存储在其中的数据不做任何解析，一律看做字符串



### 数据模型-BigTable

**行**

行是表的第一级索引，可以把该行的列、时间和值看成一个整体，简化为一维键值映射。

Bigtable的行关键字可以是任意的字符串，但是大小不能超过**64KB**

Bigtable和传统的关系型数据库有很大不同，它不支持一般意义上的事务，但能保证对于行的读写操作具有原子性（Atomic）

表中数据都是根据行关键字进行排序的，排序使用的是词典序。

一个典型实例，其中com.cnn.www就是一个行关键字。不直接存储网页地址，而将其倒排是Bigtable的一个巧妙设计。带来两个好处 :同一地址域的网页会被存储在表中的连续位置，有利于用户查找和分析；倒排便于数据压缩，可以大幅提高压缩率

<img src="R:\GITHUB\MyNotes\_Typora\BigData\HBase\HBase.imgs\image-20210415211638192.png" alt="image-20210415211638192" style="zoom:67%;" />

由于规模的问题，单个的大表不利于数据处理，因此Bigtable将一个表分成了多个子表，每个子表包含多个行。**子表是Bigtable中数据划分和负载均衡的基本单位。**



**列**

列是第二级索引，每行拥有的列是不受限制的，可以随时增加减少。

Bigtable并不是简单地存储所有的列关键字，为了方便管理，列被分为多个列族，一个列族里的列一般存储相同类型的数据。

一行的列族很少变化，但是列族里的列可以随意添加删除。同族的数据会被压缩在一起保存

引入了列族的概念之后，列关键字就采用下述的语法规则来定义：

族名：限定词（family：qualifier）

族名必须有意义，限定词则可以任意选定

图中，内容、锚点都是不同的族。而cnnsi.com和my.look.ca则是锚点族中不同的限定词

族同时也是Bigtable中访问控制（Access Control）基本单元，也就是说**访问权限的设置是在族这一级别上进行的**

<img src="R:\GITHUB\MyNotes\_Typora\BigData\HBase\HBase.imgs\image-20210415211901133.png" alt="image-20210415211901133" style="zoom:67%;" />

**时间戳**

时间戳是第三级索引。

为了简化不同版本的数据管理，Bigtable目前提供了两种设置：

- 一种是保留最近的N个不同版本，图中数据模型采取的就是这种方法，它保存最新的三个版本数据。

- 另一种就是保留限定时间内的所有不同版本，比如可以保存最近10天的所有不同版本数据。失效的版本将会由Bigtable的垃圾回收机制自
  动处理
- Google的很多服务比如网页检索和用户的个性化设置等都需要保存不同时间的数据，这些不同的数据版本必须通过时间戳来区分。







## 访问接口





## 数据模型





## 实现原理





## 运行机制





## 应用方案





## 编程实践




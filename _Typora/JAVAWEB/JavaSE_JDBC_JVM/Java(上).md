## Java开发环境

### Java语言的特性

#### 简单性（相对于C++）

在Java语言当中真正操作内存的是：JVM（Java虚拟机）

所有的java程序都是运行在Java虚拟机当中的。而Java虚拟机执行过程中再去操作内存。在内存操作方面不如C++

对于C或者C++来说程序员都是可以直接通过指针操作内存的。C或者C++更灵活，可以直接程序员操作内存，但是要求程序员技术精湛。C语言或者C++更有驾驭感。

Java语言**屏蔽了**指针概念，程序员*不能直接操作指针*，或者说程序员
不能直接操作内存。这种方式有优点也有缺点：
优点：不容易导致内存泄漏。（简单了。）
缺点：效率问题，驾驭感比较差。

飞机航行：
- 如果是C语言表示程序员是飞机驾驶员。
- 如果是Java语言表示程序员是飞机上的乘客。

Java语言底层是C++，所以JVM是用C++语言写好的一个虚拟的电脑。

JVM在哪里？安装了JDK之后，JVM就代表安装好了。

CPU：

- 中央处理器，相当于人类的大脑，负责发送并执行指令。
- 是整个计算机的指挥官。
- CPU是负责计算的，负责运算的。
- 10 + 20 = 30 CPU负责将30这个结果计算出来。但是在计算过程中有三个数据需要临时找个空间存储一下：这三个数据分别是：10 20 30

内存：

- 程序运行过程当中的临时数据存储空间。
- 断电之后或者关机之后内存中的数据就消失了。

硬盘：

- 持久化设备，硬盘上的数据不会因断电而丢失。

主板：

- 相当于人类的躯干，是一个载体：
- CPU、内存条、硬盘等主要的部件都是放在主板上的，
- 主板上有很多线，将以上的部件链接起来。


#### 完全面向对象

封装，继承，多态

面向对象更容易让人理解，人类通常是以对象的方式认知世界的。

采用面向对象的方式可以让复杂问题简单化

#### <span style = "color:red">健壮性 </span>

主要是因为Java中有一种机制：自动垃圾回收机制（GC机制 Garbage Collection）。Java 程序启动了一个单独的垃圾回收线程，时刻监测内存使用情况，在特定时机会回收/释放垃圾数据，这样会让内存时刻处于最好的状态。

java语言是健壮的，相对于C语言来说，C语言没有Java健壮。

Java不容易导致内存的泄漏。C++或者C语言使用不当时很容易导致内存泄漏。

**JVM**负责调度GC机制。程序员不需要干涉。

以上讲解中又描述了这几个术语：

- JVM（C++语言写的一个虚拟的计算机）
- GC（垃圾回收机制）

有缺点：内存无法得到及时的清理

可以手动调用清理机制

#### java完全/完美支持多线程并发。

#### 可移植性/跨平台

java语言只要编写一次，可以做到到处运行。

例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linux操作系统上，同样也可以运行到MaC OS上面。

一次编写，到处运行。（平台改变了，程序不需要改。）

![1592488549142](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592488549142.png)

![1592488730858](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592488730858.png)

JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？

- 优点：一次编写到处运行，可以**跨平台**。
- 缺点：麻烦。对于运行java程序来说必须先有一个JVM。就像你要想在网页上看视频，你必须先安装一个flash是一样的。

Java语言可以编写病毒吗？

- 可以，没问题。但是很难让用户中毒。
- 中毒的一般都是java程序员。所以很少有人编写java的病毒脚本。

### JDK、JRE、JVM ？

![1592489195526](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592489195526.png)

- JDK（Java Development Kit）:Java开发工具箱

- JRE（Java Runtime Environment，Java 运行环境）:java运行环境

- JVM（Java Virtual Machine）:java虚拟机

- JDK包括JRE，JRE包括JVM。

JVM是不能独立安装的。JRE和JDK都是可以独立安装的。有单独的JDK安装包。也有单独的JRE安装包。没有单独的JVM安装包。

安装JDK的时候：JRE就自动安装了，同时JRE内部的JVM也就自动安装了。
安装JRE的时候：JVM也就自动安装了。

问题：

假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？

- 只需要安装JRE就行了。JRE体积很小，安装非常便捷快速。

问题：

为什么安装JDK的时候会自带一个JRE？

- 因为java程序员开发完程序之后，要测试这个程序，让这个程序运行起来，需要JRE。所以JDK安装的时候内部自带一个JRE。

Java体系的技术被划分为三大块：

- JavaSE：标准版
- JavaEE：企业版
- JavaME：微型版

安装JDK之后：

- JDK：java开发工具箱
- JRE：Java运行环境
- JVM：Java虚拟机

### 对Java的加载与执行的理解

java程序从编写到最终运行经历了哪些过程？

java程序非常重要的两个阶段：

- 编译阶段
- 运行阶段

注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。（不同的操作系统上编译生成的字节码也是一样的）

java代码这种普通文本被称为：java源代码。（你编写的代码是源代码）源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。

编译阶段和运行阶段可以在不同的操作系统上完成吗？

在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行**完全可以**，因为Java是跨平台的。可以做到一次编写到处运行。

java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？

**完全可以**执行，因为<u>源代码不参与程序的执行过程</u>。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。

- 放源代码的文件扩展名必须是：xxx.java
- 并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class
- .java文件就是源文件，这个文件中编写源代码。
- .class文件就是字节码文件，这个文件是编译源代码而得到的。
- 1个java源文件是可以编译生成多个class文件的。
- 最终运行的是class文件。

问题：字节码文件是二进制文件吗？

字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。

java程序从开发到最终运行经历了什么？

- 编译期：（可以在windows上）
	- 第一步：在硬盘的某个位置（随意），新建一个xxx.java文件
	- 第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件
	- 第三步：在xxx.java文件中编写“符合java语法规则的”源代码。
	- 第四步：保存（一定要将xxx.java文件保存一下）
	- 第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。
	- 第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）
- 运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）
	- 第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）
	- 第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码
	- 第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）
	- 第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和
硬件进行交互。

![1592490248784](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592490248784.png)

注意：在以上的过程中，需要使用两个非常重要的命令？

- javac 命令，负责编译
- java 命令，负责运行

xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。

源文件中编写的代码叫做：源代码。

以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？

- 新建java文件
- 打开java文件
- 写java源代码
- 保存
- javac命令编译
- java命令运行

编写、编译、运行

### Hello World

第一步：安装文本编辑器

第二步：安装JDK（先下载JDK）安装JDK13，直接下一步就行。

JDK13安装的时候内置了一个JRE，独立于JDK之外的JRE并没有生成。对于java13来说，如果你希望生成一个独立于JDK之外的JRE的话需要执行特殊的命令。

注意：
JDK8安装的时候，不仅JDK内置了一个JRE，而且还会在JDK目录之外独立的生成一个单独的JRE。（以前低版本的时候，JRE实际上是有2个。）一个是JDK内置的，一个是独立于JDK之外的。

JDK的bin目录下有：

- javac.exe 负责编译
- java.exe 负责运行

第三步：写代码

第四步：编译

第五步：运行

#### 编译

怎么编译？使用什么命令？这个命令怎么用？

- 需要使用的命令是：C:\Program Files\Java\jdk-13.0.2\bin\javac.exe
- 这个命令需要先测试一下，打开DOS命令窗口，看看javac命令是否可用。

C:\Users\Administrator>javac

'javac' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这说明：windows操作系统没有发现“javac.exe”命令在哪里。windows操作系统没有找到javac.exe文件在哪。

为什么ipconfig、ping等命令可以使用呢？为什么javac用不了？

- 我们发现windows操作系统中有这样一个环境变量，名字叫做：path，并且发现path环境变量的值是：
  C:\Windows\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe

注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。

将path环境变量中的:C:\windows\system32; 删除之后再测试：C:\Users\Administrator>ipconfig
'ipconfig' 不是内部或外部命令，也不是可运行的程序或批处理文件。

配置环境变量path的步骤：

- 桌面计算机上右键-->属性-->高级系统设置-->环境变量

怎么修改path环境变量？

- 找到path，鼠标双击！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。

让javac.exe能用，我们配置哪个路径到path中？将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。

注意：

- 环境变量包括“系统变量”和“用户变量”
- 系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
- 用户变量：范围比较小，这个变量只是作用于当前用户。

怎么查看编译器版本？

C:\Users\Administrator><u>javac -version</u>
javac 13.0.2

怎么查看java虚拟机的版本？

C:\Users\Administrator><u>java -version</u>
java version "13.0.2" 2020-01-14
Java(TM) SE Runtime Environment (build 13.0.2+8)
Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)

问题1：path环境变量的作用是什么？

path环境变量的作用就是给windows操作系统指路的。<u>告诉windows操作系统去哪里找这个命令文件。</u>path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。path=A;B;C;D......path是环境变量的名字。A;B;C;D......是环境变量path的值。

问题2：path环境变量是java中的机制，还是windows操作系统中的机制？path环境变量是隶属于java的吗？path环境变量和java有关系吗？

path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。

要学会融会贯通，学一通百：

以后在安装其他软件之后，希望在DOS命令窗口中使用该软件的某个命令的时候，如果出现“命令找不到错误了”，这个时候希望大家能够想起来配置环境变量path。

path环境变量中的路径可以指定多个

javac命令怎么用？

语法格式先背会：javac java源文件的路径

什么是java源文件？

java源文件的名字以“.java”结尾，该文件中写了java源代码。java源文件的路径是什么意思？注意：路径永远包括绝对路径和相对路径。

注意：神操作？

把java**源文件直接拖进到DOS命令窗口**，那么DOS命令窗口就有这个路径了。

C:\Users\Administrator>javac D:\course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
D:\>javac course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
D:\course\JavaProjects>javac 02-JavaSE\chapter01\HelloWorld.java
D:\course\JavaProjects\02-JavaSE\chapter01>javac HelloWorld.java
以上的四种方式都行，第一种方式是绝对路径
剩下三种方式都是相对路径。

C:\Users\Administrator>javac course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
错误: 找不到文件: course\JavaProjects\02-JavaSE\chapter01\HelloWorld.java
用法: javac <选项> <源文件>
使用 --help 可列出可能的选项
以上报错的原因是：java源文件的路径写错了。

C:\Users\Administrator>javac HelloWorld.java
错误: 找不到文件: HelloWorld.java
用法: javac <选项> <源文件>
使用 --help 可列出可能的选项

注意：神操作？

- 怎么在DOS命令窗口中快速定位到某个路径呢？

- 打开计算机-->打开一些文件夹-->在地址栏上直接输入cmd回车，这样直接就过去了。

#### 运行

运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。

假设该文件的名字叫做：HelloWorld.class

那么HelloWorld被称为？HelloWorld 就是一个类名。

如果文件名是Test.class，那么：Test就是一个类名。

怎么运行，使用哪个命令？使用JDK的bin目录下的：java.exe命令来运行。

先在DOS命令窗口中测试java.exe这个命令是否可用！java -version

"java.exe"这个命令怎么用，语法格式是什么？java 类名

java HelloWorld.class 对不对？不对！正确的写法是：java HelloWorld

千万千万要注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”，因为java命令后面跟的不是文件，是一个“类名”。

对于这个类：Test.class   ，应该：java Test

到目前为止，一共配置了哪些环境变量？

到目前为止，我们只配置了一个环境变量path，并且这个环境变量path和java实际上没关系，是人家windows操作系统的机制。

对于Java的JDK所属的环境变量，有一个叫做：JAVA_HOME，这个JAVA_HOME目前我们不需要，不配置这个环境变量也不会影响当前java程序的运行。但是后期学习到**JavaWEB**的时候需要安装**Tomcat**服务器，那个时候JAVA_HOME就必须配置了。

那么除了JAVA_HOME环境变量之外，JDK相关的环境变量还有其他的吗？答案：有的。

#### java HelloWorld”的执行过程以及原理

D:\course\JavaProjects\02-JavaSE\chapter01>java HelloWorld 敲完回车，都发生了什么？？？？？

第一步：

会先启动**JVM**（java虚拟机）

第二步：

JVM启动之后，JVM会去启动“类加载器classloader”

类加载器的作用：

- 加载类的。本质上类加载器负责去硬盘上**找“类”对应的“字节码”文件**。
- 假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。
- 假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。
  .......

第三步：

类加载器如果在硬盘上找不到对应的字节码文件，会报错，报什么错？

- 错误: 找不到或无法加载主类

类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000...”这种二进制码，操作系统执行二进制码和硬件交互。

默认情况下，类加载器去硬盘上找“字节码”文件的时候，默认从哪找？

- 默认情况下类加载器（classloader）会从当前路径下找。

能不能给类加载器指定一个路径，让类加载器去指定的路径下加载字节码文件？

- 答案：可以的。但是我们需要设置一个环境变量，叫做：classpath

classpath是一个环境变量，是干啥的？

- 答案：是给“类加载器”指路的。

classpath环境变量**不属于**windows操作系统，classpath环境变量**隶属于java**

classpath环境变量是java特有的。
classpath=A路径;B路径;C路径.....
classpath是一个变量名，A路径;B路径;C路径.....是变量值

我们把classpath配置一下，这个环境变量在windows中没有，需要新建！
计算机-->右键-->属性-->高级系统设置-->环境变量-->新建...

注意：变量名不能随意写：大小写无所谓，但必须叫做：classpath

我目前是随意配置的：（重启CMD）classpath=D:\course

非常重要的一个特点，必须记住：配置了classpath=D:\course之后，类加载器只会去D:\course目录下找“xxx.class”文件，不再从当前路径下找了。

到目前为止：classpath环境变量不需要配置。但你必须理解classpath环境变量是干什么的！

你一定要理解classpath环境变量的作用是什么？

- 是给类加载器指路的。
- 在没有配置环境变量classpath的时候，默认从当前路径下加载。
- 如果配置了环境变量classpath的话，就只能从指定的路径下加载了。

path java_home classpath，这3个环境变量path需要配置，后面两个暂时不配置。


在高版本的JDK当中，有这样的一个新特性，可以直接这样一步到位：

java x/y/z/xxx.java

java后面直接加java源文件的路径。

这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。

#### 对于第一个程序的解释

```java
public class HelloWorld{ //类体开始
    //public：公开的
    //class：一个类
    //HelloWorld：类名
    //表示一个共有的类HelloWorld

    public static void main(String[] args){ //方法体开始
        //整个这一块的代码被称为：main方法（程序的入口，sUN公司java语言规定的）
        //也就是说：JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序不能执行
        //main方法也可以叫做主方法。
        //注意：方法必须放到类体中，不能放到类体外面。
        System.out.print("Hello "); //作用：向控制台输出一句话
        //如果println里面的事字符串，就应该用英文创引号括起来
        //
        System.out.println("World!");
    } //方法体结束

}//类体结束

//----------------------------------------------------------------------

//以下程序可以编译通过，但是无法运行，符合语法规则。

public class Test2{
}

/*
>java Test2
错误: 在类 Test2 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/

//---------------------------------------------------------------------

/*
没有语法错误，没有入口，能够编译通过，但是不能运行，因为没有main方法。

错误: 在类 Test3 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/
public class Test3{
    static void main(String[] args){
    
    }
}

//---------------------------------------------------------------------

public class Test4{
	// 注意：args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动
	public static void main(String[] fdsafdsafdsafdsa){
		System.out.println("hello world");
	}
}

//---------------------------------------------------------------------

// 以下程序符合java语法规则吗？不符合！
// 不是不运行，是编译报错。编译过不去，运行肯定不行。

public class Test5{

	// 类体当中应该是方法，而不是直接的java语句
	// 这里可以写吗？不可以！
	System.out.println("hello1");
	
	// 主方法，入口
	public static void main(String[] args){
	
	}

	// 这里可以写吗？不可以！
	System.out.println("hello2");
}

//---------------------------------------------------------------------

// main方法中什么也不写行吗？可以！
// 以下程序编译和运行可以吗？可以！
public class Test6{
	// 入口
	public static void main(String[] args){
	}
}

//---------------------------------------------------------------------

public class Test7{
	
	public static void main(String[] args){

		// 这个不加双引号行吗？ 可以，因为它是数字。
		System.out.println(100);

		// 是数字，加双引号行吗？
		System.out.println("100");

		// 以上性质一样吗？不一样：一个是字符串，一个是数字。
		// 但最终输出到控制台上一个样子，没啥区别。

		// 这里扩展一下：对于数字来说能进行加减乘除吗？
		// + - * / 能用吗 ？ 都可以！
		System.out.println(100 + 200); // 300
		System.out.println(200 - 100); // 100
		System.out.println(200 * 100); // 20000
		System.out.println(200 / 100); // 2
	}
}

class A{

}
class B{

}
class C{

}
class D{

} //编译成功并且生成了 四个类 A.class B.class C.class D.class
/*
	1、这个内容没有为什么，只能经过测试，然后根据测试结果进行记忆。

	2、第一个结论？
		一个java源文件中可以定义多个class。
	
	3、第二个结论？
		public的类不是必须的。可以没有。

	4、第三个结论？
		在源文件中只要有一个class的定义，那么必然会对应生成一个class文件。
	
	5、第四个结论？
		public的类可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。
	
	6、第五个结论？
		public的类有也只能有1个。
*/
class A{

}

/*
	Test8.java:20: 错误: 类 B 是公共的, 应在名为 B.java 的文件中声明
	public class B{
			 ^
	1 个错误
*/
/*
public class B{

}
*/

// 如果定义public的类你只能这样写
public class Test8{
}

class C{

}

class D{

}

//错误: 类重复: Test8
/*
public class Test8{
}
*/

//---------------------------------------------------------------------

// 编译通过了
// 能执行吗？
// 想从哪个入口进去执行，你就加载哪个类就行了！
// 例如：java T1
// 例如：java T2

// 测试不代表以后就这样写，一般一个软件的执行入口是一个。不会出现多个的。
// 以下只是一个测试罢了。
class T1{
	// 想从这个入口进去执行怎么办？java T1
	public static void main(String[] args){
		System.out.println("T1.....");
	}
}

class T2{
	// 想从这个入口进去执行怎么办？java T2
	public static void main(String[] args){
		System.out.println("T2.....");
	}
}
```

/**
javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。
*/

### Tips

- 终止程序用System.exit()  方法
- 函数调用 ：object.method(parameters)

## 标识符与关键字

### 标识符

```java

/*
	1、在java程序当中，使用EditPlus工具进行代码编写的时候，	有一些单词是蓝色，有的是红色，有的绿色，有的是黑色，有的是紫色，有的是粉色....

	2、注意：在java源代码当中，在EditPlus工具中显示的高亮颜色为黑色时,这个单词属于标识符。

	3、标识符可以标识什么？可以标识：类名 方法名 变量名 接口名 常量名......
	
	4、到底什么是标识符呢？一句话搞定：凡是程序员自己有权利命名的单词都是标识符。
	
	5、标识符可以随意编写吗，有命名规则吗？有
		什么是命名规则？命名规则属于语法机制，必须遵守，不遵守命名规则标识不符合语法，
			这样，编译器会报错。

		规则1：标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号（比如空格）。

		规则2：标识符不能以数字开头

		规则3：关键字不能做标识符。例如：public class static void 这些蓝色的字体都是关键字，关键字是不能做标识符的。

		规则4：标识符是严格区分大小写的。大写A和小写a不一样。

		规则5：标识符理论上是没有长度限制的。

*/

public class BiaoShiFuTest{
	// main是一个方法的名称，属于标识符
	// 但是这个标识符不能修改，因为这个main是SUN固定死的。
	public static void main(String[] args){
	}

	//doSome是一个方法名，可以改成其他的名字
	public static void doSome(){
		// k是一个变量名
		int k = 100;
		// nianLing 是一个变量名
		int nianLing = 20;
	}
}

/*
	class 123ABC{
	}

	编译报错，错误信息是：
		错误: 需要<标识符>
		错误原因：编译器检测到class这个单词，那么编译器会从class这个
		单词后面找类名，而类名是标识符，编译器找了半天没有找到标识符，
		因为123ABC不是标识符，所以编译器提示的错误信息是：需要<标识符>

		解决办法：
			将123ABC修改为合法的标识符。
*/

class Y123ABC{
}

// 类名是标识符，标识符“中”不能有空格
/*
编译器错误信息是：
	错误: 需要'{'
	编译器检测到class，然后找class后面的标识符，编译器找到了一个合法的标识符
	叫做“Hello”，然后编译器继续往后找“{”，结果没有找到“{”，所以报错了。

	解决办法：
		办法1：是把World删除
		办法2：把空格删除
*/
/*
class Hello World{
}
*/

class Hello{
}

class HelloWorld                   {
}

class _A{
}

class _$1Aa你{
}

// 错误: 需要<标识符>
// 关键字不能做标识符
/*
class public {
}
*/

// 这个可以，因为 public1 不是关键字，可以用。
class public1 {
}

class b {
}

class B {
}


// 虽然java中的标识符严格区分大小写
// 但是对于类名来说，如果一个java源文件中同时出现了：A类和a类
// 那么谁在前就生成谁。大家以后最好不要让类名“相同”。
// 最好类名是不同的。
class HelloWorld2{
}

class helloWorld2{
}

//---------------------------------------------------------------------

/*
	题目：
		创建一个java文件，起名 123.java可以吗？
			可以，完全可以，在windows操作系统中文件名叫做：123.java 没毛病。
		123其实并不是标识符。只是一个文件名。
		只不过在123.java文件中无法定义public的类。
	
	标识符除了命名规则之外，还有命名规范：
		1、命名规则和命名规范有什么区别？
			命名规则是语法，不遵守就会编译报错。
			命名规范只是说，大家尽量按照统一的规范来进行命名，不符合规范也行，
			代码是可以编译通过的，但是你的代码风格和大家不一样，这个通常也是
			不允许的。

			规则类似于：现实世界中的法律。
			规范类似于：现实世界中的道德。

			统一按照规范进行的话，代码的可读性很好。
			代码很容易让其它开发人员理解。

		2、具体的命名规范是哪些？

			规范1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）

			规范2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低...）
				  驼峰有利于单词与单词之间很好的进行分隔
				  BiaoShiFuTest，这个很好，一眼就能看出来是4个单词。

			规范3：类名、接口名有特殊要求
				  类名和接口名首字母大写，后面每个单词首字母大写。
					StudentTest、UserTest ，这是类名、接口名。

			规范4：变量名、方法名有特殊要求
				  变量名和方法名首字母小写，后面每个单词首字母大写。
					nianLing（NianLing这样就不符合了。）
					mingZi（MingZi这样也不符合了。）
			
			规范5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。
				  USER_AGE ：用户年龄
				  MATH_PI：固定不变的常量3.1415926.....
*/

public class IdentifierTest{
	public static void main(String[] args){
		// 主要看两个汉语拼音，可读性很强。
		// nianLing和mingZi都是黑色字体的标识符。
		int nianLing = 20;
		String mingZi = "zhangsan";
	}
}


class T{
}

// 在123.java文件中定义public的类可以吗？
// 因为之前有一条规则是这样说的：public的类可以没有
// 但如果有public的类，也只能有1个，并且public的类的
// 名字必须和源文件名保持一致。
//public class 123 { // 但是最终尴尬了，因为123不能做标识符。是错误的标识符。
//}
```

每一天你会编写很多程序，你会遇到很多编译错误，也会遇到很多运行错误，你是否需要准备一个单独的文件来记录这些信息，以及记录这些信息是怎么导致的，原因是什么，怎么去解决的，解决办法是啥？**非常有必要的**，要想成为一个调错高手，这个有必要进行一下。

![1592573820690](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592573820690.png)

### 关键字

什么是关键字？在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。

凡是在EditPlus中以蓝色字体形式存在的都是关键字，具有特殊含义。

切记：java语言中的所有关键字都是全部小写。注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。

### Tips

- java 中整型的范围与运行代码的机器无关
- 从java7开始，加上前缀0b或者0B就可以写二进制数，比如0b10100
- 还可以为数字加上下划线，如1_0000_0000,等价于100000000
- 在C/C++中，int和long等类型的大小与平台直接相关，int型在16位的平台上占用2字节的大小，在32位的平台上占用4字节的大小，在Java中，占用的大小是固定的，与平台无关。
- Java中没有任何的无符号整型
- Java无法精确打印出2.0-1.1的结果的原因（0.89999999而不是0.9）
  - 浮点数采用二进制数表示，但是二进制系统中无法精确的表示分数1/10
- 强烈建议不要使用char类型，除非确实需要处理UTF-16的代码单元
- 不提倡在一行中声明多个变量，逐一声明变量可以提高程序的可读性

## 变量与数据类型

### 变量

字面量：字面量就是数据、数据就是字面量、是一个东西。在java语言中“数据”被称为“字面量”。

10 100 123 ：整型
1.34 3.14 2.0：浮点型
true false ：布尔型
'a' '国'：字符型
"a" "abc"  "国" "中国"：字符串型
10：整数，是一个数字
"10"：它不是数字，是一个字符串，或者说，它属于“文字类”的。性质完全不同，在计算机中的对应的二进制码也是完全不同的。

其中字符型和字符串型都是描述了现实世界中的文字，需要注意的是：

- 所有的字符型只能使用单引号括起来。
- 所有的字符串型只能使用双引号括起来。
- 字符型一定是单个字符才能成为“字符型”
	

在语法级别上怎么区分字符型和字符串型？

- 主要看是双引号还是单引号。
- 单引号的一定是字符型。
- 双引号的一定是字符串型。

什么是变量？

变量就是一个存数据盒子。（盒子大小谁来决定啊？数据类型）

在内存中的最基本的存储单元。

存数据用的，而且这个数据是可变的，所以叫做变量。

变量的使用

变量的三要素？
数据类型、变量名、值  （值就是数据，就是字面量。）
int i = 100;

java中的变量必须先声明，再赋值才能访问（必须手动赋值。）
int k; System.out.println(k); 这样是不行的。

可以在一行上声明多个变量：
int a, b, c = 100;
c变量赋值100，a,b变量只声明了没有赋值。
int a = 10, b = 20, c = 100;
也可以这样每个都赋值。

声明和赋值可以分开，也可以一起做！
int i;
i = 100; // 先声明再赋值
int k = 200; // 声明的同时赋值

在“同一个域”当中，变量名不能重名！但可以重新赋值
```java
{
    int i = 100;
    //double i = 2.0; // 重名了编译器会报错，不允许。
    i = 300; // 可以重新赋值。
}
```

什么叫做同一个域？一个大括号代表一个域。

变量的分类

根据位置进行分类：记住就行

```java
//在方法体当中声明的变量叫做局部变量。

public static void m1(){
//局部变量，方法执行结束之后内存释放。
    int k = 100;
    int i = 200;
}

//在方法体外以及类体内声明的变量叫做成员变量。
public class T{
public static void x(){

}
	// 成员变量
	int i = 200;
}

//变量的作用域
//出了大括号就不认识了。别的先别管。
{
	int i = 100;
	{
		//在这里可以访问i
	}
}
{
	//在这里是无法访问i变量。
}


/*
	变量的作用域？
		1、什么是作用域？
			变量的有效范围。
		2、关于变量的作用域，大家可以记住一句话：
			出了大括号就不认识了。（死记这句话。）
		3、java中有一个很重要的原则：
			就近原则。（不仅java中是这样，其它编程语言都有这个原则。）
			哪个离我近，就访问哪个。
*/

public class VarTest08{

	// 成员变量
	int i = 10000;

	public static void main(String[] args){
		// 局部变量
		int i = 100; // 这个i的有效范围是main方法。
		System.out.println(i); // 这个i是多少？

		// 同一个域当中，这是不允许的。
		//int i = 90;  

		for(int n = 0; n < 10; n++){ // 这里声明的n变量只属于for域。for结束后n释放没了。
			// 这里没有编写代码。
		}

		// for循环执行结束之后，在这里访问n变量可以吗？
		//System.out.println(n);  //错误: 找不到符号

		int k; // 属于main域。
		for(k = 0; k < 10; k++){

		}
	}

	// 这个方法怎么定义先不用管，后面会学习。
	public static void x(){
		// 在这个位置上能访问i吗？不能
		// 错误: 找不到符号
		// System.out.println(i); // i是无法访问的。

		// 可以定义一个变量起名i吗？
		// 这个i的有效范围是x方法。
		// 局部变量
		int i = 200; // 所以这个i和main方法中的i不在同一个域当中。不冲突。
	}
}
```


### 数据类型

数据类型有什么用？

- 数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。

数据类型在java语言中包括两种：

- 第一种：基本数据类型(8小种)
  基本数据类型又可以划分为4大类8小种：
  - 第一类：整数型 byte,short,int,long （没有小数的）
  - 第二类：浮点型 float,double （带有小数的）
  - 第三类：布尔型 boolean：只有两个值true和false，true表示真，false表示假
  - 第四类：字符型 char：java中规定字符型字面量必须使用单引号括起来。属于文字。
- 第二种：引用数据类型
  - 字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。
- java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。

整数型：byte short int long有什么区别？
浮点型：float和double有什么区别？
区别：占用的空间大小不同。

| 类型 | 占用字节数量(byte) | 取值范围|
| ---- | ------------------ |-----|
| byte | 1 | -128 ~ 127|
| short | 2 | -32768 ~ 32767 |
| int | 4   | -2147483648 ~ 2147483647|
| long | 8  | -2^63~2^63-1 |
| float | 4 | -2^31~2^31-1|
| double | 8  | -2^63~2^63-1|
| boolean | 1 | true、false |
|char | 2 | 0 ~ 65535 |

short和char实际上容量相同，不过char可以表示更大的数字。
因为char表示的是文字，文件没有正负之分，所以char可以表示更大的数字。

其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0。

对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。

什么是字符编码？
字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。字符编码是人为规定的。（是某个计算机协会规定的。）

字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。

关于字符编码的发展过程？

- 起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了战争而开发的，计算导弹的轨道....
- 后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文对应的字符编码方式是：ASCII码。

在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。具体的实现包括：UTF-8 UTF-16 UTF-32....

ASCII（'a'是97 'A'是65 '0'是48...）

#### 字符型：char

```java
/*
	字符型：
		char
		1、char占用2个字节。
		2、char的取值范围：[0-65535]
		3、char采用unicode编码方式。
		4、char类型的字面量使用单引号括起来。
		5、char可以存储一个汉字。
*/
public class CharTest01{
	public static void main(String[] args){
		// char可以存储1个汉字吗？
		// 可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。
		char c1 = '中';
		System.out.println(c1);

		char c2 = 'a';
		System.out.println(c2);

		// 0如果加上单引号的话，0就不是数字0了，就是文字0，它是1个字符。
		char c3 = '0';
		System.out.println(c3);

		// 错误: 不兼容的类型: String无法转换为char
		//char c4 = "a";

		// 错误: 未结束的字符文字
		//char c5 = 'ab';

		// 错误: 未结束的字符文字
		//char c6 = '1.08';

	}
}

//-----------------------转义字符------------------------------

/*
	关于java中的转义字符
*/
public class CharTest02{
	public static void main(String[] args){


		System.out.println("s");
		// 编译报错。
		//System.out.println(""");
		//System.out.println("\"");

		// 这个可以输出吗？
		// 这个不需要专门进行转义。
		// 这个 ' 在这里只是一个普通的字符，不具备特殊含义。
		System.out.println("'");

		//以下都有问题
		//System.out.println(''');
		//System.out.println(""");

		// 可以的。
		System.out.println("'这样呢'");

		// 编译报错，因为：4e2d 是一个字符串
		// 错误: 未结束的字符文字
		//char x = '4e2d';

		// 反斜杠u表示后面的是一个字符的unicode编码。
		// unicode编码是十六进制的。
		char x = '\u4e2d';
		System.out.println(x); // '中'
	}
}

/*
	1、整数能否直接赋值给char
	2、char x = 97;
		这个java语句是允许的，并且输出的结果是'a'
		经过这个测试得出两个结论：
			第一个结论：当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。

			第二个结论：当一个整数没有超出byte short char的取值范围的时候，
			这个整数可以直接赋值给byte short char类型的变量。
*/
public class CharTest03{
	public static void main(String[] args){
	
		char c1 = 'a';
		System.out.println(c1);

		// 这里会做类型转换吗？
		// 97是int类型（这是java中规定，默认当做int处理）
		// c2是char类型
		//char c2 = (char)97; // 不需要这样做。
		char c2 = 97;
		System.out.println(c2); // 'a'

		// char类型取值范围：[0~65535]
		char c3 = 65535; // 实际上最终是一个“看不懂”的字符。
		System.out.println(c3);

		//错误: 不兼容的类型: 从int转换到char可能会有损失
		//char c4 = 65536;

		// 怎么解决以上问题？
		char c4 = (char)65536;

		byte x = 1;
		short s = 1;
		char c = 1;

	}
}
```

#### 整数型：byte short int long

byte b = 127; // 可以直接赋值short s = 32767; // 可以直接赋值
char // 没有超出char的取值范围可以直接赋值给char变量吗?
浮点型：float double
布尔型：boolean

```java
/*
	开发的时候不用斤斤计较，直接选择使用int就行了。
*/
public class IntTest01{
	public static void main(String[] args){

		// 二进制（JDK8的新特性，低版本不支持。）
		int d = 0b10;
		System.out.println(d); // 2
	}
}


```

##### 过大整数的问题

```java
/*
	在java中有一条非常重要的结论，必须记住：
		在任何情况下，整数型的“字面量/数据”默认被当做int类型处理。（记住就行）
		如果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L/l
		建议使用大写L，因为小写l和1傻傻分不清。
*/
public class IntTest02{
	public static void main(String[] args){

		// 分析这个代码存在类型转换吗，以下代码什么意思？
		// 不存在类型转换
		// 100 这个字面量被当做int类型处理
		// a变量是int类型，所以不存在类型的转换。
		// int类型的字面量赋值给int类型的变量。
		int a = 100;
		System.out.println(a);

		// 分析这个程序是否存在类型转换？
		// 分析：200这个字面量默认被当做int类型来处理
		// b变量是long类型，int类型占4个字节，long类型占8个字节
		// 小容量可以自动转换成大容量，这种操作被称为：自动类型转换。
		long b = 200;
		System.out.println(b);

		// 分析这个是否存在类型转换？
		// 这个不存在类型转换。
		// 在整数型字面量300后面添加一个L之后，300L联合起来就是一个long类型的字面量
		// c变量是long类型，long类型赋值给long类型不存在类型转换。
		long c = 300L;
		System.out.println(c);

		// 题目：
		// 可以吗？存在类型转换吗？
		// 2147483647默认被当做int来处理
		// d变量是long类型，小容量可以自动赋值给大容量，自动类型转换
		long d = 2147483647; // 2147483647是int最大值。
		System.out.println(d);

		// 编译器会报错吗？为什么？
		// 在java中，整数型字面量一上来编译器就会将它看做int类型
		// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。
		// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648
		// 只不过2147483648本身已经超出了int范围。
		// 错误: 整数太大
		//long e = 2147483648;

		// 怎么解决这个问题呢？
		long e = 2147483648L;
		System.out.println(e);

	}
}

```

##### 自动类型转换和强制类型转换

```java

/*
	1、小容量可以直接赋值给大容量，称为自动类型转换。

	2、大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。但需要注意的是：加强制类型转换符之后，虽然编译通过了，但是运行的时候可能会损失精度。
*/

public class IntTest03{
	public static void main(String[] args){
		
		// 不存在类型转换
		// 100L是long类型字面量，x是long类型字面量。
		long x = 100L;

		// x是long类型，占用8个字节，而y变量是int类型，占用4个字节
		// 在java语言中，大容量可以“直接”赋值给小容量吗？不允许，没有这种语法。
		// 编译错误信息：错误: 不兼容的类型: 从long转换到int可能会有损失
		// int y = x;

		// 大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。
		// 底层是怎么进行强制类型转换的呢？
		// long类型100L：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
		// 以上的long类型100L强转为int类型，会自动将“前面”的4个字节砍掉：00000000 00000000 00000000 01100100
		int y = (int)x; // 这个(int)就是强制类型转换符，加上去就能编译通过。
						// 但是要记住：编译虽然过了，但是运行时可能损失精度。
		System.out.println(y); // 100

		// 定义变量a int类型，赋值100
		int a = 100;
		System.out.println(a);

		int b = a; // 将变量a中保存的值100复制一份给b变量。
		System.out.println(b);

	}
}

```

##### 强制类型转换的精度损失

```java
/*
	java中有一个语法规则：
		当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量。short 同理。
	
	这种语法机制是为了方便写代码，而存在的。
*/
public class IntTest04{
	public static void main(String[] args){
		// 分析：以下代码编译可以通过吗？
		// 300 被默认当做int类型
		// b变量是byte类型
		// 大容量转换成小容量，要想编译通过，必须使用强制类型转换符
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//byte b = 300;

		// 要想让以上的程序编译通过，必须加强制类型转换符
		// 虽然编译通过了，但是可能精度损失。
		// 300这个int类型对应的二进制：00000000 00000000 00000001 00101100
		// byte占用1个字节，砍掉前3个字节，结果是：00101100 (44)
		byte b = (byte)300;
		System.out.println(b); // 44

		// 这个编译能通过吗？
		// 1是int类型，默认被当做int类型来看。
		// x是byte类型，1个字节，大容量无法直接转换成小容量。
		// 按说是编译报错的。
		byte x = 1;
		byte y = 127;
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		byte z = 128;

		// 当整数型字面量没有超出short类型取值范围的时候，该字面量可以直接赋值给short
		// 类型的变量。
		short s = 1;
		short s1 = 32767;
		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s2 = 32768;
		System.out.println(s);

	}
}
```

##### 原码，补码和反码

```java
/*
	1、计算机在任何情况下都只能识别二进制
	2、计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”
		计算机采用补码形式存储数据的原因是：补码形式效率最高。
	3、什么是补码呢？
		实际上是这样的，二进制有：原码 反码 补码 
	4、记住：
		对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。
			int i = 1;
			对应的二进制原码：00000000 00000000 00000000 00000001
			对应的二进制反码：00000000 00000000 00000000 00000001
			对应的二进制补码：00000000 00000000 00000000 00000001
		对于一个负数来说：二进制原码、反码、补码是什么关系呢？
			byte i = -1;
			对应的二进制原码：10000001
			对应的二进制反码（符号位不变，其它位取反）：11111110
			对应的二进制补码（反码+1）：11111111
	5、分析 byte b = (byte)150;
		这个b是多少？
			int类型的4个字节的150的二进制码是什么？
				00000000 00000000 00000000 10010110
			将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：
				10010110
		
		千万要注意：计算机永远存储的都是二进制补码形式。也就是说上面
		10010110 这个是一个二进制补码形式，你可以采用逆推导的方式推算出
		这个二进制补码对应的原码是啥！！！！！！
			10010110 ---> 二进制补码形式
			10010101 ---> 二进制反码形式
			11101010 ---> 二进制原码形式 
*/
public class IntTest05{
	public static void main(String[] args){

		// 编译报错：因为150已经超出了byte取值范围，不能直接赋值，需要强转
		//byte b = 150;
		byte b = (byte)150;

		// 这个结果会输出多少呢？
		System.out.println(b); // -106
	}
}

```
##### byte, char, short 混合运算

```java
/*
	结论：byte、char、short做混合运算的时候，各自先转换成int再做运算。
*/
public class IntTest06{
	public static void main(String[] args){

		char c1 = 'a';
		byte b = 1;

		// 注意：这里的"+"是负责求和的
		System.out.println(c1 + b); // 98

		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = c1 + b; // 编译器不知道这个加法最后的结果是多少。只知道是int类型。

		// 这样修改行吗？
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = (short)c1 + b;

		short s = (short)(c1 + b);

		//short k = 98;

		int a = 1;
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		// short x = 1; 可以
		short x = a; // 不可以，编译器只知道a是int类型，不知道a中存储的是哪个值。
		System.out.println(x);
	}
}
```
##### 多种类型混合运算

```java
/*
	结论：多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。

	char+short+byte 这个除外。
	因为char + short + byte混合运算的时候，会各自先转换成int再做运算。
*/
public class IntTest07{
	public static void main(String[] args){
		
		long a = 10L;
		char c = 'a';
		short s = 100;
		int i = 30;

		// 求和
		System.out.println(a + c + s + i); //237

		// 错误: 不兼容的类型: 从long转换到int可能会有损失
		// 计算结果是long类型
		//int x = a + c + s + i;

		int x = (int)(a + c + s + i);
		System.out.println(x);

		// 以下程序执行结果是？
		// java中规定，int类型和int类型最终的结果还是int类型。
		int temp = 10 / 3; // / 是除号。（最终取整）
		System.out.println(temp); // 3.33333吗？结果是：3

		// 在java中计算结果不一定是精确的。
		int temp2 = 1 / 2;
		System.out.println(temp2); // 0

	}
}
```

#### 浮点型数据

```java
/*
	关于java语言中的浮点型数据
		浮点型包括：
			float		4个字节
			double		8个字节
		
		float是单精度
		double是双精度,更精确

		比如说：
			10.0 / 3 如果采用float来存储的话结果可能是：3.33333
			10.0 / 3 如果采用double来存储的话结果可能是：3.3333333333333
		
		但是需要注意的是，如果用在银行方面或者说使用在财务方面，double也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门使用在财务软件方面：java.math.BigDecimal （不是基本数据类型，属于引用数据类型。）
	
		float和double存储数据的时候都是存储的近似值。
		为什么？
			因为现实世界中有这种无限循环的数据，例如：3.3333333333333....数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源表示无限的数据，只能存储近似值。

		long类型占用8个字节。
		float类型占用4个字节。
		哪个容量大？
			注意：任意一个浮点型都比整数型空间大。
			float容量 > long容量。
	
	java中规定，任何一个浮点型数据默认被当做double来处理。如果想让这个浮点型字面量被当做float类型来处理，那么请在字面量后面添加F/f。
		1.0 那么1.0默认被当做double类型处理。
		1.0F 这才是float类型。（1.0f）
*/

public class FloatTest01{
	public static void main(String[] args){

		// 这个不存在类型转换
		// 3.1415926是double类型
		// pi是double类型
		double pi = 3.1415926;
		System.out.println(pi);

		// 这个可以吗？
		//错误: 不兼容的类型: 从double转换到float可能会有损失
		//float f = 3.14;

		// 怎么修改以上的代码呢？
		// 第一种方式:在字面量后面添加F/f
		//float f = 3.14f;
		//float f = 3.14F;

		// 第二种方式：强制类型转换，但可能损失精度。谨慎使用。
		float f = (float)3.14;
		System.out.println(f);

		// 分析这个程序，可以编译通过吗？
		// 错误: 不兼容的类型: 从double转换到int可能会有损失
		// 原理：先将5转换成double类型，然后再做运算，结果是double
		// 大容量无法直接赋值给小容量，需要强转。
		//int i = 10.0 / 5;

		// 怎么修改
		int i = (int)10.0 / 5;
		System.out.println(i); // 2

		// 可以这样修改吗？强转的时候只留下整数位。
		int x = (int)(10.0 / 5);
		System.out.println(x); // 2
	}
}

```

#### 布尔类型

```java
/*
	1、在java语言中boolean类型只有两个值，没有其他值：
		true和false。
		不像C或者C++，C语言中1和0也可以表示布尔类型。

	2、boolean类型在实际开发中使用在哪里呢？
		使用在逻辑判断当中，通常放到条件的位置上（充当条件）
*/
public class BooleanTest01{
	public static void main(String[] args){
		//错误: 不兼容的类型: int无法转换为boolean
		//boolean xingBie = 1;
	}
}
```

#### 类型转换

在类型转换的时候需要遵循哪些规则？

- 第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以
进行转换；

- 第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋
值给byte,short,char 类型的变量；

- 第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：
byte < short(char) < int < long < float < double，其中 short和 char
都占用两个字节，但是char 可以表示更大的正整数；

- 第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，
但运行时可能出现精度损失，谨慎使用；

- 第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；

- 第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；

### 运算符

- 算术运算符：+ - * / % ++ --
- 关系运算符： > >= < <= == !=
- 逻辑运算符：& | ! && ||
- 赋值运算符：= += -= *= /= %=
- 三目运算符：布尔表达式 ? 表达式 1 : 表达式 2 
- 字符串连接运算符：+

#### 逻辑运算符

```java

/*
	逻辑运算符：
		&	逻辑与（可以翻译成并且）
		|	逻辑或（可以翻译成或者）
		!	逻辑非（取反）
		&&	短路与
		||	短路或
	
	用普通话描述的话：100 大于 99 并且 100 大于 98 ，有道理
	用代码描述的话：100 > 99 & 100 > 98 --> true

	true & true --> true

	非常重要：
		逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。
		这是逻辑运算符的特点。
	
	100 & true 不行，语法错误。
	100 & 200 不行，没有这种语法。
	true & false 这样可以。

	100 > 90 & 100 > 101 --> false

	& 两边都是true，结果才是true
	| 有一边是true，结果就是true

*/	

		/*
			关于短路与 &&，短路或 ||
			其中重点学习短路与，短路或照葫芦画瓢。

			短路与&& 和 逻辑与 &有什么区别？
				首先这两个运算符的运算结果没有任何区别，完全相同。
				只不过“短路与&&”会发生短路现象。

			什么是短路现象呢？
				右边表达式不执行，这种现象叫做短路现象。

			什么时候使用&&，什么时候使用& ？
				从效率方面来说，&&比&的效率高一些。
				因为逻辑与&不管第一个表达式结果是什么，第二个表达式一定会执行。

				以后的开发中，短路与&&和逻辑与还是需要同时并存的。
					大部分情况下都建议使用短路与&&
					只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会
					选择逻辑与&。
		*/

		System.out.println(true & true); // true
		System.out.println(true & false); // false
		System.out.println(false & false); // false

		System.out.println(true && true); // true
		System.out.println(true && false); // false
		System.out.println(false && false); // false

		// 接下来需要理解一下什么是短路现象，什么时候会发生“短路”。
		int x = 10;
		int y = 11;
		// 逻辑与&什么时候结果为true（两边都是true，结果才是true）
		// 左边的 x>y 表达式结果已经是false了，其实整个表达式的结
		// 果已经确定是false了，按道理来说右边的表达式不应该执行。
		System.out.println(x > y & x > y++); 

		// 通过这个测试得出：x > y++ 这个表达式执行了。
		System.out.println(y); // 12

		//测试短路与&&
		int m = 10;
		int n = 11;
		// 使用短路与&&的时候，当左边的表达式为false的时候，右边的表达式不执行
		// 这种现象被称为短路。
		System.out.println(m > n && m > n++);
		System.out.println(n); // 11

		// 问题：什么时候发生短路或现象？
		// || 短路或
		// “或”的时候只要有一边是true，结果就是true。
		// 所以，当左边的表达式结果是true的时候，右边的表达式不需要执行，此时会短路。

	}
}
```

#### 赋值运算符

```java

/*
		扩展的赋值运算符？
			+=
			-=
			*=
			/=
			%=

			使用扩展赋值运算符的时候，永远都不会改变运算结果类型。
			byte x = 100;
			x += 1;
			x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。
			不管后面是多大的数字。
*/
public class OperatorTest04{
	public static void main(String[] args){

		// 研究：
		// i += 10 和 i = i + 10 真的是完全一样吗？
		// 答案：不一样，只能说相似，其实本质上并不是完全相同。
		byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
		System.out.println(x); // 100

		// 分析：这个代码是否能够编译通过？
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？

		// 使用扩展赋值运算符可以吗？
		// 可以的，所以得出结论：x += 1 和 x = x + 1不一样。
		// 其实 x += 1 等同于：x = (byte)(x + 1);
		x += 1;
		System.out.println(x); // 101

		// 早就超出byte的取值范围了。
		x += 199; // x = (byte)(x + 199);
		System.out.println(x); // 44 （当然会自动损失精度了。）

		int y = 100;
		y += 100;
		System.out.println(y); // 200

		y -= 100; // x = x - 100;
		System.out.println(y); // 100

		y *= 10; // x = x * 10;
		System.out.println(y); // 1000

		y /= 30; // x = x / 30;
		System.out.println(y); // 33

		y %= 10; // x = x % 10;
		System.out.println(y); // 3
		
	}
}

//-------------------特例

// 大家讨论最多的一个问题。
// 如果只是针对于面试题的话，建议死记硬背。
public class Homework01{
	public static void main(String[] args){
		int i = 10;
		i = i++;
		// 大部分同学都会认为这个i一定是11
		// 这个i变量最终的结果是10（惊讶）
		// 首先，第一点：这种代码以后不会有人写。
		// 其次：第二点：没必要讨论这个问题，因为在C++中运行结果确实是11.
		// java中运行结果是10
		// c++中运行结果是11
		// 为什么？因为java和c++的编译器是不同的人开发的。原理不同。
		System.out.println(i);
		
		// 在java语言中i++，这种表达式在执行的时候，会提前先将i变量找一个临时
		// 变量存储一下。(C++中并没有这样做。)
		/*
		int k = 10;
		k = k++;
		*/
		int k = 10;
		// k = k++;对应的是下面三行代码
		int temp = k;
		k++;
		k = temp;
		System.out.println(k);
	}
}

```

#### 字符串链接运算符

```java

/*
	+ 运算符：
		1、+ 运算符在java语言中有两个作用。
			作用1：求和
			作用2：字符串拼接

		2、什么时候求和？什么时候进行字符串的拼接呢？
			当 + 运算符两边都是数字类型的时候，求和。
			当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。

		3、一定要记住：字符串拼接完之后的结果还是一个字符串。
*/
```



#### 接收用户键盘输入

```java
/*
1、输出信息到控制台：
	System.out.println(...);
2、在java中怎么接收键盘的输入呢？
	先声明一下，这个代码看不懂很正常，因为这个代码是面向对象章节学习之后才能够理解。
	这个代码以后复制粘贴就行。

	前提：java.util.Scanner s = new java.util.Scanner(System.in); 
	接收一个整数怎么办？
		int num = s.nextInt();
		
	接收一个字符串怎么办？
		String str = s.next();
*/
public class KeyInput{
	public static void main(String[] args){

		// 创建一个键盘扫描器对象
		// s 变量名，可以修改。其它不能改。 
		java.util.Scanner s = new java.util.Scanner(System.in); //这行代码写一次就行了。

		// 接收用户的输入，从键盘上接收一个int类型的数据
		// 解释这行代码，尽量让大家明白：代码执行到这里的时候，会暂停下来
		// 等待用户的输入，用户可以从键盘上输入一个整数，然后回车，回车之后
		// i变量就有值了。并且i变量中保存的这个值是用户输入的数字。
		// i变量就是接收键盘数据的。
		int i = s.nextInt(); // i是变量名，s是上面的变量名
		System.out.println("您输入的数字是：" + i);

		// 代码执行到此处又会停下来，等待用户的输入。
		// 敲完回车，s.nextInt();代码执行结束。
		int j = s.nextInt();
		System.out.println("您输入的数字是：" + j);

		// 如果输入的不是数字，那么会出异常：InputMismatchException
		int m = s.nextInt();
		System.out.println("您输入的数字是：" + m);

		// 我怎么从键盘上接收一个字符串呢？
		// 程序执行到此处会停下来，等待用户的输入，用户可以输入字符串。
		String str = s.next();
		System.out.println("您输入了：" + str);

		// 完整的。
		System.out.print("请输入用户名：");
		String name = s.next();
		System.out.println("欢迎"+name+"回来");
	}
}
```

### Tips

- 在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层的变量，这样可能会导致程序设计的错误，所以在Java中不能这样做。
- Java的引用相当于C++的指针而不是引用，因为：
  - C++中没有空引用
  - 引用不能被赋值
- java中的null引用相当与C++中的NULL指针


## 控制语句和方法

### 控制语句

- 选择语句
	- if
	- switch
		- switch语句本质上是只支持int和String，但是byte,short,char也可以使用在switch语句当中，因为byte short char可以进行自动类型转换。
- 循环语句
	- for
	- while
	- do...while
- 转向语句
	- break
	- continue
	- return

**记住 ：Java的 int 和 boolean 不能转换 ！！！**

```java
/*
		怎么用break;语句终止指定的循环呢？
			第一步：你需要给循环起一个名字，例如：
				a: for(){
					b:for(){
					
					}
				}
			第二步：终止：break a;
*/
public class BreakTest01{

	public static void main(String[] args){

		// 以下讲解的内容，以后开发很少用。不要紧张。
		// 这种语法很少用，了解一下即可。
		a:for(int k = 0; k < 2; k++){ 
			b:for(int i = 0; i < 10; i++){
				if(i == 5){
					break a; // 终止指定的循环。
				}
				System.out.println("i ===> " + i); 
			}
		}

		System.out.println("呵呵");

	}
}

/*
		continue语句后面可以指定循环吗？
			可以的。
			这里就不再讲了，自己测试以下。
			a:for(;;更新表达式1){
				b:for(;;更新表达式2){
					if(){
						continue a;
					}
					code1;
					code2;
					code3;
				}
			}
*/

```

### 方法

方法定义的先后顺序没有关系。都可以。


方法怎么定义，语法机制是什么？

[修饰符列表] 返回值类型 方法名(形式参数列表){
	方法体; 
}

注意：
- [] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。
- 方法体由Java语句构成。
- 方法定义之后需要去调用，不调用是不会执行的。
		

关于修饰符列表：
- 修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static

于返回值类型：

- 第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short	int long float double boolean char String......
- 第二：什么是返回值？返回值一般指的是一个方法执行结束之后的结果。结果通常是一个数据，所以被称为“值”，而且还叫“返回值”。	方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。
		main{
			// 调用a方法
			a();..如果a方法执行结束之后有返回值，这个返回值返回给main了。
		}
		a(){}
	方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。
	
- 第三：当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。

- 第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用"return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。
	
- 第五：只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。

- 第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。
	
- 第七：除了void之外，剩下的都必须有“return 值;”这样的语句。

形式参数列表

- 简称：形参
- 注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。
- 形参的个数是：0~N个。
- public static void sumInt(){}
- public static void sumInt(int x){}
- 形参有多个的话使用“逗号,”隔开。逗号是英文的。形参的数据类型起决定性作用，形参对应的变量名是随意的。
	

方法体：
- 由Java语句构成。java语句以“;”结尾。方法体当中编写的是代码，完成某个特定功能。
- 在方法体中的代码遵循自上而下的顺序依次逐行执行。
- 在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。
	

怎么调用呢

- 类名.方法名(实际参数列表);	
- 实参和形参的类型必须一一对应，个数也要一一对应。

你定义了一个/抽取了一个方法出来，而这个方法确无法完成某个功能，那么你抽取的这个方法毫无意义。般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。

“类名.”是可以省略

- a()方法调用b()方法的时候，a和b方法都在同一个类中，“类名.”可以		省略。如果不在同一个类中“类名.”不能省略。

```java
	// 在同一个域当中，"return语句"下面不能再编写其它代码。编写之后编译报错。
	public static int m(){
		boolean flag = true;
		if(flag){
			return 1;
			//错误: 无法访问的语句
			//System.out.println("hello1");
		}
		// 这行代码和上面的代码hello1的区别是：不在同一个域当中。
		//System.out.println("hello2");
		return 0;
		// 错误: 无法访问的语句
		//System.out.println("hello3");
	}
```

![1592785676387](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592785676387.png)


#### 重载

注意：如果功能不相似，坚决要让方法名不一致。

重载条件

- 条件1：在同一个类当中
- 条件2：方法名相同
- 条件3：形式参数列表不同（类型、个数、顺序）

注意：
方法重载和返回值类型无关，和修饰符列表无关。

在java语言中，是怎么进行方法区分的？

- 首先java编译器会通过方法名进行区分。
- 但是在java语言中允许方法名相同的情况出现。
- 如果方法名相同的情况下，编译器会通过方法的参数类型进行方法的区分。


#### 递归

- 方法自身调用自身。

- 使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。
- StackOverflowError  原因：一直压栈，没有弹栈，栈内存不够用。

- 能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。JVM发生错误之后只有一个结果，就是退出JVM。当然，只有极少数情况下，只能用递归，其它代码解决不了问题。

- 当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？
也不一定。可能递归的太深了。栈内存不够了。因为一直在压栈。

- 在实际的开发中，不建议轻易的选择递归，能用for循环while循环代替的，尽量使用循环来做。因为循环的效率高，耗费的内存少。递归耗费的内存比较大，另外递归的使用不当，会导致JVM死掉。(但在极少数的情况下，不用递归，这个程序没法实现。)所以：递归我们还是要认真学习的。

- 在实际的开发中，假设有一天你真正的遇到了：StackOverflowError 你怎么解决这个问题，可以谈一下你的思路吗？
- 我来谈一下我的个人思路：
	- 第一步：先检查递归的结束条件对不对。如果递归结束条件不对，必须对条件进一步修改，直到正确为止。
	- 第二步：假设递归条件没问题，怎么办？这个时候需要手动的调整JVM的栈内存初始化大小。可以将栈内存的空间调大点。（可以调整大一些。）				
	- 第三步：调整了大小，如果运行时还是出现这个错误，没办法，只能继续扩大栈的内存大小。

(java -X)这个可以查看调整堆栈大小的参数

## 认识面向对象

面向过程有什么缺点？（耦合度高，扩展力差。）

- 面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B
步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果
关系结合在一起，假设其中任何一个因果关系出现问题（错误），此时
整个系统的运转都会出现问题。（代码和代码之间的耦合度太高，扩展力
太差。）

面向过程有什么优点？（快速开发）

- 对于小型项目（功能），采用面向过程的方式进行开发，效率较高。
不需要前期进行对象的提取，模型的建立，采用面向过程
方式可以直接开始干活。一上来直接写代码，编写因果关系。
从而实现功能。

什么是面向对象的开发方式？

- 采用面向对象的方式进行开发，更符合人类的思维方式。（面向对象成为主流的原因）人类就是以“对象”的方式去认识世界的。所以面向对象更容易让我们接受。
- 面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后给一个环境驱动一下，让各个对象之间协作起来形成一个系统。
- 采用面向对象的方式进行开发：耦合度低，扩展力强。
- 面向对象当中最主要“一词”是：对象。

什么是类？

- 实际上在现实世界当中是不存在的，是一个抽象的概念。是一个模板。是我们人类大脑进行“思考、总结、抽象”的一个结果。(主要是因为人类的大脑不一般才有了类的概念。)
- 类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的概念就是一个“类”，“类”就是一个模板。

什么是对象？对象是实际存在的个体。（真实存在的个体）

这几个术语你需要自己能够阐述出来：

- 类：不存在的，人类大脑思考总结一个模板（这个模板当中描述了共同特征。）
- 对象：实际存在的个体。
- 实例：对象还有另一个名字叫做实例。
- 实例化：通过类这个模板创建对象的过程，叫做：实例化。
- 抽象：多个对象具有共同特征，进行思考总结抽取共同特征的过程。

类 --【实例化】--> 对象(实例)
对象 --【抽象】--> 类

类是一个模板，是描述共同特征的一个模板，那么共同特征包括什么呢？

类 = 属性 + 方法
属性来源于：状态
方法来源于：动作

思考：“java软件工程师”在开发中起到的一个作用是什么？

我们为什么要做软件开发？说的大一些是为了人民服务。解决现实生活当中的问题。软件开发既然是为了解决现实世界当中的问题，那么首先java软件必须能够模拟现实世界。其实软件是一个虚拟的世界。这个虚拟的世界需要和现实世界一一对应，这才叫模拟。

### 类的定义

```java
[修饰符列表] class 类名{
	// 类体 = 属性 + 方法
	// 属性在代码上以“变量”的形式体现
	//方法描述动作、行为
}
```

```java
`public class XueSheng{ // 这个程序编译之后，会生成XueSheng.class字节码文件。
	// 属性
	// 学号（成员变量）
	int xueHao;
	// 姓名
	String xingMing;
	// 年龄
	int nianLing;
	// 性别
	boolean xingBie;
	// 住址
	String zhuZhi;
}
```



![1592798494719](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592798494719.png)

注意：修饰符列表可以省略。

为什么属性是“以”变量的形式存在的？是因为属性对应的是“数据”，数据在程序中只能放到变量中。结论：属性其实就是变量。

变量根据出现位置进行划分：

- 方法体当中声明的变量：局部变量。
- 方法体外声明的变量：成员变量。（这里的成员变量就是“属性”）

关于编译的过程

- 按说应该先编译XueSheng.java，然后再编译XueShengTest.java
- 但是对于编译器来说，编译XueShengTest.java文件的时候，会自动找XueSheng.class，如果没有，会自动编译XueSheng.java文件，生成XueSheng.class文件。

编译方法：

- 第一种方式：
javac XueSheng.java
javac XueShengTest.java

- 第二种方式：
javac XueShengTest.java

- 第三种方式：
javac *.java

在语法级别上是怎么完成对象创建的呢？

- 类名 变量名 = new 类名();


什么是实例变量？

- 对象又被称为实例。
- 实例变量实际上就是：对象级别的变量。
public class 明星类{
double height;
}
- 身高这个属性所有的明星对象都有，但是每一个对象都有“自己的身高值”。
- 假设创建10个明星对象，height变量应该有10份。
- 所以这种变量被称为对象级别的变量。属于实例变量。

实例变量在访问的时候，是不是必须先创建对象？

对象和引用的区别？

- 对象是通过new出来的，在堆内存中存储。
- 引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。

成员变量的默认值

|类型|默认值|
| ----- | ----- |
|   byte | 0 |
| short | 0|
| int | 0|
| long | 0L|
|float | 0.0F|
|double | 0.0|
| boolean | flase|
|char | \u0000|
|引用数据类型| null|

### 内存图

1、画内存图注意事项：

- 第一：大家在内存图上不要体现出代码。内存上应该主要体现“数据”。

- 第二：大家画图的时候，图上的图形应该有先后顺序，先画什么，再画什么，必须是有顺序的，而不是想起来这个画这个，想起来那个画那个。程序代码是有执行顺序的，程序执行到哪里你就画哪里就行了。

2、为什么要画内存图（非常重要）？

- 第一：有了内存图，程序不运行，我也知道结果。（可以推算出结果）
- 第二：有了内存图，有助于你调试程序。画内存图是对Java运行机制的一种理解。不知道运行机制，以后复杂的程序出现错误之后你是不会调试的。

```java

/*
			所有的实例变量（属性）都是通过“引用.”来访问的。
	
	引用和对象怎么区分？
		“引用”是啥？是存储对象内存地址的一个变量。
		“对象”是啥？堆里new出来的。
	
	通俗一点：
		只要这个变量中保存的是一个对象的内存地址，那么这个变量就叫做“引用”。
	
	思考：
		引用一定是局部变量吗？
			不一定。
*/
public class Test{
	public static void main(String[] args){

		// 家庭住址对象
		Address a = new Address();
		a.city = "北京";
		a.street = "大兴区";
		a.zipcode = "121221";
		
		// 用户对象
		User u = new User();
		System.out.println(u.id); // 0
		System.out.println(u.username); // null
		System.out.println(u.addr); // null

		u.id = 11111;
		u.username = "zhangsan";
		u.addr = a;

	}
}

public class User{

	int id; // 实例变量

	String username; // 实例变量

	Address addr; 
}


// 住址类
public class Address{

	// 一个家庭住址有3个属性。

	// 城市
	String city; // 实例变量

	// 街道
	String street;

	// 邮编
	String zipcode;
}

```
![1592877765151](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592877765151.png)

### 空指针异常

```java
/*
	空指针异常。（NullPointerException）

	关于垃圾回收器：GC
		在java语言中，垃圾回收器主要针对的是堆内存。
		当一个java对象没有任何引用指向该对象的时候，
		GC会考虑将该垃圾数据释放回收掉。

	出现空指针异常的前提条件是？
		"空引用"访问实例【对象相关】相关的数据时，都会出现空指针异常。
*/
public class NullPointerTest{
	public static void main(String[] args){
		// 创建客户对象
		Customer c = new Customer();
		// 访问这个客户的id
		System.out.println(c.id); // 0

		// 重新给id赋值
		c.id = 9521; // 终身代号
		System.out.println("客户的id是=" + c.id);
		//c = null;
		// NullPointerException
		// 编译器没问题，因为编译器只检查语法，编译器发现c是Customer类型，
		// Customer类型中有id属性，所以可以：c.id。语法过了。
		// 但是运行的时候需要对象的存在，但是对象没了，尴尬了，就只能出现一个异常。
		System.out.println(c.id);
	}
}

class Customer{
	// 客户id
	int id; // 成员变量中的实例变量，应该先创建对象，然后通过“引用.”的方式访问。
}
```

![1592878637533](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592878637533.png)


方法在调用的时候参数是如何传递的？
- 实际上，在java语言中，方法调用时参数传递，和类型无关，都是将变量中保存的那个“值”传过去，这个“值”可能是一个数字100，也可能是一个java对象的内存地址：0x1234记住这句话：不管是哪一种数据类型的传递，都是将“变量中保存的那个值复制一份传递过去。”

```java

/*
	java中关于方法调用时参数传递实际上只有一个规则：
		不管你是基本数据类型，还是引用数据类型，实际上在传递的时候都是
		将变量中保存的那个“值”复制一份，传过去。

		int x = 1;
		int y = x; 把x中保存1复制一份传给y
		x和y都是两个局部变量。

		Person p1 = 0x1234;
		Person p2 = p1; 把p1中保存的0x1234复制一份传给p2
		p1和p2都是两个局部变量。

		你和你媳妇，都有你家大门上的钥匙，钥匙是两把。
		但是都可以打开你家的大门。

*/

public class Test2{
	public static void main(String[] args){
		Person p = new Person();
		p.age = 10;
		add(p);
		System.out.println("main--->" + p.age); //11
	}
	// 方法的参数可以是基本数据类型，也可以是引用数据类型，只要是合法的数据类型就行。
	public static void add(Person p){ // p是add方法的局部变量。
		p.age++;
		System.out.println("add--->" + p.age); //11
	}
}

class Person{
	// 年龄属性，成员变量中的实例变量。
	int age;
}
```

![1592884781662](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592884781662.png)

### 构造方法

当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参数的构造方法叫做缺省构造器。

当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。

建议将无参数构造方法手动的写出来，这样一定不会出问题。

无参数构造方法和有参数的构造方法都可以调用。

Student x = new Student();
Student y = new Student(123);

构造方法支持方法重载吗？

- 构造方法是支持方法重载的。
- 在一个类当中构造方法可以有多个。
- 并且所有的构造方法名字都是一样的。
- 特点：在同一个类中，方法名相同，参数列表不同。

对于实例变量来说，只要你在构造方法中没有手动给它赋值，统一都会默认赋值。默认赋系统值。

构造方法需要掌握的知识点：
1. 构造方法有什么作用？
2. 构造方法怎么定义，语法是什么？
3. 构造方法怎么调用，使用哪个运算符？
4. 什么是缺省构造器？
5. 怎么防止缺省构造器丢失？
6. 实例变量在类加载是初始化吗？实例变量在什么时候初始化？

```java
/*
	构造方法
		1、什么是构造方法，有什么用？
			构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化。换句话说：构造方法是用来创建对象，并且同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统会赋默认值。）

		2、重点（需要记忆）：当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法。（而这个构造方法被称为缺省构造器。）

		3、调用构造方法怎么调用呢？使用哪个运算符呢？使用new运算符来调用构造方法。
				语法格式：
					new 构造方法名(实际参数列表);
		
		4、构造方法的语法结构是？

			[修饰符列表] 构造方法名(形式参数列表){
				构造方法体;
				通常在构造方法体当中给属性赋值，完成属性的初始化。
			}

			注意：
				第一：修饰符列表目前统一写：public。千万不要写public static。

				第二：构造方法名和类名必须一致。

				第三：构造方法不需要指定返回值类型，也不能写void，写上void表示普通方法，就不是构造方法了。

			普通方法的语法结构是？
				[修饰符列表] 返回值类型 方法名(形式参数列表){
					方法体;
				}
*/
public class ConstructorTest01{
	public static void main(String[] args){

		// 调用Student类的无参数构造方法
		new Student();

		// 调用普通方法
		ConstructorTest01.doSome();
		doSome();

		// 创建Student类型的对象
		Student s1 = new Student();

		// 输出“引用”
		//只要输出结果不是null，说明这个对象一定是创建完成了。
		// 此处的输出结果大家目前是看不懂的，后期再说。
		System.out.println(s1); //Student@54bedef2

		// 这是调用另一个有参数的构造方法。
		Student s3 = new Student(100);
		System.out.println(s3); //Student@5caf905d
	}

	public static void doSome(){
		System.out.println("do some!!!!");
	}
}


/*
	1、构造方法对应的英语单词：Constructor【构造器】
	2、构造方法作用：
		创建对象，并且创建对象的过程中给属性赋值（初始化。）

	以后开发的时候最好自己写出来一个默认无参构造函数
*/

```

## 封装、this和static

### 封装

有了封装，才有继承，有了继承，才能说多态。

封装的作用有两个：

- 第一个作用：保证内部结构的安全。
- 第二个作用：屏蔽复杂，暴露简单。

在代码级别上，封装有什么用？

- 一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。
- 类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。

怎么进行封装

- 第一步：属性私有化（使用private关键字进行修饰。）
- 第二步：对外提供简单的操作入口。

第一步：属性私有化

第二步：1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。

在强调一下：
set和get方法都是实例方法，**不能带static**。
不带static的方法称为实例方法，实例方法的调用必须先new对象。

#### 封装过程

```java
// 尝试封装一下
// 不再对外暴露复杂的数据，封装起来
// 对外只提供简单的操作入口。
// 优点：第一数据安全了。第二调用者也方便了。
public class Person{
	// private 表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。
	// 出了这个类，age属性就无法访问了。私有的。
	private int age; // 每一个人年龄值不同，对象级别的属性。

	// 思考：你应该对外提供几个访问入口?
	// 思考：这些操作入口是否应该是方法呢？
	// 写一个方法专门来完成读。(get)
	// 写一个方法专门来完成写。(set)
	// get和set方法应该带有static，还是不应该有static,get和set方法应该定义为实例方法吗？
	// get读年龄，set改年龄，这个读和改都是操作的一个对象的年龄。（没有对象何来年龄）
	// 封装的第二步：对外提供公开的set方法和get方法作为操作入口。并且都不带static。都是实例方法。
	/*
		[修饰符列表] 返回值类型 方法名(形式参数列表){
		}

		注意：
			java开发规范中有要求，set方法和get方法要满足以下格式。
				get方法的要求：
					public 返回值类型 get+属性名首字母大写(无参){
						return xxx;
					}
				set方法的要求：
					public void set+属性名首字母大写(有1个参数){
						xxx = 参数;
					}
			
			大家尽量按照java规范中要求的格式提供set和get方法。
			如果不按照这个规范格式来，那么你的程序将不是一个通用的程序。

	*/
	// get方法
	public int getAge(){
		return age;
	}

	// set方法
	public void setAge(int nianLing){
		// 能不能在这个位置上设置关卡！！！！
		if(nianLing < 0 || nianLing > 150){
			System.out.println("对不起，年龄值不合法，请重新赋值！");
			return; //直接终止程序的执行。
		}
		//程序能够执行到这里，说明年龄一定是合法的。
		age = nianLing;
	}
}

```

#### static方法调用方式

```java
//带有static的方法
//没有static的方法
//分别怎么调用？
	//带有static的方法怎么调用？通过“类名.”的方式访问。

//对象被称为实例。
//实例相关的有：实例变量、实例方法。
//实例变量是对象变量。实例方法是对象方法。
//实例相关的都需要先new对象，通过“引用.”的方式去访问。
public class MethodTest{

	/*
	public MethodTest(){
	
	}
	*/

	public static void main(String[] args){
		MethodTest.doSome();
		//类名. 可以省略（在同一个类中。）
		doSome();
		// 尝试使用“类名.”的方式访问“实例方法”
		// 错误的
		//MethodTest.doOther();
		
		// 创建对象
		MethodTest mt = new MethodTest();
		// 通过"引用."的方式访问实例方法。
		mt.doOther();

	}	

	// 带有static
	public static void doSome(){
		System.out.println("do some!");
	}

	//这个方法没有static，这样的方法被称为：实例方法。（对象方法，对象级别的方法）
	//这个没法解释，大家目前死记硬背。
	public void doOther(){
		System.out.println("do other....");
	}

}
```

#### 再探空指针异常

```java

/*
空指针异常导致的最本质的原因是？
	空引用访问“实例相关的数据”，会出现空指针异常。
	实例相关的包括：实例变量 + 实例方法。
*/
public class NullPointerTest{
	public static void main(String[] args){
		User u = new User();
		System.out.println(u.id); // 0
		u.doSome();

		// 引用变成空null
		u = null;

		// id的访问，需要对象的存在。
		//System.out.println(u.id); // 空指针异常

		// 一个实例方法的调用也必须有对象的存在。
		//u.doSome(); // 空指针异常。
	}
}


// 类 = 属性 + 方法
// 属性描述状态
// 方法描述行为动作
class User{

	// 实例变量
	int id;

	// 实例方法（对象相关的方法，对象级别的方法，应该是一个对象级别的行为。）
	// 方法模拟的是对象的行为动作。
	public void doSome(){
		System.out.println("do some!");
	}

	// 考试的行为，由于每一个人考试之后的分数不一样，所以考试行为应该必须有对象的参与。
	public void exam(){
		
	}
}
```

### static

static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。

当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。

#### 实例和静态

```java
/*
	static:
		1、static翻译为“静态”
		2、所有static关键字修饰的都是类相关的，类级别的。
		3、所有static修饰的，都是采用“类名.”的方式访问。
		4、static修饰的变量：静态变量
		5、static修饰的方法：静态方法

	变量的分类：
		变量根据声明的位置进行划分：
			在方法体当中声明的变量叫做：局部变量。
			在方法体外声明的变量叫做：成员变量。

		成员变量又可以分为：
			实例变量
			静态变量
*/

class VarTest{

	// 以下实例的，都是对象相关的，访问时采用“引用.”的方式访问。需要先new对象。
	// 实例相关的，必须先有对象，才能访问，可能会出现空指针异常。
	// 成员变量中的实例变量
	int i;

	// 实例方法
	public void m2(){
		// 局部变量
		int x = 200;
	}


	// 以下静态的，都是类相关的，访问时采用“类名.”的方式访问。不需要new对象。
	// 不需要对象的参与即可访问。没有空指针异常的发生。
	// 成员变量中的静态变量
	static int k;

	// 静态方法
	public static void m1(){
		// 局部变量
		int m = 100;
	}
	
}

/*
	什么时候变量声明为实例的，什么时候声明为静态的？
		如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议定义为类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销。

	一个对象一份的是实例变量。
	所有对象一份的是静态变量。
*/

// 定义一个类：中国人
class Chinese{

	// 身份证号
	// 每一个人的身份证号不同，所以身份证号应该是实例变量，一个对象一份。
	String idCard; 

	// 姓名
	// 姓名也是一个人一个姓名，姓名也应该是实例变量。
	String name;

	// 国籍
	// 重点重点五颗星：加static的变量叫做静态变量
	// 静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。
	// 静态变量存储在方法区。
	static String country = "中国";

	// 无参数
	public Chinese(){
	
	}

	// 有参数
	public Chinese(String s1,String s2){
		idCard = s1;
		name = s2;
	}
}



/*
	实例的：一定需要使用“引用.”来访问。

	静态的：
		建议使用“类名.”来访问，但使用“引用.”也行（不建议使用"引用."）。
		静态的如果使用“引用.”来访问会让程序员产生困惑：程序员以为是实例的呢。
	
	结论：
		空指针异常只有在什么情况下才会发生呢?只有在“空引用”访问“实例”相关的，都会出现空指针异常。
*/

/*
	关于方法来说，什么时候定义为实例方法？什么时候定义为静态方法？
		有没有参考标准。

		此方法一般都是描述了一个行为，如果说该行为必须由对象去触发。
		那么该方法定义为实例方法。

		参考标准：
			当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。

			我们以后开发中，大部分情况下，如果是工具类的话，工具类当中的方法
			一般都是静态的。(静态方法有一个优点，是不需要new对象，直接采用类名
			调用，极其方便。工具类就是为了方便，所以工具类中的方法一般都是static的。)

			什么是工具类？？？？？
				以后讲。（工具类就是为了方便编程而开发的一些类。）
	
	类 = 属性 + 方法
		属性描述的是：状态
		方法描述的是：行为动作
	
	一个方法代表了一个动作。

*/
```

#### 静态代码块

```java

/*
	1、使用static关键字可以定义：静态代码块
	2、什么是静态代码块，语法是什么？
		static {
			java语句;
			java语句;
		}
	3、static静态代码块在什么时候执行呢？
		类加载时执行。并且只执行一次。
		静态代码块有这样的特征/特点。

	4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。

	5、静态代码块一般是按照自上而下的顺序执行。

	6、静态代码块有啥作用，有什么用？
		第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）
		第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻/时机。这个时机叫做：类加载时机。

	具体的业务：
		项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。
	思考：这些记录日志的代码写到哪里呢？
		写到静态代码块当中。
		
*/
public class StaticTest06{

	// 静态代码块（特殊的时机：类加载时机。）
	static {
		System.out.println("A");
	}

	// 一个类当中可以编写多个静态代码块
	static {
		System.out.println("B");
	}

	// 入口
	public static void main(String[] args){
		System.out.println("Hello World!");
	}

	// 编写一个静态代码块
	static{
		System.out.println("C");
	}
}

/*
A
B
C
Hello World!
*/


/*
	栈：方法只要执行，会压栈。（局部变量）
	堆：new出来的对象都在堆中。垃圾回收器主要针对。（实例变量）
	方法区：类的信息，字节码信息，代码片段。（静态变量）

	方法的代码片段放在方法区，但是方法执行过程当中需要的内存在栈中。
*/
public class StaticTest07{
	
	// 静态变量在什么时候初始化？类加载时初始化。
	// 静态变量存储在哪里？方法区
	static int i = 100;

	// 静态代码块什么时候执行？类加载时执行。
	static {
		// 这里可以访问i吗？
		System.out.println("i = " + i);
	}

	// 实例变量
	int k = 111; // k变量是实例变量，在构造方法执行时内存空间才会开辟。

	static {
		//k变量可以访问吗？
		// static静态代码块在类加载时执行，并且只执行一次。
		// 类加载时，k变量空间还没有开辟出来呢。
		//错误: 无法从静态上下文中引用非静态 变量 k
		//System.out.println("k = " + k);

		// 这里可以访问name吗？
		//错误: 非法前向引用
		// 静态代码块和静态变量都在类加载的时候执行，时间相同，只能靠代码的顺序来决定谁先谁后。
		//System.out.println("name = " + name);
	}

	// 静态变量在静态代码块下面。
	static String name = "zhangsan";


	//入口(main方法执行之前实际上执行了很多代码)
	public static void main(String[] args){
		System.out.println("main begin");
		System.out.println("main over");
	}
}

/*
总结：
	到目前为止，你遇到的所有java程序，有顺序要求的是哪些？
		第一：对于一个方法来说，方法体中的代码是有顺序的，遵循自上而下的顺序执行。
		第二：静态代码块1和静态代码块2是有先后顺序的。
		第三：静态代码块和静态变量是有先后顺序的。(代码的顺序)
*/
```

#### 实例语句块

```java
/*
1、除了静态代码块之外，还有一种语句块叫做：实例语句块
2、实例语句在类加载是并没有执行。
3、实例语句语法？
	{
		java语句;
		java语句;
		java语句;
	}
4、实例语句块在什么时候执行？
	只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。
	实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。
*/
public class InstanceCode{

	//入口
	public static void main(String[] args){
		System.out.println("main begin");
		new InstanceCode();
		new InstanceCode();

		new InstanceCode("abc");
		new InstanceCode("xyz");
	}


	//实例语句块
	{
		System.out.println("实例语句块执行！");	
	}

	// Constructor
	public InstanceCode(){
		System.out.println("无参数构造方法");
	}

	// Constructor
	public InstanceCode(String name){
		System.out.println("有参数的构造方法");
	}

}
```

#### 代码执行顺序

```java
//判断以下程序的执行顺序
public class CodeOrder{
	
	// 静态代码块
	static{
		System.out.println("A");
	}

	// 入口
	// A X Y C B Z
	public static void main(String[] args){
		System.out.println("Y");
		new CodeOrder();
		System.out.println("Z");
	}

	// 构造方法
	public CodeOrder(){
		System.out.println("B");
	}

	// 实例语句块
	{
		System.out.println("C");
	}

	// 静态代码块
	static {
		System.out.println("X");
	}

}
```

### this

- this是一个关键字，是一个引用，保存内存地址指向自身。
- this可以使用在实例方法中，也可以使用在构造方法中。
- this出现在实例方法中其实代表的是当前对象。
- this不能使用在静态方法中。
- this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。
- this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。

```java
/*
	this：
		1、this是一个关键字，全部小写。
		2、this是什么，在内存方面是怎样的？
			一个对象一个this。
			this是一个变量，是一个引用。this保存当前对象的内存地址，指向自身。
			所以，严格意义上来说，this代表的就是“当前对象”
			this存储在堆内存当中对象的内部。

		3、this只能使用在实例方法中。谁调用这个实例方法，this就是谁。所以this代表的是：当前对象。

		4、“this.”大部分情况下是可以省略的。

		5、为什么this不能使用在静态方法中？this代表当前对象，静态方法中不存在当前对象。
*/

// 顾客类
class Customer{

	// 属性
	// 实例变量（必须采用“引用.”的方式访问）
	String name;   

	//构造方法
	public Customer(){
	
	}

	public Customer(String s){
		this.name = s;
	}

	// 顾客购物的方法
	// 实例方法
	public void shopping(){
		// 这里的this是谁？this是当前对象。
		// c1调用shopping(),this是c1
		// c2调用shopping(),this是c2
		//System.out.println(this.name + "正在购物!");

		// this. 是可以省略的。
		// this. 省略的话，还是默认访问“当前对象”的name。
		System.out.println(name + "正在购物!");
	}

	// 静态方法
	public static void doSome(){
		// this代表的是当前对象，而静态方法的调用不需要对象。矛盾了。
		// 错误: 无法从静态上下文中引用非静态 变量 this
		//System.out.println(this);
	}
}

class Student{

	// 实例变量，怎么访问？必须先new对象，通过“引用.”来访问。
	String name = "zhangsan";

	// 静态方法
	public static void m1(){
		//System.out.println(name);

		// this代表的是当前对象。
		//System.out.println(this.name);

		// 除非你这样
		Student s = new Student();
		System.out.println(s.name);

	}

	//为什么set和get方法是实例方法？this不能出现在静态方法中
	public static void setName(String s){
		name = s;
	}
	public String getName(){
		return name;
	}

	// 又回到上午的问题了？什么时候方法定义为实例方法，什么时候定义为静态方法？
	// 如果方法中直接访问了实例变量，该方法必须是实例方法。
}
```


![1592899792382](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592899792382.png)

```java

// 分析：i变量在main方法中能不能访问？？？？

public class ThisTest02{

	// 实例变量
	int i = 100; // 这个i变量是不是必须先new对象才能访问。

	// 静态变量
	static int k = 111;

	// 静态方法
	public static void main(String[] args){
		// 错误: 无法从静态上下文中引用非静态 变量 i
		// System.out.println(i);

		// 怎么样访问i
		ThisTest02 tt = new ThisTest02();
		System.out.println(tt.i);

		// 静态变量用“类名.”访问。
		System.out.println(ThisTest02.k);

		// 类名. 能不能省略？
		// 可以
		System.out.println(k);
	}
}
```

this什么时候可以省略？

```java

/*
1、this可以使用在实例方法中，不能使用在静态方法中。
2、this关键字大部分情况下可以省略，什么时候不能省略呢？
	在实例方法中，或者构造方法中，为了区分局部变量和实例变量，
	这种情况下：this. 是不能省略的。
*/
public class ThisTest03{
	public static void main(String[] args){

		Student s = new Student();
		s.setNo(111);
		s.setName("张三");
		System.out.println("学号：" + s.getNo());
		System.out.println("姓名：" + s.getName());
	}
}

// 分析一下：以下代码哪里写的不好。
// 学生类
class Student{
	//学号
	private int no;

	//姓名
	private String name;

	// setter and getter方法
	/*
	public void setNo(int i){
		no = i;
	}
	*/
	/*
	public void setNo(int no){ // 就近原则。
		no = no; //这两个no都是局部变量no，和实例变量no没关系。
	}
	*/
	public void setNo(int no){ 
		//no是局部变量
		//this.no 是指的实例变量。
		this.no = no; // this. 的作用是：区分局部变量和实例变量。
	}
	
	public String getName(){ // getName实际上获取的是“当前对象”的名字。
		//return this.name; // 严格来说，这里是有一个 this. 的。只不过这个 this. 是可以省略的。
		return name;
	}
}
```

this()的使用时机

```java
/*
	1、this除了可以使用在实例方法中，还可以用在构造方法中。
	2、新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：
		this(实际参数列表);
			通过一个构造方法1去调用构造方法2，可以做到代码复用。
			但需要注意的是：“构造方法1”和“构造方法2” 都是在同一个类当中。

	3、this() 这个语法作用是什么？
		代码复用。
	
	4、死记硬背：
		对于this()的调用只能出现在构造方法的第一行。
*/
public class ThisTest04{
	public static void main(String[] args){
		// 调用无参数构造方法
		Date d1 = new Date();
		d1.detail();

		// 调用有参数构造方法
		Date d2 = new Date(2008, 8, 8);
		d2.detail();
	}
}

/*
需求：
	1、定义一个日期类，可以表示年月日信息。
	2、需求中要求：
		如果调用无参数构造方法，默认创建的日期为：1970年1月1日。
		当然，除了调用无参数构造方法之外，也可以调用有参数的构造方法来创建日期对象。
*/
class Date{ // 以后写代码都要封装，属性私有化，对外提供setter and getter
	//年
	private int year;
	//月
	private int month;
	//日
	private int day;

	// 构造方法无参
	// 调用无参数构造方法，初始化的日期是固定值。
	public Date(){
		//错误: 对this的调用必须是构造器中的第一个语句
		this(1970, 1, 1);
	}
	// 构造方法有参数
	public Date(int year, int month, int day){
		this.year = year;
		this.month = month;
		this.day = day;
	}
}
```

this 复习
```java

public class Review{ // 类
	// 类加载机制中，是这样的：在程序执行之前，凡是需要加载的类全部加载到JVM当中。
	// 先完成加载才会执行main方法。
	static{
		System.out.println("Review类加载时执行！");
	}
	// 入口
	// 静态方法
	public static void main(String[] args){
		// 局部变量
		int i = 100;
		// 完成一个对象的一连串动作。
		// 一个学生在教室先学习，学习完成之后去餐厅吃饭。
		Student s1 = new Student();
		// 先学习，所有调用学习这个实例方法。
		s1.study();
		Student s2 = new Student();
	}
}

```

## 继承

继承的作用：
基本作用：子类继承父类，代码可以得到复用。（这个不是重要的作用，是基本作用。）
主要(重要)作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。

举例

```java

// 使用继承机制来解决代码复用问题。
// 继承也是存在缺点的：耦合度高，父类修改，子类受牵连。

// 银行账户类
// 账户的属性：账号、余额
class Account{ // 父类
	// 属性
	private String actno;
	private double balance;

	// 构造方法
	public Account(){
	
	}
	public Account(String actno, double balance){
		this.actno = actno;
		this.balance = balance;
	}

	// setter and getter
	public void setActno(String actno){
		this.actno = actno;
	}
	public String getActno(){
		return actno;
	}
	public void setBalance(double balance){
		this.balance = balance;
	}
	public double getBalance(){
		return balance;
	}
}

// 其它类型的账户：信用卡账户
// 账号、余额、信誉度
class CreditAccount extends Account{ //子类

	// 属性
	private double credit;

	// 构造方法
	public CreditAccount(){
	
	}

	public void doSome(){
		//错误: actno 在 Account 中是 private 访问控制
		//System.out.println(actno);
		// 间接访问
		//System.out.println(this.getActno());
		System.out.println(getActno());
	}

	// setter and getter方法
	public void setCredit(double credit){
		this.credit = credit;
	}
	public double getCredit(){
		return credit;
	}
	
}
```

### 相关特性

1. ①B类继承A类，则称A类为超类(superclass)、父类、基类，B类则称为子类(subclass)、派生类、扩展类。
class A{}
class B extends A{}
我们平时聊天说的比较多的是：父类和子类。superclass 父类, subclass 子类

2. java 中的继承只支持单继承，**不支持多继承**，C++中支持多继承，这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：class B extends A,C{ } 这是错误的。

3. 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，例如：class C extends B，class B extends A，也就是说，C 直接继承 B，其实 C 还间接继承 A。

4.  java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)

5.  java 中的类没有显示的继承任何类，则**默认继承 Object类**，Object类是java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有Object类型中所有的特征。

6.  继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CeditAccount 类

子类继承父类之后，能使用子类对象调用父类方法吗？可以，因为子类继承了父类之后，这个方法就属于子类了。当然可以使用子类对象来调用。

在实际开发中，满足什么条件的时候，我可以使用继承呢？
凡是采用“is a”能描述的，都可以继承。
例如：
Cat is a Animal：猫是一个动物
Dog is a Animal：狗是一个动物
CreditAccount is a Account：信用卡账户是一个银行账户
....

假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，
那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够
使用is a来描述。

我们研究了一下Object类当中有很多方法，大部分看不懂，其中有一个叫做toString()的，我们进行了测试，发现：System.out.println(引用); 当直接输出一个“引用”的时候，println()方法会先自动调用“引用.toString()”，然后输出toString()方法的执行结果。

## 方法覆盖和多态

### 方法覆盖

#### 何时使用

- 父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。

什么条件满足的时候构成方法覆盖？

- 第一：有继承关系的两个类
- 第二：具有相同方法名、返回值类型、形式参数列表
- 第三：访问权限不能更低。
- 第四：抛出异常不能更多。

```java
/*
	回顾一下方法重载！！！！
		什么时候考虑使用方法重载overload？
			当在一个类当中，如果功能相似的话，建议将名字定义的一样，这样
			代码美观，并且方便编程。
		
		什么条件满足之后能够构成方法重载overload？
			条件一：在同一个类当中
			条件二：方法名相同
			条件三：参数列表不同（个数、顺序、类型）

	--------------------------------------------------------------------------------

	什么时候我们会考虑使用“方法覆盖”呢？
		子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时，
		子类有权利对这个方法进行重新编写，有必要进行“方法的覆盖”。
	
	方法覆盖又叫做：方法重写（重新编写），英语单词叫做：Override、Overwrite，都可以。
	比较常见的：方法覆盖、方法重写、override

	重要结论：
		当子类对父类继承过来的方法进行“方法覆盖”之后，
		子类对象调用该方法的时候，一定执行覆盖之后的方法。

	当我们代码怎么编写的时候，在代码级别上构成了方法覆盖呢？
		条件一：两个类必须要有继承关系。
		条件二：重写之后的方法和之前的方法具有：
					相同的返回值类型、
					相同的方法名、
					相同的形式参数列表。
		条件三：访问权限不能更低，可以更高。（这个先记住。）
		条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少。（这个先记住）
	
	这里还有几个注意事项：（这几个注意事项，当学习了多态语法之后自然就明白了！）
		注意1：方法覆盖只是针对于方法，和属性无关。
		注意2：私有方法无法覆盖。
		注意3：构造方法不能被继承，所以构造方法也不能被覆盖。
		注意4：方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。

*/
public class OverrideTest02{
	public static void main(String[] args){
		Bird b = new Bird();
		b.move();
		b.sing(1000); //Animal sing....

		Cat c = new Cat();
		c.move();
	}
}

class Animal{
	public void move(){
		System.out.println("动物在移动！");
	}

	public void sing(int i){
		System.out.println("Animal sing....");
	}
}

class Bird extends Animal{

	// 对move方法进行方法覆盖，方法重写，override
	// 最好将父类中的方法原封不动的复制过来。（不建议手动编写）
	// 方法覆盖，就是将继承过来的那个方法给覆盖掉了。继承过来的方法没了。
	public void move(){
		System.out.println("鸟儿在飞翔！！！");
	}

	//protected表示受保护的。没有public开放。
	// 错误：正在尝试分配更低的访问权限; 以前为public
	/*
	protected void move(){
		System.out.println("鸟儿在飞翔！！！");
	}
	*/

	//错误：被覆盖的方法未抛出Exception
	/*
	public void move() throws Exception{
		System.out.println("鸟儿在飞翔！！！");
	}
	*/

	// 分析：这个sing()和父类中的sing(int i)有没有构成方法覆盖呢？
	// 没有，原因是，这两个方法根本就是两个完全不同的方法。
	// 可以说这两个方法构成了方法重载吗？可以。
	public void sing(){
		System.out.println("Bird sing.....");
	}
}
```


#### 关于Object类中toString()方法的覆盖

toString()方法存在的作用就是：将java对象转换成字符串形式。大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()方法输出的是一个java对象的内存地址。

至于toString()方法具体怎么进行覆盖？格式可以自己定义，或者听需求的。

```java
/*
	关于Object类中的toString()方法
		1、toString()方法的作用是什么？
			作用：将“java对象”转换成“字符串的形式”。

		2、Object类中toString()方法的默认实现是什么？
			public String toString() {
				return getClass().getName() + "@" + Integer.toHexString(hashCode());
			}
			toString: 方法名的意思是转换成String
			含义：调用一个java对象的toString()方法就可以将该java对象转换成字符串的表示形式。

		3、那么toString()方法给的默认实现够用吗？
*/
public class OverrideTest04{
	public static void main(String[] args){
		// 创建一个日期对象
		MyDate t1 = new MyDate();

		// 大家是否还记得：当输出一个引用的时候，println方法会自动调用引用的toString方法。
		System.out.println(t1);

		//创建学生对象
		Student s = new Student(1111, "zhangsan");
		// 重写toString()方法之前
		//System.out.println(s); //Student@87aac27
		// 重写toString()方法之后
		// 输出一个学生对象的时候，可能更愿意看到学生的信息，不愿意看到对象的内存地址。
		System.out.println(s.toString());
		System.out.println(s);//自动调用toString方法
	}
}

// 日期类
class MyDate {
	private int year;
	private int month;
	private int day;
	public MyDate(){
		this(1970,1,1);
	}
	// constructor
	...
	// setters and getters 
	...

	// 从Object类中继承过来的那个toString()方法已经无法满足我业务需求了。
	// 我在子类MyDate中有必要对父类的toString()方法进行覆盖/重写。
	// 我的业务要求是：调用toString()方法进行字符串转换的时候，
	// 希望转换的结果是：xxxx年xx月xx日，这种格式。
	// 重写一定要复制粘贴，不要手动编写，会错的。
	public String toString() {
		return year + "年" + month + "月" + day + "日";
	}
}

class Student{
	int no;
	String name;
	public Student(int no, String name){
		this.no = no;
		this.name = name;
	}
	// 重写  方法覆盖
	public String toString() {
		return "学号：" + no + "，姓名：" + name;
	}
}
```

#### 方法重载和方法覆盖的区别

方法重载发生在同一个类当中。
方法覆盖是发生在具有继承关系的父子类之间。
方法重载是一个类中，方法名相同，参数列表不同。
方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：方法名一致、参数列表一致、返回值类型一致。


### 多态

#### 多态的基础语法

向上转型和向下转型的概念

![1592956803661](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1592956803661.png)

向上转型：子--->父 (upcasting)
又被称为自动类型转换：Animal a = new Cat();

向下转型：父--->子 (downcasting)
又被称为强制类型转换：Cat c = (Cat)a; 需要添加强制类型转换符。

什么时候需要向下转型？
- 需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。

向下转型有风险吗？
- 容易出现ClassCastException（类型转换异常）

怎么避免这个风险？
- instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象
是否为某一种类型。

-> 养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。

不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。

```java
/*
	多态的基础语法：
		1、学习多态基础语法之前，我们需要普及两个概念：
			第一个：向上转型
				子 ---> 父（自动类型转换）
			第二个：向下转型
				父 ---> 子（强制类型转换，需要加强制类型转换符）

			注意：
				java中允许向上转型，也允许向下转型。

				*****（五颗星）无论是向上转型，还是向下转型，两种类型之间必须有继承关系，没有继承关系编译器报错。
				
				以后在工作过程中，和别人聊天的时候，要专业一些，说向上转型和向下转型，不要说自动类型转换，也不要说强制类型转换，因为自动类型转换和强制类型转换是使用在基本数据类型方面的，在引用类型转换这里只有向上和向下转型。
		
		2、多态指的是：
			父类型引用指向子类型对象。
			包括编译阶段和运行阶段。
			编译阶段：绑定父类的方法。
			运行阶段：动态绑定子类型对象的方法。
			多种形态。
		
		3、什么时候必须使用“向下转型”？
			不要随便做强制类型转换。当你需要访问的是子类对象中“特有”的方法。此时必须进行向下转型。
*/
public class Test01{

	public static void main(String[] args){

		Animal a1 = new Animal();
		a1.move(); //动物在移动！

		Cat c1 = new Cat();
		c1.move(); //cat走猫步！

		Bird b1 = new Bird();
		b1.move(); //鸟儿在飞翔！

		// 代码可以这样写吗？
		/*
			1、Animal和Cat之间有继承关系吗？有的。
			2、Animal是父类，Cat是子类。
			3、Cat is a Animal，这句话能不能说通？能。
			4、经过测试得知java中支持这样的一个语法：
				父类型的引用允许指向子类型的对象。
				Animal a2 = new Cat();
				a2就是父类型的引用。new Cat()是一个子类型的对象。允许a2这个父类型引用指向子类型的对象。
		*/
		Animal a2 = new Cat();
		Animal a3 = new Bird();

		// 没有继承关系的两个类型之间存在转型吗？
		// 错误: 不兼容的类型: Dog无法转换为Animal
		// Animal a4 = new Dog();（Dog没有继承Animal）

		// 调用a2的move()方法
		/*
			什么是多态？
				多种形态，多种状态。
			分析：a2.move();
				java程序分为编译阶段和运行阶段。
				先来分析编译阶段：
					对于编译器来说，编译器只知道a2的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()方法，找到了，绑定上move()方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）
				再来分析运行阶段：
					运行阶段的时候，实际上在堆内存中创建的java对象是Cat对象，所以move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行Cat对象的move()方法。这个过程属于运行阶段绑定。（运行阶段绑定属于动态绑定。）

			多态表示多种形态：
				编译的时候一种形态。
				运行的时候另一种形态。
		*/
		a2.move(); //cat走猫步！
		
		// 调用a3的move()方法
		a3.move(); //鸟儿在飞翔！！！

		// ======================================================================
		Animal a5 = new Cat(); // 底层对象是一只猫。

		// 分析这个程序能否编译和运行呢？
		// 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。
		// 只有编译通过的代码才能运行。没有编译，根本轮不到运行。
		// 错误: 找不到符号
		// why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法
		// 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）
		//a5.catchMouse(); 
		
		// 假设代码写到了这里，我非要调用catchMouse()方法怎么办？
		// 这个时候就必须使用“向下转型”了。（强制类型转换）
		// 以下这行代码为啥没报错？？？？
		// 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。
		Cat x = (Cat)a5;
		x.catchMouse(); //猫正在抓老鼠！！！！

		// 向下转型有风险吗？
		Animal a6 = new Bird(); //表面上a6是一个Animal，运行的时候实际上是一只鸟儿。
		/*
			分析以下程序，编译报错还是运行报错？？？
				编译器检测到a6这个引用是Animal类型，
				而Animal和Cat之间存在继承关系，所以可以向下转型。
				编译没毛病。

				运行阶段，堆内存实际创建的对象是：Bird对象。
				在实际运行过程中，拿着Bird对象转换成Cat对象就不行了。因为Bird和Cat之间没有继承关系。
			
			运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：
				java.lang.ClassCastException：类型转换异常。
			
			java.lang.NullPointerException：空指针异常。这个也非常重要。
		*/
		//Cat y = (Cat)a6;
		//y.catchMouse();

		// 怎么避免ClassCastException异常的发生？？？
		/*	
			新的内容，运算符：
				instanceof （运行阶段动态判断）
			第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。
			第二：instanceof的语法：(引用 instanceof 类型)
			第三：instanceof运算符的运算结果只能是：true/false
			第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。
				假设(c instanceof Cat)为true表示:c引用指向的堆内存中的java对象是一个Cat。
				假设(c instanceof Cat)为false表示:c引用指向的堆内存中的java对象不是一个Cat。
			
			程序员要养成一个好习惯：
				任何时候，任何地点，对类型进行向下转型时，一定要使用instanceof 运算符进行判断。（java规范中要求的。）
				这样可以很好的避免：ClassCastException
		*/
		System.out.println(a6 instanceof Cat); //false

		if(a6 instanceof Cat){ // 如果a6是一只Cat
			Cat y = (Cat)a6;  // 再进行强制类型转换
			y.catchMouse();
		}
	}
}
```

多种形态，多种状态，编译和运行有两个不同的状态。
编译期叫做静态绑定。
运行期叫做动态绑定。
Animal a = new Cat();
// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法
// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关
// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。
a.move();

多态的典型代码：父类型的引用指向子类型的对象。（java中允许这样写代码！！！）

什么时候必须进行向下转型？调用子类对象上特有的方法时。


#### 为什么要用instanceof

```java
public class AnimalTest{
	
	// test方法是程序员B负责编写。
	// 这个test()方法的参数是一个Animal
	public void test(Animal a){ // 实例方法
		// 你写的这个方法别人会去调用。
		// 别人调用的时候可能给你test()方法传过来一个Bird
		// 当然也可能传过来一个Cat
		// 对于我来说，我不知道你调用的时候给我传过来一个啥。
		if(a instanceof Cat){
			Cat c = (Cat)a;
			c.catchMouse();
		}else if(a instanceof Bird){
			Bird b = (Bird)a;
			b.sing();
		}
	}

}
```

#### 多态在开发中的作用

```java
/*

	注意这里的分析：
		主人起初的时候只喜欢养宠物狗狗
		随着时间的推移，主人又喜欢上养“猫咪”
		在实际的开发中这就表示客户产生了新的需求。
		作为软件的开发人员来说，必须满足客户的需求。
		我们怎么去满足客户的需求呢？
			在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。
	
	思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？
		一定要记住：软件在扩展过程当中，修改的越少越好。
		修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。

		其实这里涉及到一个软件的开发原则：
			软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：
				其中有一条最基本的原则：OCP（开闭原则）

		什么是开闭原则？
			对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。
			在软件的扩展过程当中，修改的越少越好。


	高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。

	什么是软件扩展性？
		假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。
		这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。

	面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。
	因为面向具体编程会让软件的扩展力很差。

*/
```

非常重要：五颗星。

多态在开发中的作用是：降低程序的耦合度，提高程序的扩展力。

```java
public class Master{
public void feed(Dog d){}
public void feed(Cat c){}
}

//以上的代码中表示：Master和Dog以及Cat的关系很紧密（耦合度高）。导致扩展力很差。

public class Master{
public void feed(Pet pet){
pet.eat();
}
}
//以上的代表中表示：Master和Dog以及Cat的关系就脱离了，Master关注的是Pet类。
//这样Master和Dog以及Cat的耦合度就降低了，提高了软件的扩展性。
```

有了封装，有了这种整体的概念之后。
对象和对象之间产生了继承。
有了继承之后，才有了方法的覆盖和多态。

这里提到了一个软件开发原则：
七大原则最基本的原则：OCP（对扩展开放，对修改关闭）
目的是：降低程序耦合度，提高程序扩展力。
面向抽象编程，不建议面向具体编程。


#### 解释之前遗留的问题

私有方法无法覆盖。

方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）

总结两句话：私有不能覆盖。静态不谈覆盖。

在方法覆盖中，关于方法的返回值类型。
什么条件满足之后，会构成方法的覆盖呢？

1. 发生具有继承关系的两个类之间。
2. 父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。


```java
/*
	1、方法覆盖需要和多态机制联合起来使用才有意义。
		Animal a = new Cat();
		a.move();
		要的是什么效果？
			编译的时候move()方法是Animal的。
			运行的时候自动调用到子类重写move()方法上。

		假设没有多态机制，只有方法覆盖机制，你觉得有意义吗？
			没有多态机制的话，方法覆盖可有可无。

			没有多态机制，方法覆盖也可以没有，如果父类的方法无法满足
			子类业务需求的时候，子类完全可以定义一个全新的方法。

		方法覆盖和多态不能分开。

	2、静态方法存在方法覆盖吗？
		多态自然就和对象有关系了。
		而静态方法的执行不需要对象。
		所以，一般情况下，我们会说静态方法“不存在”方法覆盖。
		不探讨静态方法的覆盖。

*/
public class OverrideTest05{
	public static void main(String[] args){
		// 静态方法可以使用“引用.”来调用吗？可以
		// 虽然使用“引用.”来调用，但是和对象无关。
		Animal a = new Cat(); //多态
		// 静态方法和对象无关。
		// 虽然使用“引用.”来调用。但是实际运行的时候还是：Animal.doSome()
		a.doSome();
		
		Animal.doSome();
		Cat.doSome();
	}
}

```

“相同的返回值类型”可以修改一下吗？

- 对于返回值类型是基本数据类型来说，必须一致。
- 对于返回值类型是引用数据类型来说，重写之后返回值类型可以变的更小（但意义不大，实际开发中没人这样写。）。

## super

### 与this相比

- super能出现在实例方法和构造方法中。
- super的语法是：“super.”、“super()”
- super不能使用在静态方法中。
- super. 大部分情况下是可以省略的。


```java
/*
	1、super是一个关键字，全部小写。
	2、super和this对比着学习。
		this:
			this能出现在实例方法和构造方法中。
			this的语法是：“this.”、“this()”
			this不能使用在静态方法中。
			this. 大部分情况下是可以省略的。
			this.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。
				public void setName(String name){
					this.name = name;
				}
			this() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中
			其它的构造方法，目的是：代码复用。

		super:
			super能出现在实例方法和构造方法中。
			super的语法是：“super.”、“super()”
			super不能使用在静态方法中。
			super. 大部分情况下是可以省略的。
			super.什么时候不能省略呢？ 
			super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
			的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

	3、super()
		表示通过子类的构造方法调用父类的构造方法。
		模拟现实世界中的这种场景：要想有儿子，需要先有父亲。
	
	4、重要的结论：
		当一个构造方法第一行：
			既没有this()又没有super()的话，默认会有一个super();
			表示通过当前子类的构造方法调用父类的无参数构造方法。
			所以必须保证父类的无参数构造方法是存在的。
	
	5、注意：
		this()和super() 不能共存，它们都是只能出现在构造方法第一行。
	
	6、无论是怎样折腾，父类的构造方法是一定会执行的。（百分百的。）
	
*/
public class SuperTest01{
	public static void main(String[] args){
		// 创建子类对象
		/*
			A类的无参数构造方法！
			B类的无参数构造方法！
		*/
		new B();
	}
}

class A{

	// 建议手动的将一个类的无参数构造方法写出来。
	public A(){
		//super(); // 这里也是默认有这一行代码的。
		System.out.println("A类的无参数构造方法！");
	}

	// 一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。
	// 一个类如果手动提供了一个构造方法，那么无参数构造系统将不再提供。
	public A(int i){
		//super();
		System.out.println("A类的有参数构造方法(int)");
	}
}

class B extends A{
	/*
	public B(){
		super();
		System.out.println("B类的无参数构造方法！");
	}
	*/

	public B(){
		this("zhangsan");
		// 调用父类中有参数的构造方法
		//super(123);
		System.out.println("B类的无参数构造方法！");
	}

	public B(String name){
		super();
		System.out.println("B类的有参数构造方法(String)");
	}
}
```



```java
/*
	1、举个例子：在恰当的时间使用：super(实际参数列表);
	2、注意：在构造方法执行过程中一连串调用了父类的构造方法，
	父类的构造方法又继续向下调用它的父类的构造方法，但是实际上
	对象只创建了一个。

	3、思考：“super(实参)”到底是干啥的？
		super(实参)的作用是：初始化当前对象的父类型特征。
		并不是创建新对象。实际上对象只创建了1个。
	
	4、super关键字代表什么？
		super关键字代表的就是“当前对象”的那部分父类型特征。
		
	5、 super和this都不能出现在静态方法中。
*/

```

super的使用：
super.属性名   【访问父类的属性】
super.方法名(实参)   【访问父类的方法】
super(实参)   【调用父类的构造方法】


### 什么时候可以省略

super.什么时候不能省略呢？
- 父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。

super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中
的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。

```java

/*
	1、“this.”和“super.”大部分情况下都是可以省略的。
	2、this. 什么时候不能省略？
		public void setName(String name){
			this.name = name;
		}
	3、super. 什么时候不能省略？
		父中有，子中又有，如果想在子中访问“父的特征”，super. 不能省略。
*/
	public void shopping(){
		/*
			java是怎么来区分子类和父类的同名属性的？
				this.name：当前对象的name属性
				super.name：当前对象的父类型特征中的name属性。
		*/
		System.out.println(this.name + "正在购物!"); // null 正在购物
		System.out.println(super.name + "正在购物!"); // 张三正在购物
		System.out.println(name + "正在购物!"); //null 正在购物
	}
}



/*
	在父和子中有同名的属性，或者说有相同的方法，
	如果此时想在子类中访问父中的数据，必须使用“super.”加以区分。

	super.属性名    【访问父类的属性】
	super.方法名(实参) 【访问父类的方法】
	super(实参)  【调用父类的构造方法】
*/



/*
	通过这个测试得出的结论：
		super 不是引用。super也不保存内存地址，super也不指向任何对象。
		super 只是代表当前对象内部的那一块父类型的特征。
*/
public class SuperTest06 {

	// 实例方法
	public void doSome(){
		// SuperTest06@2f92e0f4
		System.out.println(this);
		// 输出“引用”的时候，会自动调用引用的toString()方法。
		//System.out.println(this.toString());

		//编译错误: 需要'.'
		//System.out.println(super);
	}

	// this和super不能使用在static静态方法中。
	/*
	public static void doOther(){
		System.out.println(this);
		System.out.println(super.xxx);
	}
	*/

	// 静态方法，主方法
	public static void main(String[] args){
		SuperTest06 st = new SuperTest06();
		st.doSome();

		// main方法是静态的
		// 错误的。
		/*
		System.out.println(this);
		System.out.println(super.xxxx);
		*/
	}
}
```

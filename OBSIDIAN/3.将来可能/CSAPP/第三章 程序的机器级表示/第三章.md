## 3.0 章节总述

1. 我们在技术讲解之前，先快速浏览C语言、汇编代码以及机器代码之间的==关系==。
2. 然后介绍x86-64的细节，从==数据的表示和处理以及控制的实现==开始。
3. 了解如何实现C语言中的==控制结构==，如if、while和switch语句。
4. 之后，我们会讲到==过程的实现==，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。
5. 接着，我们会考虑在机器级如何实现像数组、结构和联合这样的==数据结构==。
6. 有了这些机器级编程的背景知识，我们会讨论==内存访问越界==的问题，以及系统容易遭受缓冲区溢出攻击的问题。
7. 在这一部分的结尾，我们会给出一些用==GDB调试器==检查机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。

## 3.1 历史观点

## 3.2 程序编码

gcc将源代码转化成可执行代码的过程
1. 首先，C预处理器扩展源代码，插人所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。
2. 其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。
3. 接下来，汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
4. 最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件p（由命令行指示符-op指定的）。

机器级编程的两层抽象：ISA+虚拟内存
1. 第一种是由ISA来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
2. 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

程序员可见的寄存器
1. **程序计数器**（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。
2. **整数寄存器文件**包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。
3. **条件码寄存器**保存着最近执行的算术或逻辑指令的状态信息。

## 3.3 数据格式

![[assets/Pasted image 20240305085117.png]]

## 3.4 访问信息

### 16个整数寄存器

![[assets/Pasted image 20240305085232.png]]

### 三种寻址类型

![[assets/Pasted image 20240305085450.png]]

### 数据传送指令的类型

1. 源操作数长度 = 目的操作数长度：mov\[bwlq\]
2. 源操作数长度 > 目的操作数长度：截断
3. 源操作数长度 < 目的操作数长度：进行符号扩展或者零扩展

![[assets/Pasted image 20240305085843.png]]


## 3.5 算数和逻辑操作

## 3.6 控制

## 3.7 过程

## 3.8 数组分配和访问

## 3.9 异数的数据结构

## 3.10 在机器级程序中将控制与数据

## 3.11 浮点代码


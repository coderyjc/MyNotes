---
doc_type: weread-highlights-reviews
bookId: "30179184"
author: 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
cover: https://weread-1258476243.file.myqcloud.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg
reviewCount: 3
noteCount: 24
isbn: 9787115508232
category: 计算机-计算机综合
---

#读书/计算机-计算机综合

# 元数据
> [!bookinfo]+ 操作系统导论
> - ![ 操作系统导论|200](https://weread-1258476243.file.myqcloud.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg)
> - 书名： 操作系统导论
> - 作者： 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
> - 出版时间 2019-06-01 00:00:00
> - ISBN： 9787115508232
> - 分类： 计算机-计算机综合
> - 出版社： 人民邮电出版社

> [!bookinfo]+ 简介
> 这是一本关于现代操作系统的书。全书围绕虚拟化、并发和持久性这3个主要概念展开，介绍了所有现代系统的主要组件（包括调度、虚拟内存管理、磁盘和I/O子系统、文件系统 ）。 本书共50章，分为3个部分，分别讲述虚拟化、并发和持久性的相关内容。本书大部分章节均先提出特定的问题，然后通过书中介绍的技术、算法和思想来解决这些问题。笔者以对话形式引入所介绍的主题概念，行文诙谐幽默却又鞭辟入里，力求帮助读者理解操作系统中虚拟化、并发和持久性的原理。 本书内容全面，并给出了真实可运行的代码（而非伪代码），还提供了相应的练习，适合高等院校相关专业教师教学和高校学生自学。
# 高亮划线

## 第2章 操作系统介绍


- 📌 每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。 ^9-6046-6132
    - ⏱ 2022-03-07 00:14:37 
## 第4章 抽象：进程


- 📌 操作系统通过虚拟化（virtualizing）CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是时分共享（time sharing）CPU技术， ^11-789-896
    - ⏱ 2023-02-23 15:22:28 

- 📌 我们将低级机制称为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。 ^11-1000-1045
    - ⏱ 2023-02-23 15:24:06 

- 📌 策略是在操作系统内做出某种决定的算法。 ^11-1477-1496
    - ⏱ 2023-02-23 15:24:12 

- 📌 机器状态（machine state）：程序在运行时可以读取或更新的内容。 ^11-1877-1914
    - ⏱ 2023-02-23 15:30:06 

- 📌 将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处 ^11-3724-3770
    - ⏱ 2023-02-23 15:40:54 

- 📌 在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。 ^11-4017-4113
    - ⏱ 2023-02-23 15:44:58 

- 📌 为程序的运行时栈（run-time stack或stack）分配一些内存。 ^11-4275-4312
    - ⏱ 2023-02-23 15:46:21 

- 📌 UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（file descriptor），用于标准输入、输出和错误 ^11-4658-4717
    - ⏱ 2023-02-23 16:04:15 

- 📌 一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。 ^11-5509-5553
    - ⏱ 2023-02-23 16:11:48 
 

- 📌 有时候人们会将存储关于进程的信息的个体结构称为进程控制块（Process Control Block，PCB） ^11-9386-9441
    - ⏱ 2023-02-23 17:40:34 
## 第5章 插叙：进程API


- 📌 UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：fork()和exec()。进程还可以通过第三个系统调用wait()，来等待其创建的子进程执行完成。 ^12-583-668
    - ⏱ 2023-02-23 17:42:28 

- 📌 进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这时看起来有两个完全一样的p1程序在运行，并都从fork()系统调用中返回。新创建的进程称为子进程（child），原来的进程称为父进程（parent）。子进程不会从main()函数开始执行（因此hello world信息只输出了一次），而是直接从fork()系统调用返回，就好像是它自己调用了fork()。 ^12-2171-2384
    - ⏱ 2023-02-23 17:51:26 

- 📌 CPU调度程序（scheduler）决定了某个时刻哪个进程被执行 ^12-2879-2911
    - ⏱ 2023-02-23 17:52:43 

- 📌 有时候父进程需要等待子进程执行完毕，这很有用。这项任务由wait()系统调用（或者更完整的兄弟接口waitpid()） ^12-3200-3259
    - ⏱ 2023-02-23 17:54:44 

- 📌 如果父进程碰巧先运行，它会马上调用wait()。该系统调用会在子进程运行结束后才返回 ^12-4504-4581
    - ⏱ 2023-02-23 18:09:17 

- 📌 exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程 ^12-6472-6563
    - ⏱ 2023-02-23 18:12:12 

- 📌 事实证明，这种分离fork()及exec()的做法在构建UNIX shell的时候非常有用，因为这给了shell在fork之后exec之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。 ^12-6795-6907
    - ⏱ 2023-02-23 18:12:47 

- 📌 shell实现结果重定向的方式也很简单，当完成子进程的创建后，shell在调用exec()之前先关闭了标准输出（standard output），打开了文件newfile.txt。这样，即将运行的程序wc的输出结果就被发送到该文件，而不是打印在屏幕上。 ^12-7673-7799
    - ⏱ 2023-02-23 18:14:57 

- 📌 p4确实调用了fork来创建新的子进程，之后调用execvp()来执行wc。屏幕上没有看到输出，是由于结果被重定向到文件p4.output。 ^12-9358-9428
    - ⏱ 2023-02-23 18:15:42 

- 📌 UNIX管道也是用类似的方式实现的，但用的是pipe()系统调用。在这种情况下，一个进程的输出被链接到了一个内核管道（pipe）上（队列），另一个进程的输入也被连接到了同一个管道上。 ^12-9478-9569
    - ⏱ 2023-02-23 18:16:04 

- 📌 阅读man手册可以避免尴尬。当你询问同事某个fork细节时，他可能会回复：“RTFM”。这是他在有礼貌地督促你阅读man手册（Read the Man）。RTFM中的F只是为这个短语增加了一点色彩…… ^12-10110-10210
    - ⏱ 2023-02-23 18:17:10 
## 第26章 并发：介绍


- 📌 线程有一个程序计数器（PC），记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。 ^33-781-827
    - ⏱ 2022-03-07 14:08:12 
# 读书笔记

## 第4章 抽象：进程

### 划线评论
- 📌 一旦进程被阻塞（例如，通过发起I/O操作），OS将保持进程的这种状态，直到发生某种事件（例如，I/O完成）  ^360415329-7Gf4RtZed
    - 💭 运行的时候，使用CPU执行指令；阻塞的时候，不使用CPU执行指令。
以IO操作为例：
发起IO之后，需要等待IO操作的完成才能进行后续（使用CPU）的操作，在等待期间是不使用CPU的，又因为IO速度远不及CPU的速度，所以一定会有一段时间不使用CPU，我们把"等待IO完成而暂停使用CPU"的状态称为阻塞态。
    - ⏱ 2023-02-23 17:36:51

### 划线评论
- 📌 具体来说，它会将参数填入main()函数，即argc和argv数组。  ^360415329-7GeYAj1HZ
    - 💭 argc（argument count），表示argv这个数组中保存的命令行参数的个数。
argv（argument vector），表示传入main函数的参数序列，并且第一个参数argv[0]一定是程序的全路径名称，所以需要输入的main函数的参数个数是argc-1个。
    - ⏱ 2023-02-23 16:01:00

### 划线评论
- 📌 将高级策略与其低级机制分开  ^360415329-7GeX2c1AV
    - 💭 机制是底层的，策略是顶层的。
    - ⏱ 2023-02-23 15:37:20
   
# 本书评论

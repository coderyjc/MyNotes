---
desc: 计算属性
complete: true
---

## 计算属性

### 比较和使用

==插值语法==：

```html
<h2>{{ firstName + " " + lastName }}</h2>
<h2>{{ score >= 60 ? '及格': '不及格' }}</h2>
<h2>{{ message.split(" ").reverse().join(" ") }}</h2>
```

优点：适合简单的运算
缺点：如果多个地方用到，就会有大量重复的代码

==函数==：

```html
<h2>{{ getFullname() }}</h2>
<h2>{{ getScoreLevel() }}</h2>
<h2>{{ reverseMessage() }}</h2>
```

优点：简洁
缺点：所有对的data使用过程变成了函数调用

==计算属性==：

用法：是一个属性，一个对象， 而不是函数。

选项：computed
类型：`{ [key: string]: Function | { get: Function, set: Function } }`

```html
    <!-- 1.拼接名字 -->
    <h2>{{ fullname }}</h2>
    <!-- 2.显示分数等级 -->
    <h2>{{ scoreLevel }}</h2>
    <!-- 3.反转单词显示文本 -->
    <h2>{{ reverseMessage }}</h2>
```


```js
computed: {
	// 1.计算属性默认对应的是一个函数
	fullname() {
	  return this.firstName + " " + this.lastName
	},
	scoreLevel() {
	  return this.score >= 60 ? "及格": "不及格"
	},
	reverseMessage() {
	  return this.message.split(" ").reverse().join(" ")
	}
}
```

### 计算属性和方法的区别

计算属性会基于它们的依赖关系进行缓存；

在数据不发生变化时，计算属性是不需要重新计算的；

但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；

### 计算属性set和get的写法

计算属性，计算属性，说到底还是**属性**，是一个属性，就是可以用this点出来，可以访问，也可以修改

此前我们使用的是函数式的写法，实际上是一个语法糖，事实上我们可以写成一个属性。

```html
    <button @click="setFullname">设置fullname</button>
```

```js
computed: {
	// 语法糖的写法
	// fullname() {
	//   return this.firstname + " " + this.lastname
	// },
	
	// 完整的写法:
	fullname: {
	  get: function() {
		return this.firstname + " " + this.lastname
	  },
	  set: function(value) {
		const names = value.split(" ")
		this.firstname = names[0]
		this.lastname = names[1]
	  }
	}
  },
  methods: {
  setFullname() {
	this.fullname = "kobe bryant"
  }
}

```
```ad-note
title: 主要章节
第4章 抽象：进程
第5章 插叙：进程API
第6章 机制：受限直接执行
```

## 进程

进程就是运行中的程序

操作系统通过虚拟化（virtualizing）CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是时分共享（time sharing）CPU技术。

我们将低级机制称为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。策略是在操作系统内做出某种决定的算法。机制是底层的，策略是顶层的。机制和策略分离提高了软件的灵活性。

**进程的创建**：
1. 将程序和静态数据加载到内存（从磁盘读取，并放在内存）（懒加载）
2. 为程序的运行时栈分配内存
3. 为堆分配内存
4. 启动程序的main函数

如何理解==阻塞==：
运行的时候，使用CPU执行指令；阻塞的时候，不使用CPU执行指令。  
以IO操作为例：  
发起IO之后，需要等待IO操作的完成才能进行后续（使用CPU）的操作，在等待期间是不使用CPU的，又因为IO速度远不及CPU的速度，所以一定会有一段时间不使用CPU，我们把"等待IO完成而暂停使用CPU"的状态称为阻塞态。

## 进程API

### fork()

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) {        // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else {             // parent goes down this path (main)
        printf("hello, I am parent of %d (pid:%d)\n",
                rc, (int) getpid());
    }
    return 0;
}
```

output:

```bash
prompt> ./p1
hello world (pid:29146) 
hello, I am child (pid:29147)
hello, I am parent of 29147 (pid:29146) 
prompt>
```

这是操作系统提供的创建新进程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这时看起来有两个完全一样的p1程序在运行，并都从fork()系统调用中返回。新创建的进程称为子进程（child），原来的进程称为父进程（parent）。子进程不会从main()函数开始执行（因此hello world信息只输出了一次），而是直接从fork()系统调用返回，就好像是它自己调用了fork()。

![[assets/Pasted image 20230224084948.png]]

子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从fork()返回的值是不同的。父进程获得的返回值是新创建子进程的PID，而子进程获得的返回值是0。

CPU调度程序决定了某时刻该执行哪个程序，所以父子进程不一定哪个先输出


### wait()

![[assets/Pasted image 20230224085422.png]]

有时候父进程需要等待子进程执行完毕，这很有用。这项任务由wait()系统调用（或者更完整的兄弟接口waitpid()）

如果父进程碰巧先运行，它会马上调用wait()。该系统调用会在子进程运行结束后才返回；如果子进程先运行，那么正是我们想要的。

### exec()

相当于先从当前进程fork出来一个子进程，然后exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程

这种分离fork()及exec()的做法在构建UNIX shell的时候非常有用，因为这给了shell在fork之后exec之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。


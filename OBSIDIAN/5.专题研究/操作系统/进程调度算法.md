```ad-abstract
第7章 进程调度：介绍
第8章 调度：多级反馈队列
第9章 调度：比例份额
第10章 多处理器调度（高级）
```


## 先进先出（FIFO/FCFS）

可能出现护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。

## 最短任务有优先（SJF）

【非抢占式】

`先运行最短的任务，然后是次短的任务，如此下去。`

## 最短完成时间优先（STCF、PSJF）

向SJF添加抢占，使其变成抢占式。

## 轮转（RR）

对于要求响应时间的任务比较适合。

## 多级反馈队列（MLFQ）

MLFQ的**两条基本规则**
- 规则1：如果A的优先级 > B的优先级，运行A（不运行B）
- 规则2：如果A的优先级 = B的优先级，轮转运行A和B

存在的==问题==：高优先级一直轮转，低优先级可能会发生饥饿现象。

---

**如何动态调整优先级？**
- 规则3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
- 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变。

情况1-单个长工作：和其他没什么不同
情况2-存在断工作：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF。
情况3-存在IO：根据规则4b，假设交互型工作中有大量的I/O操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。

存在的==问题==：病毒：进程在时间片用完之前，调用一个I/O操作（比如访问一个无关的文件），从而主动释放CPU。如此便可以保持在高优先级，占用更多的CPU时间。

---

为了防止上述病毒的攻击，增加以下**规则**：
- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。

新规则解决了两个问题：
1. 进程不会饿死
2. 如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。

存在的==问题==：S的值不好设置

---

新规则：更为完善的计时方式

规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。

至此，规则就比较完善了。

```ad-tip
如今我们使用的Windows系统也是用的这种调度规则
```

## 比例份额调度

比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。

彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。

彩票调度算法能够更合理地处理新加入的进程

### 彩票调度

基本思想很简单：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。

### 步长调度

基本思路很简单：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。
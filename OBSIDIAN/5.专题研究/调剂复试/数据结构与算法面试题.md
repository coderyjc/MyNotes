## 绪论

<span style="background:#affad1">Easy</span>

- [ ] 你觉得什么是数据结构，什么是算法？
```ad-note
数据结构是计算机按照数据之间的关系进行存储和组织数据的一种方式。
算法是解决问题的策略。
```

- [ ] 数据的基本单位和最小单位的分别是什么？
```ad-note
数据的基本单位是**数据元素**，
而数据的最小单位是数据项，
多个相同属性的数据元素组在一起就成为了数据对象。
```

- [ ] 列举你知道的常见的数据结构
```ad-note
数组	——————	一维数组、二维数组
链表	——————	单链表、循环链表
栈		——————	先进后出、递归、后缀表达式、函数调用
队列	——————	先进先出、树的层次遍历、图的广度遍历
树		——————	二叉树、森林、平衡二叉树、线索二叉树、遍历
图		——————	有向图、无向图、最小二叉树、遍历、最短路径
```


- [ ] 算法的五个特征
```ad-note
- 有穷性——有限的步骤
- 确定性——不可二义性
- 可行性——每一步都是通过执行有限次数完成的
- 输入——零个或多个输入
- 输出——至少有一个或多个输出
```

- [ ] 什么是ADT
```ad-note
抽象数据类型。
一般指由用户定义的、表示应用问题的数学模型以及定义在这个模型上的一组操作的总称。
具体包括三部分：数据对象、数据对象上关系的集合、以及对数据对象的基本操作的集合
```

- [ ] 时间复杂度是什么？简单介绍一下大T和大O
```ad-note
时间复杂度：算法执行时所需要的计算工作量，与整个算法的执行时间和基本操作重复的次数成正比。一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 T(n)。O：T(n) 的数量级。【数量级】数量的尺度或大小的级别, 每个级别之间保持固定的比例。
```

- [ ] 空间复杂度和原地算法
```ad-note
空间复杂度：算法执行时所耗费的存储空间。主要是指对数据进行操作所使用到的额外辅助空间。
算法原地工作：算法所需要的辅助空间为常量，即 O(1)。
```

- [ ] 介绍一下数据的逻辑结构和存储结构
```ad-note
逻辑结构：
（1）集合：数据元素之间除了有相同的数据类型再没有其他的关系 
（2）线性结构：数据元素之间是一对一的关系 
（3）树形结构：数据元素之间是一对多的关系 
（4）图状结构：数据元素之间是多对多的关系。

物理（存储）结构：
（1）顺序存储：逻辑上相邻的元素物理位置也相邻  
（2）链式存储：不要求逻辑上相邻的元素物理位置也相邻，通过结点附加的指针找到下一个结点  
（3）索引存储：建立附加的索引表来标识结点的地址  
（4）散列存储：根据结点的关键字通过散列函数计算出结点的地址
```

- [ ] 循环和递归的优缺点
```ad-note
-   递归
    -   优点：代码简洁。
    -   缺点：递归调用次数过多，增加额外的堆栈处理，可能产生堆栈溢出。
-   循环
    -   优点：结构简单，速度快。
    -   缺点：有些问题难以解决，例如汉诺塔。
```

Hard

贪心算法（Greedy Algorithm）和动态规划（DP）的区别

## 线性表

<span style="background:#affad1">Easy</span>

- [ ] 头指针、头结点、首元节点的区别
```ad-note
（1）头指针是指向链表第一个结点的指针，是链表存在的标志  
（2）首元结点是链表中存储线性表的第一个结点  
（3）头结点是首元结点的前一个结点，是为了使得对链表的处理统一而设置的结点
```

- [ ] 简述链表中引入头节点带来的优点
```ad-note
放在第一个元素结点之前，便于在第一个元素结点之前进行插入和删除操作，不是链表必须的，也不存储任何信息。
```

- [ ] 头插法和尾插法的区别
```ad-note
插入的位置不同
头插法：新插入结点始终未当前的第一个结点  
尾插法：新插入结点始终为当前的最后一个结点
```


- [ ] 比较一下顺序表和链表
```ad-note
1. **存取（读写）方式**  
顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第 i 个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 i 次。

2. **逻辑结构与物理结构**  
采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的。

3. **查找、插入和删除操作**  
对于按值查找，顺序表无序时，两者的时间复杂度均为 O(n); 顺序表有序时，可采用折半查找，此时的时间复杂度为 O(log2n) 。
对于按序号查找，顺序表支持随机访问，时间复杂度仅为 0(1), 而链表的平均时间复杂度为 O(n) 。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。

4. **空间分配**  
顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。
```

## 栈和队列

<span style="background:#affad1">Easy</span>

- [ ] 什么是栈
```ad-note
-   只允许在表尾进行插入和删除操作，对插入到栈中的元素按 “**后进先出**” 的规则处理，插入和删除操作都在栈顶进行。
```

- [ ] 什么是队列
```ad-note
-   只允许在表的一端进行插入另外一端进行删除操作，对插入到队列中的元素按 “**先进先出**” 的规则处理，在表头进行删除在表尾进行插入。
```

- [ ] 列举一下栈和队列的用途
```ad-note
栈可用于函数调用和递归，括号匹配，后缀表达式求值；
队列常用于计算机各种资源的管理，消息缓冲器的管理和广度有限搜索算法等
```

<span style="background:#fff88f">Medium</span>

- [ ] 循环队列的顺序表中为什么要空一个位置？
```ad-note
-   普通情况下，循环队列队空和队满的判定条件是一样的。牺牲一个位置来判断队空和队满。
```

栈的两个应用：括号匹配和表达式的计算是怎么应用的？
```ad-note
遍历表达式，缝左括号就入栈，遇到右括号则检查栈是否为空，为空则表明不匹配，不为空则将左括号出栈；表达式遍历完成后栈为空则表明匹配，若栈中还有左括号表明不匹配

后缀表达式求值
（1）是操作数则进栈  
（2）是运算符则将两个元素出栈并将得到的结果进栈  
（3）表达式扫描完成后，栈顶元素为所求结果
```

## 串

<span style="background:#affad1">Easy</span>

- [ ] 介绍一下串的暴力匹配算法
```ad-note
-   **暴力模式匹配算法**：从主串的第一个字符开始，与子串的第一个字符比较，如果相同则继续比较下一个字符；如果不同则从主串的第二个字符开始，重新和子串的第一个字符比较，直到最后看是否匹配成功。
```

<span style="background:#fff88f">Medium</span>

- [ ] 介绍一下[[../Algorithm/算法专栏/KMP算法|KMP算法]]
	- [ ] 扩展：next数组的含义
	- [ ] 扩展：nextval数组的含义

```ad-note
-   **KMP 算法**：当匹配失败时，如果已经匹配的相同前缀序列中有某个后缀正好是子串的前缀，则将子串向后滑动到与这些字符对齐的位置，主串的指针不变，并从该位置开始比较。
- next 当前位置的字符匹配失配后，下一步应该跳到哪个位置进行比较
- nextVal 对next的优化，避免回退到相同的字符之后再次进行比较造成的冗余匹配
```

## 树

<span style="background:#affad1">Easy</span>

- [ ] 什么是树、二叉树、满二叉树、完全二叉树、
```ad-note
**树**是非线性结构，其元素之间有明显的层次关系。在树的结构中，每个节点都只有一个前件称为父节点，没有前件的节点为树的根节点，简称为树的根；每个节点可以有多个后件成为节点的子节点，没有后件的节点称为叶子节点。

在树的结构中，一个节点所拥有的子节点个数称为该节点的度，树中最大的节点的度为树的度，树的最大的层次称为树的深度

**二叉树**：二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。与树相似，二叉树也以递归的形式定义。二叉树是 n (n>=0) 个结点的有限集合：
1) 或者为空二叉树，即 n=0 。  
2) 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

**满二叉树**：满二叉树是指除了最后一层外其他节点均有两颗子树。

**完全二叉树**：完全二叉树是指除了最后一层外，其他任何一层的节点数均达到最大值，且最后一层也只是在最右侧缺少节点
```

- [ ] 介绍一下二叉树的存储结构：双亲表示法，孩子表示法、孩子兄弟表示法
```ad-note
双亲表示法：这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。
孩子表示法：孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 n 个结点就有 n 个孩子链表（叶子结点的孩子链表为空表），这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 n 个结点中孩子链表指针域所指向的 n 个孩子链表。
孩子兄弟表示法：孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）
```

- [ ] 什么是二叉排序树？
	- [ ] 二叉排序树的查找过程
```ad-note
*   满足以下性质的二叉树：
    *   若左子树不空，则左子树上所有结点的值均小于根结点的值；
    *   若右子树不空，则右子树上所有结点的值均大于根结点的值；
    *   左右子树又分别是二叉排序树。

从根结点开始，若根结点的关键字等于查找的关键字，则查找成功；
*   若小于根结点的关键字，则递归查找左子树；
*   若大于根结点的关键字，则递归查找右子树；
*   若查找到叶子结点还是不相等，则查找失败。
```

- [ ] 什么是线索二叉树，有什么优点
```ad-note
对于 n 个结点的二叉树，在二叉链存储结构中有 n+1 个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。
其优点是能够较快地找到当前结点的前驱和后继结点
```

- [ ]  什么是哈夫曼树？有什么特点？
	- [ ] 什么是WSL（带权路径长度）
	- [ ] 什么是前缀编码
	- [ ] 什么是哈夫曼编码
```ad-note
* 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若带权路径长度最小，则称为**哈夫曼树**。
* 特点：权值越大的结点，离根结点越近，树中没有度为 1 的结点。
* 从树的根结点到任意结点的路径长度与该结点上权值的乘积，称为该**结点的带权路径长度**。
* 所有结点的带权路径长度之和称为该**树的带权路径长度**。
* 前缀编码：如果在 一 个编码方案中，任 一 个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。
* 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予 0, 右分支赋予1'则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。
```

<span style="background:#fff88f">Medium</span>


- [ ] 二叉树与度为 2 的有序树的区别
```ad-note
（1）度为 2 的树要求树中最少有一个结点的孩子数为 2，二叉树则只要求度不超过 2 即可  
（2）二叉树子树区分左右，度为 2 的树则不区分
```

- [ ] 如何由先序遍历和中序遍历序列构造一棵二叉树
```ad-note
在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。
```

- [ ] 如何由二叉树的后序序列和中序序列唯一地确定一棵二叉树。  
```ad-note
因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子  
序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树。
```

- [ ] 如何构造一棵哈夫曼树
```ad-note
* 把 n 个结点视为仅有一个结点的二叉树，构成森林 F
* 从 F 中选取两个根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树根结点的权值之和；
* 从 F 中删除刚才选取的两棵树，并将新的树加入 F 中；
* 重复上述操作，直到 F 中只剩一棵树为止。
```

- [ ] 已知二叉树的哪两个遍历序列之后，无法唯一确定一棵二叉树？为什么？
```ad-note
前序和后序。

前序和后序在本质上都是将父节点与子结点进行分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树
```

二叉排序树和平衡二叉树的区别
```ad-note
-   相同点：
都是基于分治思想采用二分法的策略提高数据查找速度的二叉树结构。

-   不同点：
1.  二叉查找树的根节点是不可变的，左右两边结点层级差没有限制；
2.  平衡二叉树左右两边结点层级相差不大于1，通过旋转实现根节点可变，达到自平衡。

相对于二叉查找树，平衡二叉树的查询效率高，但由于增加和删除节点时，为了保证自平衡会做连续的旋转操作，平衡二叉树的额外开销比较大，耗时相对较长。
```



## 图

<span style="background:#affad1">Easy</span>

- [ ] 解释相关概念：图、有向图、无向图、完全图、连通图、连通分量、强连通图、强连通分量、生成树、生成森林、简单路径、简单回路
```ad-note
*   **图**：由结点的有穷集合 V 和边的集合 E 组成。
*   **有向图**：若 E 是有向边（弧）的有限集合时，则为有向图。
*   **无向图**：若 E 是无向边（边）的有限集合时，则为无向图。
*   **完全图**：无向图中每一个顶点与其他所有顶点之间都存在边。
*   **连通图**：无向图中任意两个顶点都是连通的。
*   **连图分量**：无向图中的极大连通子图。
*   **强连通图**：有向图中，如果一对顶点之间有相互到达的路径，则这两个顶点是强连通的。图中任意一对顶点都是强连通的，则称该图为强连通图。
*   **强连通分量**：有向图中的极大强连通子图。
*   **生成树**：连通图的生成树是包含图中全部顶点的一个极小连通子图。
*   **生成森林**：非连通图中，连通分量的生成树构成生成森林。
*   **简单路径**：顶点不重复的路径。
*   **简单回路**：除第一个和最后一个顶点外，其余顶点不重复出现的回路。
```

- [ ] 什么是最小生成树？有什么用？
```ad-note
连接图的各个顶点且边的权值之和最小的是最小生成树；

重要用途，如设计通信网。设图的顶点表示城市，边表示两个城市之间的通信线路，边的权值表示建造通信线路的费用。n 个城市之间最多可以建 n(n-1)/2 条线路，用最小生成树来选择其中的 n-1 条，使总的建造费用最低
```

- [ ] 图的DFS和BFS遍历序列是否唯一？为什么？
	- [ ] DFS和BFS最终形成什么？
```ad-note
如果确定其存储结构，那他们就是唯一的。因为在存储时，人为的定义了第1个顶点，以及各顶点之间邻接关系的顺序。
若单纯从逻辑上考虑算法，则它们是不唯一的

如果图是连通的，最终形成一棵树，如果图不连通，最终形成森林。
```

简述邻接矩阵与邻接表的区别
```ad-note
1. 在邻接矩阵表示中，无向图的邻接矩阵是对称的。矩阵中第 i 行或 第 i 列有效元素个数之和就是顶点的度。在有向图中 第 i 行有效元素个数之和是顶点的出度，第 i 列有效元素个数之和是顶点的入度。
2. 在邻接表的表示中，无向图的同一条边在邻接表中存储的两次。如果想要知道顶点的度，只需要求出所对应链表的结点个数即可。有向图中每条边在邻接表中只出现一次，求顶点的出度只需要遍历所对应链表即可。求入度则需要遍历其他顶点的链表。
```

如何判断有向图有环
```ad-note
（1）深度搜索遍历：若图中有一个顶点被访问两次则证明有环  
（2）拓扑排序：查找图中入度为 0 的顶点，删除它，重复此操作；若图中最后还剩顶点则证明有环
```


<span style="background:#fff88f">Medium</span>

- [ ] 介绍一下DFS算法
```ad-note
*   首先访问图中某一起始顶点 v1，然后由 v1 出发，访问与 v1 相邻且未被访问的任一顶点 v2，再访问与 v2 相邻且未被访问的任一顶点 v3，重复上述操作。
*   当不能继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问，则从该顶点开始继续上述操作，直到图中所有顶点都被访问。
```

- [ ] 介绍一下BFS算法
```ad-note
* 首先访问图中某一起始顶点 v1，然后依次访问与 v1 相邻的所有未被访问过的顶点 v2、v3...。
* 再从这些被访问过的 v2、v3... 出发，依次访问它们所有未被访问过的邻接结点，直到图中所有顶点都被访问。
```

- [ ] 介绍一下Prim（普里姆）算法
```ad-note
*   从图中任取一顶点加入树 T，此时树 T 中只有一个顶点；
*   然后选择一个**与当前树 T 的顶点集合距离最近的顶点**，并将其顶点和对应的边加入树 T；
*   以此类推，直到图中所有顶点都加入树 T。
```

- [ ] 介绍一下Kruskal（克鲁斯卡尔）算法
```ad-note
*   初始时为 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量；
*   不断**选取权值最小且未被选取过的边**，若该边**两端的顶点属于不同的连通分量**，则把该边加入 T，否则选取下一条权值最小且未被选取过的边；
*   依次类推，直到 T 中所有顶点都在一个连通分量上。
```

- [ ] 什么样的图可以进行拓扑排序
```ad-note
有向无环图（DAG图）
-> 是一个无回路的有向图。
```

- [ ] 介绍一下拓扑排序
```ad-note
拓扑排序可以决定哪些子工程必须要先执行，哪些子工程要在某些工程完成后才能执行。把以顶点为活动，边为活动间先后顺序关系的有向图成为顶点活动网，简称为 AOV 网。一个 AOV 网应该是有向无环图，不应该存在回路，如果要存在回路的话则该回路上的所有活动都无法执行。在 AOV 网中如果不存在回路，则可以把所有的活动排列成一个序列，称该序列为拓扑序列，拓扑序列并不是唯一的。形成拓扑序列的过程称为拓扑排序。
```

- [ ] 拓扑排序是如何实现的？
```ad-note
拓扑排序的步骤：
（1）在有向图中任意选择一个没有前驱的节点输出
（2）从图中删去该节点以及与它相连的边
（3）重复以上步骤，直到所有的顶点都输出或者当前图中不存在无前驱的顶点为止，后者代表该图是有环图，所以可以通过拓扑排序来判断一个图是否存在环。
```


<span style="background:#ff4d4f">Hard</span>

- [ ] 介绍一下Dijkstra（迪杰斯特拉）算法
```ad-note
*   单源最短路径，即求图中某一顶点到其他顶点的最短路径。
*   设置一个集合 S 记录已经求得的最短路径的顶点。初始时把源点放入 S 中，计算源点到其它顶点的最短路径长度，选择路径最短的顶点加入 S，再根据该顶点重新计算源点到其它顶点的最短路径长度，重复上述操作，直到所有顶点都加入 S。
*   打个比方，A 到 B 的距离是 10，A 到 C 的距离是 4，C 到 B 的距离是 3，则 A 到 B 的距离应该修改为 7。
```

- [ ] 介绍一下Floyd（佛洛依德）算法
```ad-note
*   求每对顶点间的最短路径。
*   设置一个 n 阶方阵 A 记录每对顶点间的路径长度，其中 A[i][j] 表示从顶点 i 到顶点 j 的路径长度；
*   初始时，若任意两个顶点之间存在边，则该边的权值设为它们的最短路径；若不存在有向边，则把值设为∞；
*   之后在原路径中不断加入其他顶点作为中转点。若增加中转点后，得到的路径比原路径长度更短，则修改原路径。
```

- [ ] Dijkstra算法和Floyd算法的区别是什么
```ad-note
1.
Dijkstra不能处理负权图，Flyod能处理负权图；

2.
Dijkstra处理单源最短路径
Flyod是处理多源最短路径

3.
Dijkstra时间复杂度为O（n^2）
Flyod时间复杂度为O（n^3） 空间复杂度为O（n ^ 2）;
所以题目中如果是单源点正权图，就用Dijkstra
如果是任意两个点之间的最短路径或者是负权图，就用Floyd；
```

比较一下AOV网和AOE网
```ad-note
相同点: 两者都是有向无环图

不同点：
- AOV 网：顶点表示**活动**，边表示**活动之间的先后关系**，一般用来表示活动的制约关系；  
- AOE 网：边表示**活动**，边的权值表示**活动持续时间**，顶点用来表示**活动的开始**，一般用来分析工程最少需要多少时间完成，或者是工程为缩短时间可以加快哪些活动；
```

- [ ] 什么是关键路径
```ad-note
*   **定义**：从源点到汇点的所有路径中，**具有最大路径长度的路径**称为关键路径。
*   关键路径的长度是完成整个工程的最短时间。
```


- [ ] 什么是并查集
```ad-note
**并查集是一种维护集合的数据结构，支持合并和查找两种操作；**  
**合并：合并两个集合；**  
**查找：判断两个元素是否在一个集合中；**  
并查集是用数组来实现的，设数组 int father[N] , 其中 father[i] 表示元素 i 的父亲结点，另外如果 father[i] = i 则表示元素 i 是该集合的根结点  
例如 father[2] = 1 表示元素 2 的父结点为 1；father[1] = 1 表示该集合的根结点为 1；
```

## 查找

<span style="background:#affad1">Easy</span>

- [ ] 介绍一下常用的查找方法
```ad-note
查找分为静态查找表和动态查找表；静态查找表包括：顺序查找、折半查找、分块查找；动态查找包括：二叉排序树和平衡二叉树。

（1）顺序查找：把待查关键字 key 放入哨兵位置（i=0），再从后往前依次把表中元素和 key 比较，如果返回值为 0 则查找失败，表中没有这个 key 值，如果返回值为元素的位置 i（i!=0）则查找成功，设置哨兵的位置是为了加快执行速度，时间复杂度为 O（n），其特点是：结构简单，对顺序结构和链式式结构都适用，但查找效率太低。

（2）折半查找：要求查找表为顺序存储结构并且有序，若关键字在表中则返回关键字的位置，若关键字不在表中时停止查找的典型标志是：查找范围的上界 <= 查找范围的下界。

（3）分块查找：先把查找表分为若干子表，要求每个子表的元素都要比后面的子表的元素小，也就是保证块间是有序的（但是子表内不一定有序），把各子表中的最大关键字构成一张索引表，表中还包含各子表的起始地址。特点是：块间有序，块内无序，查找时块间进行索引查找，块内进行顺序查找。

（4）二叉排序树：二叉排序树的定义为：一棵空树，或者是一棵具有如下特点的树：如果该树有左子树，则其左子树的所有节点值小于根的值；若该树有右子树，则其右子树的所有节点值均大于根的值；其左右子树也分别为二叉排序树

（5）平衡二叉树：平衡二叉树又称为 AVL 树，它或者是一棵空树或者具有如下特点：他的左子树和右子树的高度差的绝对值不能大于 1，且他的左右子树也都是平衡二叉树。
```


- [ ] 什么是哈希表
```ad-note
通过把关键字码的值映射到表中的一个位置以加快查找速度。
```

- [ ] 哈希函数的构造方法
```ad-note
直接定址法、除留余数法（数字分析法、平方取中法、折叠法、随机数法）

（1）直接定址法：取关键字的某个线性函数值作为散列地址，H(key)=a*key+b。

（2）除留余数法：取关键字对 p 取余的值作为散列地址，其中 p<m, 即 H(key)=key%p (p<m)。

（3）数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列的地址，适用于所有关键字都已知的情况。

（4）平方取中法：对关键字求平方，再取结果中的中间几位作为散列地址。

（5）折叠法：将关键字分为位数相同的几部分，然后取这几部分的叠加和作为散列地址。适用于关键字位数较多，且关键字中每一位上数字分布大致均匀。

（6）随机数法：选择一个随机函数，把关键字的随机函数值作为散列地址。适合于关键字的长度不相同时。

```

- [ ] 什么是哈希冲突？以及如何解决。
```ad-note
不同的值,由哈希函数计算出的哈希值可能相同。
- 开放定址法：线性探测法、二次探测法、双重散列法
- 拉链法

（1）线性探查法：基本思想，探查时从地址 d 开始，首先探查 T[d], 在探查 T[d+1]... 直到查到 T[m-1]，此后循环到 T[0],T[1]... 直到探测到 T[d-1] 为止。

（2）二次探查法：基本思想，探查时从地址 d 开始，首先探查 T[d], 再探查 T[d+1^2],T[d+2^2]... 等，直到探查到有空余地址或者探查到 T[d-1] 为止，缺点是无法探查到整个散列空间。

（3）双重散列法：基本思想，使用两个散列函数来确定地址，探查时从地址 d 开始，首先探查 T[d], 再探查 T[d+h1(d)],T[d+2*h1(d)]...

拉链法：将所有关键字为同义词的节点链接在同一个单链表中，若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数组，凡是散列地址为 i 的节点均插入到头指针为 i 的单链表中。
```

- [ ] 二叉查找树中序遍历的序列是什么？
```ad-note

```

- [ ] 什么是平衡二叉树
```ad-note

```

Medium

静态查找和动态查找的区别



- [ ] 决定散列表ASL的因素
```ad-note
（1）选用的散列函数  
（2）选用的冲突处理方法  
（3）散列表的饱和程度
```

什么是散列表的装填因子，有什么特点




<span style="background:#ff4d4f">Hard</span>

B树、B+树、红黑树 

M 阶 B- 树和 M 阶 B+ 树的主要区别

```ad-note
（1）B 树 n 个结点有 n+1 个分支，B + 树 n 个结点有 n 个分支  
（2）B 树的每个结点包含信息，B + 树非叶结点起索引作用，只有叶子结点包含信息（且包含了全部关键字）  
（3）B + 树有一个指针指向关键字最小的叶子结点，所有叶子结点链接成一个链表，B 树没有  
（4）B 树和 B + 树每个结点的**关键字个数**取值范围不同；
```

难度太大，应该不会问，最后再看吧。


## 排序

<span style="background:#fff88f">Medium</span>

- [ ] 什么是堆？有什么作用？
```ad-note

```

- [ ] 介绍以下算法的基本思想、时间复杂度和空间复杂度：
	- [ ] 直接插入排序、折半插入排序、希尔排序
	- [ ] 简单选择排序、堆排序、冒泡排序、快速排序
	- [ ] 归并排序
	- [ ] 基数排序
```ad-note
直接插入排序
*   基本思想：将序列分为有序部分和无序部分，从无序部分中依次选择元素与有序部分比较，找到合适的位置，将原来的元素及其后面的元素向后移，再将元素插入到相应的位置。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

折半插入排序 (稳定)
*   基本思想：先使用折半查找找到适合位置，再将其他元素后移，最后将元素插入到相应的位置。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(1)

希尔排序（不稳定）
*   基本思想：将序列中相隔某个增量的元素组成一个子序列，对各子序列分别进行直接插入排序，当整个序列的元素基本有序时，再进行一次直接插入排序。
*   空间复杂度：O(1)

简单选择排序（不稳定）
*   基本思想：每经过一趟在序列中找一个最小值，然后与序列的第一个元素交换并固定，固定的元素不参与后续比较。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

堆排序（不稳定）
*   基本思想：把序列建成初始堆，输出堆顶元素后，对其重新建堆，再输出堆顶元素，重复操作，直到堆中仅剩一个元素。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(1)

冒泡排序（稳定）
*   基本思想：从前往后（或从后往前）两两比较相邻元素的值，若为逆序，则交换，直到比较完最后一个元素，固定该元素不再参与后续比较。再从头开始重复上述操作，每轮比较都能选出一个固定的元素。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

快速排序（不稳定）
*   基本思想：在序列中任意选择一个元素作为中心，把比它大的元素移到右边，把比它小的元素移到左边，形成左右两个子序列，再把子序列按上述操作调整，直到所有子序列只有一个元素时即为有序。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(log₂n)

归并排序（稳定）
*   基本思想：将两个或者两个以上的有序表合并成一个新的有序表。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(n)

基数排序（稳定）
*   基本思想：按关键字的权重依次进行排序，最后形成一个有序序列。
*   时间复杂度：O(d(n+r)) 
*   空间复杂度：O(r)       **【注】n 个数、r 个队列、d 趟分配**
```


```ad-tip
稳定算法：
**插**入**奇**数个**泡泡**，然后将他们**归并**起来；
插（插入）
奇（基数排序）
泡（冒泡排序）
归（归并排序）

不稳定算法：
“考研压力大，心情**不稳定**，**快些选堆**朋友来聊天” 
快 ---- 快速排序；
些 ---- 希尔排序（谐音）；
选 ---- 选择排序；
堆 ---- 堆排序；**这些排序是不稳定的**

时间复杂度nlogn算法：

军训排队时，教官说：**快些**以 nlogn 的速度**归队**；
快（快速），
些（希尔），
归（归并），
队（堆）
```


- [ ] 什么是排序算法的稳定性
```ad-note
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。
```

- [ ] 简述内部排序和外部排序的区别
```ad-note
内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是**内存**）进行的排序过程。

外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中**需要对外存进行访问**的排序过程。
```

- [ ] 列举常见外部排序
```ad-note
多路平衡归并
置换-选择排序
```
## 绪论

<span style="background:#affad1">Easy</span>

- [ ] 你觉得什么是数据结构，什么是算法？
```ad-note

```

- [ ] 算法的五个特征
```ad-note

```

- [ ] 时间复杂度是什么？简单介绍一下大T和大O
```ad-note
时间复杂度：算法执行时所需要的计算工作量，与整个算法的执行时间和基本操作重复的次数成正比。一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 T(n)。O：T(n) 的数量级。【数量级】数量的尺度或大小的级别, 每个级别之间保持固定的比例。
```

- [ ] 空间复杂度和原地算法
```ad-note
空间复杂度：算法执行时所耗费的存储空间。主要是指对数据进行操作所使用到的额外辅助空间。
算法原地工作：算法所需要的辅助空间为常量，即 O(1)。
```

- [ ] 介绍一下数据的存储结构
```ad-note

```

- [ ] 循环和递归的优缺点
```ad-note
-   递归
    -   优点：代码简洁。
    -   缺点：递归调用次数过多，增加额外的堆栈处理，可能产生堆栈溢出。
-   循环
    -   优点：结构简单，速度快。
    -   缺点：有些问题难以解决，例如汉诺塔。
```

## 线性表

<span style="background:#affad1">Easy</span>

- [ ] 头指针和头结点的区别
```ad-note
-   **头指针**：指向第一个结点存储位置的指针，具有标识作用，是链表的必要元素，无论链表是否为空，头指针都存在。
-   **头结点**：放在第一个元素结点之前，便于在第一个元素结点之前进行插入和删除操作，不是链表必须的，也不存储任何信息。
```

- [ ] 比较一下顺序表和链表
```ad-note

```


## 栈和队列

<span style="background:#affad1">Easy</span>

- [ ] 什么是栈
```ad-note
-   只允许在表尾进行插入和删除操作，对插入到栈中的元素按 “**后进先出**” 的规则处理，插入和删除操作都在栈顶进行。
```

- [ ] 什么是队列
```ad-note
-   只允许在表的一端进行插入另外一端进行删除操作，对插入到队列中的元素按 “**先进先出**” 的规则处理，在表头进行删除在表尾进行插入。
```

<span style="background:#fff88f">Medium</span>

- [ ] 循环队列的顺序表中为什么要空一个位置？
```ad-note
-   普通情况下，循环队列队空和队满的判定条件是一样的。牺牲一个位置来判断队空和队满。
```


## 串

<span style="background:#affad1">Easy</span>

- [ ] 介绍一下串的暴力匹配算法
```ad-note
-   **暴力模式匹配算法**：从主串的第一个字符开始，与子串的第一个字符比较，如果相同则继续比较下一个字符；如果不同则从主串的第二个字符开始，重新和子串的第一个字符比较，直到最后看是否匹配成功。
```

<span style="background:#fff88f">Medium</span>

- [ ] 介绍一下[[../Algorithm/算法专栏/KMP算法|KMP算法]]
	- [ ] 扩展：next数组的含义、算法
	- [ ] 扩展：nextval数组的含义、算法

```ad-note
-   **KMP 算法**：当匹配失败时，如果已经匹配的相同前缀序列中有某个后缀正好是子串的前缀，则将子串向后滑动到与这些字符对齐的位置，主串的指针不变，并从该位置开始比较。
- next
```


## 树

<span style="background:#affad1">Easy</span>

- [ ] 什么是二叉树、完全二叉树、满二叉树
	- [ ] 二叉树如何存储
```ad-note
满足以下性质的二叉树：若左子树不空，则左子树上所有结点的值均小于根结点的值；若右子树不空，则右子树上所有结点的值均大于根结点的值；左右子树又分别是二叉排序树。

```

- [ ] 什么是二叉排序树？
	- [ ] 二叉排序树的查找过程
```ad-note
*   满足以下性质的二叉树：
    *   若左子树不空，则左子树上所有结点的值均小于根结点的值；
    *   若右子树不空，则右子树上所有结点的值均大于根结点的值；
    *   左右子树又分别是二叉排序树。

从根结点开始，若根结点的关键字等于查找的关键字，则查找成功；
*   若小于根结点的关键字，则递归查找左子树；
*   若大于根结点的关键字，则递归查找右子树；
*   若查找到叶子结点还是不相等，则查找失败。
```

- [ ]  什么是哈夫曼树？有什么特点？
	- [ ] 什么是WSL（带权路径长度）
	- [ ] 什么是前缀编码
	- [ ] 什么是哈夫曼编码
```ad-note
* 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若带权路径长度最小，则称为**哈夫曼树**。
* 特点：权值越大的结点，离根结点越近，树中没有度为 1 的结点。
* 从树的根结点到任意结点的路径长度与该结点上权值的乘积，称为该**结点的带权路径长度**。
* 所有结点的带权路径长度之和称为该**树的带权路径长度**。
* 前缀编码：如果在 一 个编码方案中，任 一 个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。
* 哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予 0, 右分支赋予1'则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。
```

<span style="background:#fff88f">Medium</span>

- [ ] 如何构造一棵哈夫曼树
```ad-note
* 把 n 个结点视为仅有一个结点的二叉树，构成森林 F
* 从 F 中选取两个根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树根结点的权值之和；
* 从 F 中删除刚才选取的两棵树，并将新的树加入 F 中；
* 重复上述操作，直到 F 中只剩一棵树为止。
```


- [ ] 已知二叉树的哪两个遍历序列之后，无法唯一确定一棵二叉树
```ad-note

```

## 图

<span style="background:#affad1">Easy</span>

- [ ] 解释相关概念：图、有向图、无向图、完全图、连通图、连通分量、强连通图、强连通分量、生成树、生成森林、简单路径、简单回路
```ad-note
*   **图**：由结点的有穷集合 V 和边的集合 E 组成。
*   **有向图**：若 E 是有向边（弧）的有限集合时，则为有向图。
*   **无向图**：若 E 是无向边（边）的有限集合时，则为无向图。
*   **完全图**：无向图中每一个顶点与其他所有顶点之间都存在边。
*   **连通图**：无向图中任意两个顶点都是连通的。
*   **连图分量**：无向图中的极大连通子图。
*   **强连通图**：有向图中，如果一对顶点之间有相互到达的路径，则这两个顶点是强连通的。图中任意一对顶点都是强连通的，则称该图为强连通图。
*   **强连通分量**：有向图中的极大强连通子图。
*   **生成树**：连通图的生成树是包含图中全部顶点的一个极小连通子图。
*   **生成森林**：非连通图中，连通分量的生成树构成生成森林。
*   **简单路径**：顶点不重复的路径。
*   **简单回路**：除第一个和最后一个顶点外，其余顶点不重复出现的回路。
```

- [ ] 什么是最小生成树
```ad-note

```

- [ ] 什么是关键路径
```ad-note

```

- [ ] 图的DFS和BFS遍历序列是否唯一？为什么？
	- [ ] DFS和BFS最终形成什么？
```ad-note

```

<span style="background:#fff88f">Medium</span>

- [ ] 介绍一下DFS算法
```ad-note
*   首先访问图中某一起始顶点 v1，然后由 v1 出发，访问与 v1 相邻且未被访问的任一顶点 v2，再访问与 v2 相邻且未被访问的任一顶点 v3，重复上述操作。
*   当不能继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问，则从该顶点开始继续上述操作，直到图中所有顶点都被访问。
```

- [ ] 介绍一下BFS算法
```ad-note
* 首先访问图中某一起始顶点 v1，然后依次访问与 v1 相邻的所有未被访问过的顶点 v2、v3...。
* 再从这些被访问过的 v2、v3... 出发，依次访问它们所有未被访问过的邻接结点，直到图中所有顶点都被访问。
```

- [ ] 介绍一下Prim（普里姆）算法
```ad-note
*   从图中任取一顶点加入树 T，此时树 T 中只有一个顶点；
*   然后选择一个**与当前树 T 的顶点集合距离最近的顶点**，并将其顶点和对应的边加入树 T；
*   以此类推，直到图中所有顶点都加入树 T。
```

- [ ] 介绍一下Kruskal（克鲁斯卡尔）算法
```ad-note
*   初始时为 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量；
*   不断**选取权值最小且未被选取过的边**，若该边**两端的顶点属于不同的连通分量**，则把该边加入 T，否则选取下一条权值最小且未被选取过的边；
*   依次类推，直到 T 中所有顶点都在一个连通分量上。
```

<span style="background:#ff4d4f">Hard</span>

- [ ] 介绍一下Dijkstra（迪杰斯特拉）算法
```ad-note
*   单源最短路径，即求图中某一顶点到其他顶点的最短路径。
*   设置一个集合 S 记录已经求得的最短路径的顶点。初始时把源点放入 S 中，计算源点到其它顶点的最短路径长度，选择路径最短的顶点加入 S，再根据该顶点重新计算源点到其它顶点的最短路径长度，重复上述操作，直到所有顶点都加入 S。
*   打个比方，A 到 B 的距离是 10，A 到 C 的距离是 4，C 到 B 的距离是 3，则 A 到 B 的距离应该修改为 7。
```

- [ ] 介绍一下Floyd（佛洛依德）算法
```ad-note
*   求每对顶点间的最短路径。
*   设置一个 n 阶方阵 A 记录每对顶点间的路径长度，其中 A[i][j] 表示从顶点 i 到顶点 j 的路径长度；
*   初始时，若任意两个顶点之间存在边，则该边的权值设为它们的最短路径；若不存在有向边，则把值设为∞；
*   之后在原路径中不断加入其他顶点作为中转点。若增加中转点后，得到的路径比原路径长度更短，则修改原路径。
```

- [ ] Dijkstra算法和Floyd算法的区别是什么
```ad-note

```

- [ ] 什么是关键路径
```ad-note
*   **定义**：从源点到汇点的所有路径中，**具有最大路径长度的路径**称为关键路径。
*   关键路径的长度是完成整个工程的最短时间。
```

## 查找

<span style="background:#affad1">Easy</span>

- [ ] 介绍一下常用的查找方法
```ad-note
*   **顺序查找**
    *   把待查找关键字放入哨兵位置（i=0），再从后往前依次比较表中元素。
    *   时间复杂度：O(n)
*   **折半查找**
    *   要求查找表为顺序存储结构且有序。每次比较中间元素，大了查右边，小了查左边。
    *   时间复杂度：O(log₂n)
*   **分块查找**
    *   把查找表分为若干块，块间有序，块内无序。
    *   查找时块间进行索引查找，块内进行顺序查找。
*   **二叉排序树**
    *   时间复杂度：O(log₂n)
```


- [ ] 什么是哈希表
```ad-note
通过把关键字码的值映射到表中的一个位置以加快查找速度。
```

- [ ] 哈希函数的构造方法
```ad-note
直接定址法、除留余数法（数字分析法、平方取中法、折叠法、随机数法）
```

- [ ] 什么是哈希冲突？以及如何解决。
```ad-note
不同的值,由哈希函数计算出的哈希值可能相同。
- 开放定址法：线性探测法、二次探测法、双重散列法
- 拉链法
```

- [ ] 二叉查找树中序遍历的序列是什么？
```ad-note

```

- [ ] 什么是平衡二叉树
```ad-note

```

## 排序

<span style="background:#fff88f">Medium</span>

- [ ] 什么是堆？有什么作用？
```ad-note

```

- [ ] 介绍以下算法的基本思想、时间复杂度和空间复杂度：
	- [ ] 直接插入排序、折半插入排序、希尔排序
	- [ ] 简单选择排序、堆排序、冒泡排序、快速排序
	- [ ] 归并排序
	- [ ] 基数排序
```ad-note
直接插入排序
*   基本思想：将序列分为有序部分和无序部分，从无序部分中依次选择元素与有序部分比较，找到合适的位置，将原来的元素及其后面的元素向后移，再将元素插入到相应的位置。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

折半插入排序 (稳定)
*   基本思想：先使用折半查找找到适合位置，再将其他元素后移，最后将元素插入到相应的位置。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(1)

希尔排序（不稳定）
*   基本思想：将序列中相隔某个增量的元素组成一个子序列，对各子序列分别进行直接插入排序，当整个序列的元素基本有序时，再进行一次直接插入排序。
*   空间复杂度：O(1)

简单选择排序（不稳定）
*   基本思想：每经过一趟在序列中找一个最小值，然后与序列的第一个元素交换并固定，固定的元素不参与后续比较。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

堆排序（不稳定）
*   基本思想：把序列建成初始堆，输出堆顶元素后，对其重新建堆，再输出堆顶元素，重复操作，直到堆中仅剩一个元素。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(1)

冒泡排序（稳定）
*   基本思想：从前往后（或从后往前）两两比较相邻元素的值，若为逆序，则交换，直到比较完最后一个元素，固定该元素不再参与后续比较。再从头开始重复上述操作，每轮比较都能选出一个固定的元素。
*   时间复杂度：O(n²)
*   空间复杂度：O(1)

快速排序（不稳定）
*   基本思想：在序列中任意选择一个元素作为中心，把比它大的元素移到右边，把比它小的元素移到左边，形成左右两个子序列，再把子序列按上述操作调整，直到所有子序列只有一个元素时即为有序。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(log₂n)

归并排序（稳定）
*   基本思想：将两个或者两个以上的有序表合并成一个新的有序表。
*   时间复杂度：O(nlog₂n)
*   空间复杂度：O(n)

基数排序（稳定）
*   基本思想：按关键字的权重依次进行排序，最后形成一个有序序列。
*   时间复杂度：O(d(n+r)) 
*   空间复杂度：O(r)       **【注】n 个数、r 个队列、d 趟分配**
```

## 并发控制概述

系统中，可能同时运行着多个事务，而事务的运行需要时间 ，并且事务中的操作是在一
定的数据上进行的。当系统中同时有多个事务在运行时，特别是当这些事务是对同一段数据进行操作时，彼此之间就有可能产生相互干扰的情况。

### 不同的多事务执行方式

1. 串行执行

每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行。

![[assets/Pasted image 20240310170831.png]]

问题：不能充分利用系统资源，发挥数据库共享资源的特点。

2. **交叉并行执行**

在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行。

单处理机系统中的并行事务并没有真正地并行运行，但能够**减少处理机的空闲时间**，提高系统的效率。

![[assets/Pasted image 20240310170919.png]]

3. 同时并发方式

多处理机系统中，每个处理机可以运行一个事务。多个处理机可以同时运行多个事务，实
现多个事务真正的并行运行。

### 并发带来的问题

```ad-example
飞机订票系统中的一个活动序列：
1. 甲售票点(甲事务)读出某航班的机票余额A，设A=16;
2. 乙售票点(乙事务)读出同一航班的机票余额A，也为16;
3. 甲售票点卖出一张票，修改余额A←A-1，所以A为15，写回数据库。
4. 乙售票点也卖出一张票，修改余额A←A-1，所以A为15，写会数据库。

结果：明明卖出两张机票，数据库中机票余额只减少1
原因：第4步中乙事务修改A并写回后覆盖了甲事务的修改。
```

问题：
- 多个事务同时存取同一数据的情况。
- 可能会存取和存储不正确的数据。
- 破坏事务一致性和数据库的一致性。

并发控制是衡量 DBMS 性能的重要标志之一。

并发控制机制的任务
- 对并发操作进行**正确调度**
- 保证事务的**隔离性**
- 保证数据库的**一致性**

### 数据不一致情况

- 丢失修改(LostUpdate)
- 读“脏”数据(DirtyRead)
- 不可重复读(Non-repeatableRead)
- 产生“幽灵”数据

**丢失修改(LostUpdate)**

![[assets/Pasted image 20240310200728.png]]

**读“脏”数据(DirtyRead)**

事务 T1对数据进行了更新但没有提交，事务T2读到了事务T1更新后(未提交)的数据。如果事务T1进行了回滚，那么刚刚事务T2看到的数据就是脏数据。事务T2 进行了脏读。

示例：甲给乙转账500，但是甲还没有提交，但是此时乙查询自己账户多了500。然后甲发现转错人了，回滚了转账。然后乙多出的500就没了。在这个过程中乙查到了没有提交的数据（多出的500），这就是脏读。

**不可重复读(Non-repeatableRead)**

不可重复读：事务A读取数据库中的数据后，事务B更新了数据，当A再次读取数据时，就会发现数据已经发生了改变，这就是不可重复读取。不可重复读取所导致的结果就是一个事务前后两次读取的数据不相同。重点在于update

示例：甲查询自己银行余额为1万，乙这个时候用甲的账号取走了3000，甲再一次查询余额，变成了7000。对甲而言两次结果不一致就是不可重复读。

**产生“幽灵”数据（幻读）**

幻读：如果事务T1基于某个条件读取数据后，另一个事务则更新了同一个表中的数据，这时第一个事务再次读取数据时，根据搜索的条件返回了不同的行，这就是幻读。重点在于insert

示例：甲查询自己银行明细中与乙的资金往来，之后乙向甲转了一笔账，甲再次查询发现比之前的查询多了一条新的记录，这就是幻读。

## 并发控制措施

控制目标：事务运行过程中尽可能隔离事务外操作对本事务数据环境的影响，保证操作的正确性和一致性

并发控制的主要技术——加锁(Locking)
- 加锁就是事务T在对某个数据操作之前，先向系统发出请求，封锁其所要使用的数据。在事务T释放它的锁之前，其他事务不能操作这些数据。

### 基本封锁类型

- 排它锁（X锁）
- 共享锁（S锁）

X锁（写锁）：若事务T对数据对象A加上X锁，则允许事务T**读取和修改**A，其它任何事务都不能再对A加**任何类型的锁**进行任何操作，直到事务T释放X锁，保证其他事务在事务T释放X锁之前不能再读取和修改数据。

S锁（读锁）：若事务T对数据对象A加上S锁，则事务T**只能读**A，但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到事务T释放A上的S锁为止。保证其他事务**可以读数据**，但是在事务T释放S锁前不能对数据做任何修改。

![[assets/Pasted image 20240310201828.png]]

## 封锁协议

在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，如何时申请X锁或S锁、持锁时间、何时释放锁等。称这些规则为**封锁协议**或加锁协议。

规则不同，封锁协议不同，达到的系统一致性级别不同。

| 封锁协议 | X锁      | S锁                    | 不丢失修改 | 不脏读 | 可重复读 |
| -------- | -------- | ---------------------- | ---------- | ------ | -------- |
| 一级     | 全程加锁 | 不加                   | √          |        |          |
| 二级     | 全程加锁 | 事务开始加锁，读完释放 | √          | √      |          |
| 三级     | 全程加锁 | 事务全程加锁           | √          | √      | √        |

### 一级封锁协议

规定：对事务T要修改的数据加X锁，直到事务结束（包括正常结束和非正常结束）时才释放。

效果：可以防止**丢失修改**。不能防止可重复读和不读“脏”数据。

```ad-example
![[assets/Pasted image 20240311152433.png]]

1. 事务T1在读A进行修改之前先对A加**X锁**
2. 当T2再请求对A加X锁时被拒绝，T2只能等待T1释放A上的锁后才能获得对A的X锁
3. 这时T2读到的A已经是T1更新过的值15
4. T2按此新的A值进行运算，并将结果值A=14送回到磁盘。避免了丢失T1的更新
```

### 二级封锁协议

规定：一级封锁协议加上对事务T对要读取的数据加S锁，**读完后**即释放S锁。

效果：可以防止丢失修改、防止读“脏”数据，不能防止可重复读数据。

```ad-example
![[assets/Pasted image 20240311152632.png]]

1. T1在对C进行修改前，先对C加X锁，修改后写回磁盘
2. T2想要读取数据的时候先请求C上加S锁，因T1已在C上加了X锁，T2只能等待
3. T1因某种原因被撤销，C恢复为原值100，T1释放C上的X锁后T2获得C上的S锁，读C=100。避免了T2读“脏”数据，
```

### 三级封锁协议

规定：一级封锁协议加上事务T对要读取的数据加S锁，并直到**事务结束**才释放。

效果：可以防止丢失修改、防止读“脏”数据、防止不可重复读，

```ad-example
![[assets/Pasted image 20240311152835.png]]

1. T1读A，B前，先对A, B加S锁。其他事务只能再对A，B加S锁，而不能加X锁，即其他事务只能读A，B，而不能修改。
2. 当T2为修改B而申请B的X锁时被拒绝只能等T1释放B上的锁，T1为验算再读A，B，这时读出的B仍是100，求和结果仍为150，即可重复读。
3. T1结束才释放A，B上的S锁。T2才获得对B的X锁
```

## 死锁

### 死锁的预防

```ad-attention
在操作系统中广为采用的预防死锁的策略并**不很适合数据库的特点**

DBMS 在解决死锁的问题上更**普遍采用的是诊断并解除死锁**的方法
```

产生死锁的原因：两个或多个事务都已封锁了数据对象，又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。

预防死锁的发生就是要破坏产生死锁的条件：一次封锁法、顺序封锁法。

**一次封锁法**

要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

存在的问题：
- 降低系统并发度。
- 难于事先精确确定封锁对象。

**顺序封锁法**

顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

- 维护成本大：数据库系统中封锁的数据对象多，且在不断地变化。
- 难以实现：很难事先确定每一个事务要封锁哪些对象。

### 死锁的诊断与解除

**超时法**

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

优点：实现简单。

缺点
- 时限设置过短，有可能误判死锁
- 时限设置太长，死锁发生后不能及时发现

**等待图法**

用事务等待图动态反映所有事务的等待情况：

事务等待图是一个有向图，每个结点表示正运行的事务，每条边表示事务等待的情况，若T1等待T2，则从T1指向T2划一条有向边，图中存在回路，则表示系统中出现了死锁。

 解除死锁：
 
 选择一个处理死锁代价最小的事务，将其撤消； 释放此事务持有的所有锁，使其它事务能继续运行。

## 并发调度的可串行性

可串行化调度：
- 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同

可串行性：
- 并发事务正确调度的准则。
- 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

## 两段锁协议

两段锁协议：指所有事务必须分两个阶段对数据项加锁和解锁。

第一阶段是获得封锁，也称为扩展阶段：
- 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。

第二阶段是释放封锁，也称为收缩阶段：
- 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。

![[assets/Pasted image 20240311160342.png]]

事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。

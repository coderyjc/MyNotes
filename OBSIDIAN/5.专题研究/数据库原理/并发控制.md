## 并发控制概述

系统中，可能同时运行着多个事务，而事务的运行需要时间 ，并且事务中的操作是在一
定的数据上进行的。当系统中同时有多个事务在运行时，特别是当这些事务是对同一段数据进行操作时，彼此之间就有可能产生相互干扰的情况。

### 不同的多事务执行方式

1. 串行执行

每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行。

![[assets/Pasted image 20240310170831.png]]

问题：不能充分利用系统资源，发挥数据库共享资源的特点。

2. **交叉并行执行**

在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行。

单处理机系统中的并行事务并没有真正地并行运行，但能够**减少处理机的空闲时间**，提高系统的效率。

![[assets/Pasted image 20240310170919.png]]

3. 同时并发方式

多处理机系统中，每个处理机可以运行一个事务。多个处理机可以同时运行多个事务，实
现多个事务真正的并行运行。

### 并发带来的问题

```ad-example
飞机订票系统中的一个活动序列：
1. 甲售票点(甲事务)读出某航班的机票余额A，设A=16;
2. 乙售票点(乙事务)读出同一航班的机票余额A，也为16;
3. 甲售票点卖出一张票，修改余额A←A-1，所以A为15，写回数据库。
4. 乙售票点也卖出一张票，修改余额A←A-1，所以A为15，写会数据库。

结果：明明卖出两张机票，数据库中机票余额只减少1
原因：第4步中乙事务修改A并写回后覆盖了甲事务的修改。
```

问题：
- 多个事务同时存取同一数据的情况。
- 可能会存取和存储不正确的数据。
- 破坏事务一致性和数据库的一致性。

并发控制是衡量 DBMS 性能的重要标志之一。

并发控制机制的任务
- 对并发操作进行**正确调度**
- 保证事务的**隔离性**
- 保证数据库的**一致性**

### 数据不一致情况

- 丢失修改(LostUpdate)
- 读“脏”数据(DirtyRead)
- 不可重复读(Non-repeatableRead)
- 产生“幽灵”数据

**丢失修改(LostUpdate)**

![[assets/Pasted image 20240310200728.png]]

**读“脏”数据(DirtyRead)**

事务 T1对数据进行了更新但没有提交，事务T2读到了事务T1更新后(未提交)的数据。如果事务T1进行了回滚，那么刚刚事务T2看到的数据就是脏数据。事务T2 进行了脏读。

示例：甲给乙转账500，但是甲还没有提交，但是此时乙查询自己账户多了500。然后甲发现转错人了，回滚了转账。然后乙多出的500就没了。在这个过程中乙查到了没有提交的数据（多出的500），这就是脏读。

**不可重复读(Non-repeatableRead)**

不可重复读：事务A读取数据库中的数据后，事务B更新了数据，当A再次读取数据时，就会发现数据已经发生了改变，这就是不可重复读取。不可重复读取所导致的结果就是一个事务前后两次读取的数据不相同。重点在于update

示例：甲查询自己银行余额为1万，乙这个时候用甲的账号取走了3000，甲再一次查询余额，变成了7000。对甲而言两次结果不一致就是不可重复读。

**产生“幽灵”数据（幻读）**

幻读：如果事务T1基于某个条件读取数据后，另一个事务则更新了同一个表中的数据，这时第一个事务再次读取数据时，根据搜索的条件返回了不同的行，这就是幻读。重点在于insert

示例：甲查询自己银行明细中与乙的资金往来，之后乙向甲转了一笔账，甲再次查询发现比之前的查询多了一条新的记录，这就是幻读。

## 并发控制措施

控制目标：事务运行过程中尽可能隔离事务外操作对本事务数据环境的影响，保证操作的正确性和一致性

并发控制的主要技术——加锁(Locking)
- 加锁就是事务T在对某个数据操作之前，先向系统发出请求，封锁其所要使用的数据。在事务T释放它的锁之前，其他事务不能操作这些数据。

### 基本封锁类型

- 排它锁（X锁）
- 共享锁（S锁）

X锁（写锁）：若事务T对数据对象A加上X锁，则允许事务T**读取和修改**A，其它任何事务都不能再对A加**任何类型的锁**进行任何操作，直到事务T释放X锁，保证其他事务在事务T释放X锁之前不能再读取和修改数据。

S锁（读锁）：若事务T对数据对象A加上S锁，则事务T**只能读**A，但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到事务T释放A上的S锁为止。保证其他事务**可以读数据**，但是在事务T释放S锁前不能对数据做任何修改。

![[assets/Pasted image 20240310201828.png]]

## 封锁协议

在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，如何时申请X锁或S锁、持锁时间、何时释放锁等。称这些规则为**封锁协议**或加锁协议。

规则不同，封锁协议不同，达到的系统一致性级别不同。

### 一级封锁协议




## 死锁


## 并发调度的可串行性


## 两段锁协议
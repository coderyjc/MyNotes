```ad-danger
title: cin/scanf和cout/printf速度对比
scanf的速度是cin的**<font color="#ff0000">6倍以上</font>**
printf的速度比cout也要**<font color="#ff0000">快</font>**
所以数据量大的话，<font color="#ff0000">尽量使用scanf/printf</font>
```


## 读取一行数据

### C++

直接使用`cin`读取，如果一行结束，会返回null

```cpp
int a;
while(cin >> a){
	// do something
}
```

---

使用`stringstream`读取一行，然后依次输入

```cpp
#include<sstream>

string line;
getline(cin, line);
ss.str(line);

int a;

ss >> a;
```


### C

scanf之后，使用getchar读取末尾字符，如果是`\n`，就是一行输入结束

```cpp
char c;
while(c != '\n'){
	scanf("...");
	c = getchar();
	
// do something
}
```

## 字符串读取

getline() 不会在最后加上任何字符，输入是什么样的，存进去就是什么样的

gets() 会在后面空位置上加上 ‘\0’，如果位置不够加，就会报错。

cin之后打一个回车，这个回车会存放到缓冲区，而getline会从cin的缓冲区中读入数据，因此cin后面要想使用getline读取字符串，就必须在cin后面使用getchar将回车吸收。

**数字和字母的判断：**

```c++

#include<cctype>

int isalpha(int ch); // 判断是不是字母

int isdigit( int ch ); // 判断是不是数字

int isalnum( int ch ); // 判断是不是数字或者字母

```


## C语言IO

### 数据类型取值范围

![[assets/Pasted image 20211224160318.png]]

### 整数输出

- %d：按整型数据的实际长度输出。
- %m.nd：m为指定的输出字段的宽度，n定义为实际输出的个数。
- m>0时为右对齐，根据n的大小，不足在左边补0；m<0时和m>0好像没有区别；
- 如果省略m或者n，则m=n；
- 如果只有m且不指定空位填0，根据m的正负值，空位以空格补齐。

```c++
int main(void)
{
    int a = 123;
    printf("m.nd : %5.5d\n", a);    //打印  00123
    printf("-m.nd : %-5.5d\n", a);  //打印  00123
    printf(".nd : %.5d\n", a);      //打印  00123
    printf("m.d : %5.d\n", a);      //打印    123
    printf("md : %5d\n", a);        //打印    123
    printf("md : %05d\n", a);       //指定空位补0：打印  00123
    system("pause");
    return EXIT_SUCCESS;
}
```


### 小数输出

f格式：用来输出实数（包括单--flaot、双精度--double），以小数形式输出,对双精度可以用"%lf"格式输出。有以下几种用法：

- %f：不指定宽度，整数部分全部输出并输出6位小数。
- %m.nf：m为指定的输出字段的宽度，n定义为小数点后保留n位。
- m>0时为右对齐，根据n的大小，不足在左边补空格；
- m<0时为左对齐，根据n的大小，不足在右边补空格；
- 如果实数本身长度大于m，则突破获m的限制,将实数全部输出。若实数本身长度小于m，则左补空格。
- n为小数点后位数，不够补0，多了四舍五入


### scanf 注意事项

回车可以刷新键盘缓冲区的内容

单个字符要用单撇号括起来

```c
scanf("%d",&b);//如果给b正确输入，那么a的值就是一个换行符。

scanf("%c",&a);//如果给b输入一个字符型（不正确输入），那么这个字符型就会赋值给a
```

scanf("%d%d",&a,&b);  //对于输入连续的整形或者浮点型数据，可以用空白符起到间隔数据的作用，字符型的话不用间隔

scanf("%d\n",&a);//scanf函数不要随便加空白字符，否则只能通过错误输入来结束scanf函数

scanf（“%5d”，&a）；a只能接受到输入的前五个数，剩余的可能会被后面的scanf和getchar接收

**[[scanf]] 连续读取两个char**

```c
// 这种情况
scanf("%c", &c);
scanf("%c", &d);

// 或者下面这种情况
scanf("%c%c", &c, &d);

```

以上这两种情况下，回车均会被读取，成为一个换行符。

在输入 `a` `回车`  `a` `回车`  的时候，两次赋值均是  `'a' '\n'` 

在输入`ab` `回车` `ab` `回车` 的时候，两次赋值分别为 `'a' 'b' '\n' 'a'`

可见，scanf读取char的时候会吸收上一次输入残留下来的换行符。

读取两个连续的 int 整数的时候不会出现这种情况


**[[scanf]] 连续读取int 和 char**

同样的，如果输入`整数` `回车` scanf的%c会读取输入int时候残留的换行符

如果输入`整数` `字符` ， 就算两个scanf不在同一条语句，也会正确读取并赋值。



#算法/位运算 #算法/排序 

> https://www.bilibili.com/video/BV13g41157hK?p=3&totalPage=40

指标分不出来的时候, 比如理论分析都是 O(n) 的算法, 这个时候就要进行实际测试, 而不是理论分析

理论分析的时候应该按照最差情况来估计。

## 交换两个变量的值

异或运算

```java
a = a ^ b;  
b = a ^ b;  
a = a ^ b;
```

解析: 

```java
// a = 甲  
// b = 乙  
a = a ^ b; // a = 甲^乙 b = 乙  
b = a ^ b; // a = 甲^乙 b = 甲^乙^乙 = 甲^0 = 甲  
a = a ^ b; // a = 甲^甲^乙 = 乙 b = 甲
```

> [!warning]
>  可以这么干的前提是a和b所占的空间是两块独立的区域

这样做会出错:

```java
void swap(int a[], int i, int j){  
    a[i] = a[i] ^ a[j];  
    a[j] = a[i] ^ a[j];  
    a[i] = a[i] ^ a[j];  
}  
  
int main() {  
    int a[] = {0, 1, 2};  
    swap(a, 1, 1); // 1位置和1位置指向同一个区域, 这样做输出结果是0  
    return 0;  
}
```

### 与异或有关的面试题

1. 在int类型数组中, 有两种数, 一种出现了奇数次, 另一种出现了偶数次.
(1). 找出出现了奇数次的数
(2). 两种数出现了奇数次, 其他所有的数都出现了偶数次, 如何找出这两种数
要求: 
- 时间复杂度O(n)
- 空间复杂度(1)

(1).

用0依次异或每一个元素即可, 略

(2).

```java
public static void printOddTimesNum2(int [] arr){  
    int eor = 0;  
    // 假设这两个奇数分别为 a, b
    for (int i = 0; i < arr.length; i++){  
        eor ^= arr[1]; 
    } 
    // 此时 eor = a ^ b  
    // eor != 0    
    // eor 必然有一个位置上是1
    // 异或运算取出元素最右边的数字  1
    int rightOne = eor & (~eor + 1);  
    
    int onlyOne = 0;  
    for (int cur : arr){  
	    // 只有最右边为1的位置上的数字和cur一样的时候才进行计算
        if((cur & rightOne) == 0){  
            onlyOne ^= cur;
        }
    } 
    System.out.println(onlyOne + " " + (eor ^ onlyOne));  
}
```

第一轮异或运算算出来两个奇数次数字的异或值，因为偶数个数的数字最后的结果都是0，而0和别的数字异或不改变这个数。

将所有这个位置上为0的数字用异或取出来(偶数次出现的异或出来一定是0忽略不计, 奇数次出现的数字在这个位置上一定一个是0, 一个是1), 这一步取出来的是其中的一个数，a或者b

最后用eor异或这个数就是另一个数（eor的值为`a^b`）

事实上，我们是使用这种方式，以这个位置的数字为区分标准，将所有数字分为了两种 —— 这个位置上为0，或者这个位置上为1：a和其他偶次出现的数为0，b和其他偶数次出现的数字为1。

从而将本题目转化为了上面的一道题 —— 再次异或的时候，多了一个条件 `if((cur & rightOne) == 0)` 或者 `if((cur & rightOne) == 1)` 这样就忽略掉了a或者b种的任意一个数字，最后异或出来的结果必然是a或者b其中的一个。



## 二分查找

不一定是有序才能二分。数据可以二分，问题也可以二分。

适用范围：

1. 找某个数是否存在。
2. 找大于一个数字的最左侧的位置和小于某个数字的最右侧的位置也可以二分。
3. 局部最小值问题（无序二分）

**第一种情况**，找某个数是否存在的时候，找到就可以停止了

**第二种情况**，找到之后先记录这个位置，然后继续查找，直到查找到最后。

**第三种情况**

已知：

1. 数组arr无顺序
2. 任意两个相邻的数据不相等
3. 定义局部最小：数据比左右两边的数据都小（1位置比0小就行，n-2比n-1位置上小就行）

设计一种优于O(n)的算法

实现思路：

0位置和n-1位置之间必然出现局部最小。

![[assets/Pasted image 20221227160709.png]]

![[assets/Pasted image 20221227161114.png]]

## 对数器的使用

用来测试算法的正确性。

随机样本产生器

随机生成数据样本，用爆破的方法（写起来简单，可能复杂度比较高的方法）和自己写的算法（复杂度低的方法）跑一遍，比较一下值。



> https://www.bilibili.com/video/BV13g41157hK?p=3&totalPage=40

指标分不出来的时候, 比如理论分析都是 O(n) 的算法, 这个时候就要进行实际测试, 而不是理论分析

## 交换两个变量的值

异或运算

```java
a = a ^ b;  
b = a ^ b;  
a = a ^ b;
```

解析: 

```java
// a = 甲  
// b = 乙  
a = a ^ b; // a = 甲^乙 b = 乙  
b = a ^ b; // a = 甲^乙 b = 甲^乙^乙 = 甲^0 = 甲  
a = a ^ b; // a = 甲^甲^乙 = 乙 b = 甲
```

注意: 
- 可以这么干的前提是a和b所占的空间是两块独立的区域

这样做会出错:

```java
void swap(int a[], int i, int j){  
    a[i] = a[i] ^ a[j];  
    a[j] = a[i] ^ a[j];  
    a[i] = a[i] ^ a[j];  
}  
  
int main() {  
    int a[] = {0, 1, 2};  
    swap(a, 1, 1); // 1位置和1位置指向同一个区域, 这样做输出结果是0  
    return 0;  
}
```

### 与异或有关的面试题

1. 在int类型数组中, 有两种数, 一种出现了奇数次, 另一种出现了偶数次.
(1). 找出出现了奇数次的数
(2). 两种数出现了奇数次, 其他所有的数都出现了偶数次, 如何找出这两种数
要求: 
- 时间复杂度O(n)
- 空间复杂度(1)

(1).
用0依次异或每一个元素即可, 略

(2).

```java
public static void printOddTimesNum2(int [] arr){  
    int eor = 0;  
    for (int i = 0; i < arr.length; i++){  
        eor ^= arr[1];  
    }  
    // eor = a ^ b  
    // eor != 0    // eor 必然有一个位置上是1
    // 异或运算取出元素最右边的数字  1
    int rightOne = eor & (~eor + 1);  
  
    int onlyOne = 0;  
    for (int cur : arr){  
        if((cur & rightOne) == 0){  
            onlyOne ^= cur;  
        }  
    }  
    System.out.println(onlyOne + " " + (eor ^ onlyOne));  
}
```

第一轮异或运算算出来两个奇数次数字的异或值

这个异或值必然有一位是1（因为两个数不相等）

使用异或运算取出最右面的数字1

将所有这个位置上为0的数字用异或取出来(偶数次出现的异或出来一定是0忽略不计, 奇数次出现的数字在这个位置上一定一个是0, 一个是1), 这一步取出来的是其中的一个数

最后用eor异或这个数就是另一个数

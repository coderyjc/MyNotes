
![[assets/Pasted image 20230103094108.png]]

## 发送短信验证码

![[assets/Pasted image 20230104084047.png]]

在登录界面点击发送验证码，向服务器发送了一条请求

![[assets/Pasted image 20230103095601.png]]

![[assets/Pasted image 20230103095640.png]]

在后端实现请求：

Controller

```java
/**  
 * 发送手机验证码  
 */  
@PostMapping("code")  
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {  
    // TODO 发送短信验证码并保存验证码  
    return userService.sendCode(phone, session);  
}
```

Service

```java
Result sendCode(String phone, HttpSession session);
```

ServiceImpl

```java
    @Override  
    public Result sendCode(String phone, HttpSession session) {  
//        1. 提交手机号  
//        2. 校验手机号  
        if (RegexUtils.isPhoneInvalid(phone)) {  
//        3. 不符合-重新提交手机号  
            return Result.fail("手机号输入有误");  
        }  
//        4. 符合-生成验证码  
        String code = RandomUtil.randomNumbers(6);  
//        5. 保存验证码到session  
        session.setAttribute("code", code);  
//        6. 发送验证码  
        log.debug("发送验证码成功，验证码：{}", code);  
        return Result.ok();  
    }
```

这里使用了工具类RegexUtils来校验手机号，使用了RandomUtil获取随机数，使用了Slf4j日志工具类进行日志的打印输出

其中UserServiceImpl类需要在类的头部加上注解，如下

```java
@Slf4j  
@Service  
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
...
}
```

> [!note] 技术点1 工具类的使用
> 工具类 RegexUtils 提供了校验手机号、邮箱、验证码的正则校验函数
> 工具类 RandomUtil 是包 hutool 下的生成验证码的工具类，hutool官网 https://www.hutool.cn/docs/#/

编写完成之后再次发送验证码，成功

![[assets/Pasted image 20230103101547.png]]

## 实现短信验证码登录和注册功能

![[assets/Pasted image 20230104084023.png]]

在前端输入了手机号和验证码之后点击提交，在后台进行用户的登陆或者创建

Controller

```java
@PostMapping("/login")  
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){  
    // 实现登录功能  
    return userService.login(loginForm, session);  
}
```

Service

```java
Result sendCode(String phone, HttpSession session);
```

ServiceImpl

```java
    @Override  
    public Result login(LoginFormDTO loginForm, HttpSession session) {  
//        1. 校验手机号  
        String phone = loginForm.getPhone();  
        if (RegexUtils.isPhoneInvalid(phone)) {  
            return Result.fail("手机号输入有误");  
        }  
//        2. 校验验证码  
        String code = loginForm.getCode();  
        String cacheCode = (String) session.getAttribute("code");  
        if(code == null || !code.equals(cacheCode)){  
            return Result.fail("验证码输入有误");  
        }  
//        3. 根据手机号查询用户  
        User user = query().eq("phone", phone).one();  
//        4. 用户不存在，创建用户  
        if (user == null) {  
            user = createUserByPhone(phone);  
        }  
//        5. 保存用户到session  
        session.setAttribute("user", user);  
        return null;  
    }  
  
    private User createUserByPhone(String phone) {  
		User user = new User();
        user.setPhone(phone);  
        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10));  
        save(user); // mp的直接保存用户
        return user;  
    }
```

> [!note] 技术点2 反向校验避免嵌套过深
> `if(code == null || !code.equals(cacheCode))`
> 在校验验证码和手机号的时候都是检查是不是“不符合规定”，而不是编写“当符合规定”时的业务逻辑；校验“无效“而不是校验”有效“

> [!note] 技术点3 MyBatisPlus 的单表查询
> 在使用了MyBatisPlus的服务类中，可以直接使用query函数进行select单表查询
> `User user = query().eq("phone", phone).one();  `
> 在当前服务类对应的表中，查询phone字段为phone的行，查找一个返回

> [!note] 技术点4 随机用户名前缀的静态变量封装
> 随机用户名的前缀使用了 `SystemConstants.USER_NICK_NAME_PREFIX` 进行封装

此时再次登录的时候显示登录成功，
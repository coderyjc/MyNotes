
![[assets/Pasted image 20230103094108.png]]

## 发送短信验证码

![[assets/Pasted image 20230104084047.png]]

在登录界面点击发送验证码，向服务器发送了一条请求

![[assets/Pasted image 20230103095601.png]]

![[assets/Pasted image 20230103095640.png]]

在后端实现请求：

Controller

```java
/**  
 * 发送手机验证码  
 */  
@PostMapping("code")  
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {  
    // TODO 发送短信验证码并保存验证码  
    return userService.sendCode(phone, session);  
}
```

Service

```java
Result sendCode(String phone, HttpSession session);
```

ServiceImpl

```java
    @Override  
    public Result sendCode(String phone, HttpSession session) {  
//        1. 提交手机号  
//        2. 校验手机号  
        if (RegexUtils.isPhoneInvalid(phone)) {  
//        3. 不符合-重新提交手机号  
            return Result.fail("手机号输入有误");  
        }  
//        4. 符合-生成验证码  
        String code = RandomUtil.randomNumbers(6);  
//        5. 保存验证码到session  
        session.setAttribute("code", code);  
//        6. 发送验证码  
        log.debug("发送验证码成功，验证码：{}", code);  
        return Result.ok();  
    }
```

这里使用了工具类RegexUtils来校验手机号，使用了RandomUtil获取随机数，使用了Slf4j日志工具类进行日志的打印输出

其中UserServiceImpl类需要在类的头部加上注解，如下

```java
@Slf4j  
@Service  
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
...
}
```

> [!note] 技术点1 工具类的使用
> 工具类 RegexUtils 提供了校验手机号、邮箱、验证码的正则校验函数
> 工具类 RandomUtil 是包 hutool 下的生成验证码的工具类，hutool官网 https://www.hutool.cn/docs/#/

编写完成之后再次发送验证码，成功

![[assets/Pasted image 20230103101547.png]]

## 实现短信验证码登录和注册功能

![[assets/Pasted image 20230104084023.png]]

在前端输入了手机号和验证码之后点击提交，在后台进行用户的登陆或者创建

Controller

```java
@PostMapping("/login")  
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){  
    // 实现登录功能  
    return userService.login(loginForm, session);  
}
```

Service

```java
Result sendCode(String phone, HttpSession session);
```

ServiceImpl

```java
    @Override  
    public Result login(LoginFormDTO loginForm, HttpSession session) {  
//        1. 校验手机号  
        String phone = loginForm.getPhone();  
        if (RegexUtils.isPhoneInvalid(phone)) {  
            return Result.fail("手机号输入有误");  
        }  
//        2. 校验验证码  
        String code = loginForm.getCode();  
        String cacheCode = (String) session.getAttribute("code");  
        if(code == null || !code.equals(cacheCode)){  
            return Result.fail("验证码输入有误");  
        }  
//        3. 根据手机号查询用户  
        User user = query().eq("phone", phone).one();  
//        4. 用户不存在，创建用户  
        if (user == null) {  
            user = createUserByPhone(phone);  
        }  
//        5. 保存用户到session  
        //session.setAttribute("user", user);  
        session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));
        return Result.ok();  
    }  
  
    private User createUserByPhone(String phone) {  
        User user = new User();  
        user.setPhone(phone);  
        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10));  
        save(user);  
        return user;  
    }
```

> [!note] 技术点2 反向校验避免嵌套过深
> `if(code == null || !code.equals(cacheCode))`
> 在校验验证码和手机号的时候都是检查是不是“不符合规定”，而不是编写“当符合规定”时的业务逻辑；校验“无效“而不是校验”有效“

> [!note] 技术点3 MyBatisPlus 的单表查询
> 在使用了MyBatisPlus的服务类中，可以直接使用query函数进行select单表查询
> `User user = query().eq("phone", phone).one();  `
> 在当前服务类对应的表中，查询phone字段为phone的行，查找一个返回

> [!note] 技术点4 随机用户名前缀的静态变量封装
> 随机用户名的前缀使用了 `SystemConstants.USER_NICK_NAME_PREFIX` 进行封装

此时再次登录的时候显示登录成功，但是用户个人中心界面会一闪而过，然后又跳到了登录界面。因为这时候没有实现登陆校验。

## 实现登录校验拦截器

每一个请求都需要登录校验，但如果写在每一个Controller中的话会非常麻烦，所以写在通用的拦截器中，统一校验当前的登录状态。

将所有的校验流程放到拦截器中。

将拦截器中得到的信息分发到Controller中，同时应该注意线程的安全问题——因此应该用**ThreadLocal**解决。

![[assets/Pasted image 20230104092208.png]]

LoginInterceptor

```java
public class LoginInterceptor implements HandlerInterceptor {  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
//        1. 获取session  
        HttpSession session = request.getSession();  
//        2. 获取session中的用户  
        Object user = session.getAttribute("user");  
//        3. 判断用户是否存在  
        if (user == null) {  
//        4. 不存在，拦截，401  
//            401 未授权异常  
            response.setStatus(401);  
            return false;  
        }  
//        5. 存在，保存到ThreadLocal  
        UserHolder.saveUser((UserDTO) user);  
//        6. 放行  
        return true;  
    }  
  
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
        UserHolder.removeUser();  
    }  
}
```

> [!note] 技术点6 使用UserDTO隐藏用户信息
> 直接返回User的时候，User中的手机号，密码等信息也会被一并返回，因此应该对用户信息进行隐藏。
> 在向ThreadLocal中存放信息的时候直接存放UserDTO信息，达到隐藏用户信息的目的
> > `session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));`
> 存放信息的时候使用BeanUtil将user的信息拷贝到UserDTO中直接保存


```java
@Configuration  
public class MvcConfig implements WebMvcConfigurer {  
  
    @Override  
    public void addInterceptors(InterceptorRegistry registry) {  
  
        registry.addInterceptor(new LoginInterceptor())  
                .excludePathPatterns(  
                        "/shop/**",  
                        "/voucher/**",  
                        "/shop-type/**",  
                        "/upload/**",  
                        "/blog/hot",  
                        "/user/code",  
                        "/user/login"  
                );  
    }  
}
```

Controller

```java
@GetMapping("/me")  
public Result me(){  
    // 获取当前登录的用户并返回  
    UserDTO user = UserHolder.getUser();  
    return Result.ok(user);  
}
```

Controller直接从UserHolder中获取用户信息并返回。

UserHolder
```java
public class UserHolder {  
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();  
  
    public static void saveUser(UserDTO user){  
        tl.set(user);  
    }  
  
    public static UserDTO getUser(){  
        return tl.get();  
    }  
  
    public static void removeUser(){  
        tl.remove();  
    }  
}
```

> [!note] 技术点5 使用ThreadLocal保存用户信息
> 保存在当前用户线程中，保证了线程安全，并能在需要的时候在全局直接取用。


完成登录校验之后再次登录即可登录成功。

![[assets/Pasted image 20230104094911.png]]


## 基于Redis实现共享session登录

### Tomcat 的session共享问题

多台tomcat不共享session存储空间，当请求切换到不同的tomcat服务器的时候导致数据丢失问题

session的替代方案应该同时满足
- 数据共享
- 内存存储
- kv结构

### 基于Redis的共享session登录





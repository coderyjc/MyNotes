## 【23】OS


> **OS 有哪些特征、基本特征是什么？**

并发、共享、虚拟、异步。基本特征是并发和共享，因为这两个特征是早就后两个特征的基础。

**并发**是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。
**共享**是指系统中的资源可供内存中多个并发执行的进程共同使用，可以分为互斥共享和同时访问两种方式，前者是指一段时间内只能有一个进程访问的资源，后者是指允许多个进程同时访问的资源。
**虚拟**是指把一个物理上的实体变为若干逻辑上的对应物。物理实体（前者）是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。虚拟技术可以分为时分复用和空分复用，比如虚拟内存是空分复用，处理器的分时共享是时分复用。
**异步**是指多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。


> 多道程序技术是什么？为什么引入多道程序技术？

**是什么**：多道程序技术（Multiprogramming）是一种计算机系统的工作方式，它允许多个程序同时存在于内存中，并且这些程序可以同时执行。在多道程序技术下，计算机系统的处理器不会等待单个程序的所有操作完成，而是会在等待某个程序的I/O操作时切换到执行另一个程序，从而实现了多个程序的并发执行。

**优点**：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用；系统吞吐量大，CPU和其他资源保持“忙碌”状态。

> 计算机系统的异步性？

**是什么**：计算机系统的异步性指的是系统中各个组件或任务的执行是独立于其他组件或任务的执行，并且它们的执行速度和顺序是不可预知的，进程的执行并不是一贯到底的，而是走走停停的，这就是异步性。

1. **多任务操作系统**：在多任务操作系统中，多个进程或线程可以同时运行，它们的执行顺序和时间片分配是由操作系统调度器决定的，因此它们的执行是异步的。
2. **事件驱动编程**：GUI 应用程序中用户的鼠标点击、键盘输入等事件可以随时发生，因此事件处理程序的执行是异步的。
3. **并发编程**：在并发编程中，多个任务可能会同时执行，并且它们的执行顺序和时间是不可预知的。并发编程通常涉及到共享资源的访问和同步问题。

> 分时系统和实时系统的区别？

【目标、调度方式、应用领域】

- **目标**：实时操作系统的主要目标是满足对任务响应时间有严格要求的实时性应用，而分时操作系统的主要目标是允许多用户共享计算机资源，提高资源利用率。
- **调度方式**：实时操作系统采用严格的任务调度策略，保证任务在规定的时间内完成；而分时操作系统采用分时调度的方式，让多个用户的任务轮流执行。
- **应用领域**：实时操作系统主要应用于对任务响应时间有严格要求的领域，如航空航天、汽车电子、工业控制等；而分时操作系统主要应用于多用户共享计算机资源的环境，如个人电脑、服务器等。

> 什么是管态？什么是目态？它们与进程运行状态的关系是什么？

**定义**：目态是用户态，管态是核心态。操作系统内核工作在核心态，而用户程序工作在用户态。

**关系**：系统不允许用户程序实现核心态的功能，但是用户程序必须使用这些功能，当用户程序需要使用核心态的功能的时候，就会主动执行trap指令发起系统调用，请求系统提供服务。系统通过硬件中断机制进入核心态，运行*管理程序*。还有一种情况就是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。

*扩展：列举相关的管理程序？*
1. 设备管理。完成设备的启动，请求或释放；
2. 文件管理。完成文件的读、写、创建及删除等功能。
3. 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
4. 进程通信。完成进程之间的消息传递或信号传递等功能。
5. 内存管理。完成内存的分配、回收等功能。

> 介绍一下作业与作业步？

**作业**：作业是一个比程序更为广泛的概念，包含通常的程序和数据，还有一份作业说明书。系统根据该说明书来对程序的运行进行控制。  

**作业步**：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才得到结果，其中的每一个加工步骤称为一个作业步。
 
> 库函数和系统调用的区别和联系？

**库函数**：库函数是由**编程语言或操作系统**提供的一组函数，用于执行常见的任务或操作，如输入输出函数、内存分配函数等。库函数的调用是由用户程序直接发起的，不一定要进入内核态执行。
**系统调用**：系统调用是**操作系统**提供给用户程序访问操作系统核心功能的接口。它们允许用户程序请求操作系统执行特权操作，如文件操作、进程控制。
**联系**：库函数是可以包含系统调用的，也就是说，库函数实现了更高层次的抽象。

> 可封闭性和可再现性？

**可再现性**：指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论是它从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。

**封闭性**：程序执行得到的最终结果由给定的初始条件决定，不受外界因素的影响

> 程序和进程的关系？

1. **【动静】** 而程序是一组有序的指令集合，是一种静态的概念。进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。
2. **【存在】** 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命周期，是暂时存在的；而程序则是一组代码的集合，是永久存在的，可长期保存。
3. **【包含】** 一个进程可以执行一个或几个程序，一个程序也可构成多个进程。进程可创建进程，而程序不可能形成新的程序。
4. **【组成】** 进程与程序的组成不同。进程的组成包括数据和PCB，而程序是由一系列的指令和数据组成的。

> **谈谈什么是PCB**

**是什么**：进程控制块（Process Control Block，PCB）是进程实体的一部分，是进程存在的唯一标志。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。比如创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程的PCB。

可以将PCB看成一种数据结构，他包含了这个进程拥有的一些信息：

1. 进程描述信息。进程标识符：标志各个进程，每个进程都有一个唯一的标识号。用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。
2. 进程控制和管理信息。进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。
3. 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。
4. 处理机相关信息，也称处理机的上下文，主要指处理机中各寄存器的值。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。

> 什么是通道、通道的功能？

**是什么**：为了获得CPU最高与外设的并行能力，引入了通道结构。通道技术又被称为I / O处理机。

**作用**：通道技术实现了I/O系统的独立性和各个部件的并行性。

通道是一种通过执行通道程序管理I/O操作的**控制器**，它使主机（CPU和内存）与I/O操作之间达到更高的并行程度。由于它的任务是管理实现输入/输出操作，提供一种传送通道，所以将这种部件称作“通道”。CPU把数据传输功能下放给通道，这样，通道与CPU分时使用内存（资源），就可以实现CPU与外设的并行工作。

**简单理解**：通道就是可以通数据的CPU发出一条通道命令，然后由通道和外设交换数据，之后CPU就做其它的事情，通道和外设交换完数据后再向CPU汇报，CPU再处理


> **什么是死锁？**

**定义**：死锁是指多个进程因竞争资源而造成的一种局（互相等待），若无外力作用，这些进程都将无法向前推进。

**产生的原因**：对不可剥夺资源的竞争，以及进程顺序推进非法。

**必要条件**：
1. 互斥条件。进程要求对所分配的资源（如打印机）进行排他性使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
2. 不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。
3. 请求并保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4. 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

> **怎样预防死锁？**

破坏4个产生死锁的必要条件之一即可。

1. **破坏互斥条件**：若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。
2. **破坏不剥夺条件**：当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
3. **破坏请求并保持条件**：采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行，这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
4. **破坏循环等待条件**：为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源R，则该进程在以后的资源申请中就只能申请编号大于R的资源。这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加：尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。

> **如何避免死锁？**

银行家算法。

> 介绍一下银行家算法和思想

操作系统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

> 举例解释一下同步和互斥？

1. **同步（Synchronization）**：同步指的是多个线程之间按照一定的顺序协调执行。例如，当多个线程需要访问共享资源时，为了避免竞态条件和数据不一致的问题，可以使用同步机制来确保只有一个线程能够访问共享资源，或者在访问之前对共享资源进行加锁。常见的同步机制包括互斥锁、信号量、条件变量等。
    **举例**：银行取钱的例子。多个客户同时读取账户余额并进行更新操作，由于读取和更新不是原子操作，可能会导致多个客户同时读取到相同的余额并对其进行更新，而不是基于最新的余额进行更新，导致最终结果不正确。
    
2. **互斥（Mutual Exclusion）**：互斥指的是对共享资源的访问进行排他性控制，即同一时刻只允许一个线程访问共享资源，其他线程需要等待。互斥可以避免多个线程同时修改共享资源导致的数据不一致问题。
    **举例**：sum++的问题。


> 解释一下管程是什么？

管程（Monitor）是一种进程同步工具，旨在解决多线程间的同步与互斥问题。

它包含了一组共享资源及对这些资源的操作，以及一组条件变量，用于线程间的通信和同步。管程提供了一种结构化的方法来管理共享资源的访问，以确保线程间的安全性和正确性。

> OS 有那几种方式将程序装入内存？

1. **绝对装入**。绝对装入方式只适用于单道程序环境。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。逻辑地址与实际内存地址完全相同，程序中所用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。
2. **可重定位装入**。在多道程序环境下，多个目标模块的起始地址通常都从0开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。（在装入时对目标程序中指令和数据地址的修改过程称为重定位），又因为地址变换通常是在进程装入时一次完成的，故称为**静态重定位**。当一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则无法装入。此外，作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。
3. **动态运行时装入**。也称**动态重定位**。程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。动态重定位的优点：可以将程序分配到不连续的存储区；在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享。

> 为了实现重定位需要哪些硬件？

基址寄存器（Base Register）和限长寄存器（Limit Register）

- 基址寄存器存储了程序或数据在内存中的**最小物理地址**，而限长寄存器则存储了程序或数据**所占用的内存空间的长度**。
- 当程序或数据需要被加载到内存时，基址寄存器和限长寄存器能够指定加载到内存的具体位置和长度，从而实现重定位。

进一步：*基址寄存器和限长寄存器如何实现内存保护？*

1. **访存操作**：
    - 当程序或数据需要访问内存时，CPU会将要访问的地址（逻辑地址）与基址寄存器中存储的基址相加，得到物理地址。
    - 同时，CPU会检查物理地址是否小于限长寄存器中存储的限长值，以确保访问的地址在指定的内存范围内。
2. **内存访问权限**：
    - 如果访问的地址在指定的内存范围内（即物理地址小于基址加上限长），则访问被允许，CPU会执行相应的读取或写入操作。
    - 如果访问的地址超出了指定的内存范围，CPU会产生一个异常（例如内存访问越界异常），操作系统会相应地处理这个异常，通常会终止相关进程或线程，以防止非法的内存访问。

> 虚拟存储器是什么，有什么特征？

**虚拟内存** 是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上物理内存通常被分隔成多个内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

三个特征：
1. **多次性。** 是指作业运行时无需一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行。以后每当要运行到尚未调入的那部分程序时，再将它调入。多次性是虚拟存储器**最重要的特征**。
2. **对换性。** 是指无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）。正是由于对换性，才使得虚拟存储器得以正常运行。
3. **虚拟性。** 是指**从逻辑上扩充内存**的容量，使用户所看到的内存容量远大于实际的内存容量。这是虚拟存储器所表现出的**最重要特征**，也是实现虚拟存储器的最重要目标。

> 分页与分段的区别与联系？

区别：
1. **目的**：分页仅是系统管理上的需要，是为实现离散分配方式，以提高内存的利用率。而不是用户的需要；段是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是能更好地满足用户的需要。
2. **长度**：页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的；段的长度不固定，决定于用户所编写的程序，通常由编译程序在编译时根据信息的性质来划分。
3. **地址空间**：分页的程序地址空间是一维的，即单一的线性地址空间，程序员利用一个记忆符即可表示一个地址；分段的程序地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
4. **碎片**：有内部碎片，无外部碎片；分段有外部碎片，无内部碎片。

> 分页的硬件支持？

1. **页表（Page Table）**：页表是分页技术中最重要的硬件数据结构之一，用于将进程的逻辑地址映射到物理内存中的页框。页表通常是一个表格，其中包含了每个页的映射信息，如页号、页框号以及其他控制信息。
2. **地址转换机制**：硬件需要支持地址转换机制，将进程的逻辑地址转换为对应的物理地址。
3. **TLB**：为了加速地址转换过程，硬件通常会实现一个地址转换缓存，如页表项缓存（Translation Lookaside Buffer，TLB）。TLB 存储了最近使用的页表项，可以避免每次访问都要访问内存中的页表，提高了地址转换的速度。


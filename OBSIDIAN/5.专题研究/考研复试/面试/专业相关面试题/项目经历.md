## 项目经历

解决了什么问题
创新点在那里
你的贡献是什么
使用了什么技术
取得了什么成果
遇到最难的问题是如何解决的，从中学会了什么

## 教师资格考试数据管理系统

### 介绍

**【原因】**

我的毕业设计项目名称是《教师资格考试数据分析系统》，之所以选择这个项目是因为大二的时候参加了大创，负责大创的系统的几乎所有工作，得到了当时带队老师王学军老师的赏识，在大四的时候负责王老师的项目中的一个子系统，也就是教师资格考试数据分析系统。

**【当前系统的问题】**

在这个系统之前，我对有关部门现有的数据分析方式和管理系统进行了考察和调研，发现现有的系统存在数据分析和统计方面操作繁琐，导入导出不灵活等问题。

**【我的工作】**

因此，我根据现有系统的缺点，重写了原有的系统，针对性地进行了优化并，扩展了原有的功能。

**【具体的工作】**

原有的系统没有数据大屏，只能查询并导出某一年的数据，数据统计功能只支持单字段统计，比如某一年报考笔试的男女比例，统计方式非常局限。

我的系统中，增加了数据大屏，在数据大屏中可以看到本年度报考相关的一些信息，比如各个市区的报考人数等，并且对于所管理的数据，除了基本的增删改查功能之外，还支持所有字段的筛选和按需导出，还可以选择查询结果进行导出。在数据统计方面，我的系统支持多字段统计，比如我可以筛选连续几年报考人数的男女比例进行统计并绘制柱状图，统计出来的数据和统计图也支持导出到本地。

此外，为了系统的安全性考虑，我增加了用户管理功能，并且增加了数据备份和恢复功能，让用户可以随时进行所有数据的备份和恢复。

最终我的毕业设计获得校级优秀毕业设计的荣誉，我也非常感谢那位老师给我的这次机会。

### 使用技术

这个项目的整体架构是前后端分离的。

前端主要使用了Vue系列的技术，有Vue3，Vue-Router路由管理，Pinia状态管理，网络请求库Axios，同时使用了Element-Plus作为组件库构建网页，使用了Apache Echarts渲染数据统计图，最后我使用了vite构建工具用来构建整个项目。

后端使用了SpringBoot开发框架，结合了MyBatisPlus作为数据库交互工具。使用了MySQL作为数据库。

*什么是前后端分离？和不分离相比有什么区别？*

传统的开发方式是MVC方式，也就是模型-视图-控制器（表示层-业务逻辑层-数据访问层），这种方式在大规模的开发中劣势比较明显，就是前后端代码的耦合度比较高，不利于后期的维护。

而前后端分离将前后端代码解耦，前端页面负责数据显示和用户交互，后端负责业务逻辑和数据存储，前后端通过网络请求使用json进行通信，在项目开发的时候可以并行开发，互不影响，项目开发完成之后，前端和后端可以分别部署，也就是说可以分别部署在不同的服务器上。

因此，这种开发方式可以降本增效、提高系统的可维护性和可扩展性。

*前端不都是HTML、CSS、JavaScript之类的吗，你为什么用了这些？*

使用框架和构建工具（如 Vue.js 和 Vite）有助于提高开发效率、改善代码组织和管理、增强应用程序的可维护性和可扩展性等方面。

首先框架提供了丰富的功能和工具，拿vue来说，他提供了组件化开发，数据绑定等功能，vue-router提供了路由管理功能，这些功能可以大大简化开发过程，减少开发时间。相比于原生的 JavaScript 开发，使用框架可以更快地构建出复杂的应用程序。

此外，首先我使用了vite作为前端构建工具。相较于使用传统的前端技术，这种技术除了在开发时候效率高，而且可以对资源进行优化，比如项目中的图片、字体等静态资源进行优化处理，例如压缩图片、转换字体格式等，以减小资源文件的体积，提高页面加载速度。

*｛Vue，Vue-Router，Pinia，Axios，Echarts｝是什么，有什么用？为什么选择？*

**Vue** 是一个JavaScript前端框架，通常用于构建交互式的用户界面和单页面应用程序。通过简洁的 API 和响应式数据绑定机制，可以让开发者更加高效地构建交互式的用户界面和单页面应用程序。

**Vue-Router** Vue Router 是 Vue.js 框架的官方路由管理器，用于构建单页面应用程序（SPA），能够实现路由导航、页面跳转、路由参数传递、路由嵌套等功能，提供了丰富的路由配置选项和路由守卫机制，是构建现代化 Web 应用的重要工具之一。

**Pinia** Pinia 是一个状态管理库，专为 Vue 3 设计，它采用了类似 Vuex 的思想，但更加简洁、灵活，并且与 Vue 3 生态更好地集成，使得状态管理变得更加优雅和高效。

**Axios** 是一个用于网络请求的库，支持在浏览器和 Node.js 环境中发送 HTTP 请求，提供了简洁易用的 API，支持 Promise API，具有请求和响应的拦截器、数据转换、错误处理等功能，被广泛应用于前端开发中进行与后端交互的网络请求操作。

**Echarts**：在开发中，为前端开发提供直观、生动、可交互、可高度个性化定制的数据可视化图表，如数据大屏展示、运营分析、商业报表等。支持多种图表类型，不仅有常见的折线图、柱状图和饼图等，还有用于地理数据可视化的地图、热力图等，用于关系数据可视化的关系图。提供丰富的交互方式，如数据展示、缩放、视图切换、图例过滤等。

*pinia可以代替cookie和session吗*

Pinia 是一个状态管理库，通常用于 Vue.js 应用程序中。它的主要目的是帮助管理 Vue.js 应用程序中的状态（state），并提供一种可预测的方式来管理状态变化。

然而，Pinia 本质上是一个客户端库，用于管理前端应用程序的状态，并不涉及服务器端的持久化存储，因此无法直接代替 cookie 和 session 这样的服务器端存储机制。

Cookie 和 session 主要用于在客户端和服务器端之间进行状态管理。Cookie 是一小段文本信息，存储在客户端浏览器中，可用于存储用户的身份认证信息、偏好设置等。Session 则是在服务器端维护的用户会话信息，通常使用唯一的会话标识符来识别用户。

*cookie、session和token的区别？*

1. Cookie：
    - Cookie 是一小段文本信息，存储在客户端浏览器中。
    - 由服务器发送给客户端，客户端在浏览器中存储。
    - 主要用于存储用户的身份认证信息、偏好设置等。
    - 可以设置过期时间，可以设置为会话级别或持久性的。
    - 由浏览器自动管理，每次请求都会发送到服务器端。
    - 由于存储在客户端，可能存在安全性和隐私方面的考虑。
2. Session：
    - Session 是在服务器端维护的用户会话信息。
    - 在用户访问服务器时创建，通常会分配一个唯一的会话标识符（Session ID）。
    - 会话信息可以存储在服务器内存、数据库或其他存储介质中。
    - 主要用于跟踪用户的状态，如登录状态、购物车内容等。
    - 由服务器管理，通常使用会话标识符进行跟踪。
    - 会话可以有过期时间，一般在一段时间内无用户活动会被销毁。
3. Token：
    - Token 是一种凭证，用于进行身份验证和授权。
    - 通常是一串长随机字符，被服务器生成并发送给客户端。
    - 可以存储在客户端的 Cookie、localStorage 或 sessionStorage 中。
    - 主要用于实现无状态（stateless）的身份认证，因为服务器不需要在会话中维护用户状态。
    - 通常与 OAuth、JWT（JSON Web Token）等身份验证协议结合使用。
    - 由客户端管理，每次请求时需要将 Token 发送给服务器进行验证。

*maven是什么？为什么使用maven？*

Apache Maven 是一个用于 Java 项目的项目管理和构建工具。通过定义项目的结构、依赖关系和构建过程，使得开发者能够更加简单、高效地管理项目的生命周期。

我们在java开发中需要用到大量的依赖，也就是第三方库，使用maven中的pom文件可以快速的增添和删除第三方库。

除此之外，我认为它最重要的一个功能就是基于项目生命周期的项目管理，比如clean可以清除已经构建的项目，test可以进行快速的项目测试等等。

*｛SpringBoot、MyBatisPlus｝是什么，有什么用，为什么选择他们？*

**SpringBoot** 是一种Java后端框架，它可以大大简化Java应用程序的开发。

**MyBatisPlus** 是基于 MyBatis 的增强工具库，提供了更便捷的持久层操作方式，包括代码生成器、通用 CRUD 方法、分页查询、逻辑删除、乐观锁、多租户支持等功能，简化了数据库操作，提高了开发效率。

*SSM中各个组件的作用是什么？*

1. **Spring（核心容器）**：
    - Spring 是一个轻量级的 IoC（Inversion of Control）和 AOP（Aspect-Oriented Programming）容器。
    - Spring 容器管理着应用程序中的对象（bean），负责它们的创建、依赖注入和生命周期管理。
2. **Spring MVC（Web 框架）**：
    - Spring MVC 是 Spring Framework 中的一个模块，用于构建基于 MVC（Model-View-Controller）设计模式的 Web 应用程序。
    - Spring MVC 提供了一组组件，包括控制器（Controller）、视图解析器（View Resolver）、处理器映射器（Handler Mapping）、模型（Model）等，用于处理用户请求并生成响应。
    - Spring MVC 基于注解的控制器、灵活的配置和可扩展性，使得开发者可以轻松构建可维护和高性能的 Web 应用程序。
3. **MyBatis（持久层框架）**：
    - MyBatis 是一个轻量级的持久层框架，用于简化 Java 应用程序与数据库之间的交互。
    - MyBatis 提供了 SQL 映射文件和 Java 接口的方式来定义数据库操作，使得开发者可以使用简单的 XML 或注解来编写 SQL 查询和更新语句。
    - MyBatis 提供了事务管理、缓存管理、延迟加载等功能，可以帮助开发者提高数据库访问的效率和性能。

*SpringBoot和SSM相比的优势在哪？*

1. **快速启动和简化配置**：
    - Spring Boot 提供了自动配置功能，可以根据项目的依赖自动配置应用程序的环境，大大简化了项目的配置过程。
    - 相比之下，SSM 需要手动配置很多内容，如 Spring 的 XML 配置、Spring MVC 的配置以及 MyBatis 的 XML 映射文件等，配置相对繁琐。
2. **约定优于配置**：
    - Spring Boot 遵循约定优于配置的原则，提供了一系列默认配置，开发者只需关注业务逻辑，减少了开发过程中的样板代码。
    - SSM 则需要开发者自行配置很多细节，需要更多的样板代码。
3. **内置容器**：
    - Spring Boot 内置了常用的 Web 服务器（如 Tomcat、Jetty），可以直接打包为可执行的 JAR 文件，并以独立的方式运行，无需外部 Web 服务器的支持。
    - SSM 需要依赖外部的 Web 服务器来运行，需要手动部署和配置，相对繁琐。
4. **集成度高**：
    - Spring Boot 集成了大量的常用库和组件，例如 Spring Data、Spring Security、Spring Batch 等，提供了更多功能上的支持。
    - SSM 可以通过整合其他框架和组件来扩展功能，但需要开发者手动进行集成和配置。

*java打jar包和war包的区别*

1. **JAR 包**（Java Archive）：
    - JAR 包中包含了应用程序的所有类文件、资源文件和依赖库（如果有）。
    - JAR 包适用于独立的 Java 应用程序，可以通过命令行或双击运行。
    - 对于普通的 Java 应用程序，可以直接打包成 JAR 文件，并通过 Java 虚拟机（JVM）来执行。
2. **WAR 包**（Web Application Archive）：
    - WAR 包主要用于打包 Web 应用程序，如基于 Servlet、JSP 的 Java Web 应用程序。
    - WAR 包中包含了 Web 应用程序的所有静态资源、动态页面（JSP、HTML）、Servlet 类、配置文件（web.xml）、以及依赖的 Java 类库（JAR 文件）等。
    - WAR 包可以部署到支持 Java EE 标准的应用服务器（如 Tomcat）中运行。
    - WAR 包的结构遵循 Java EE 规范，通常包含 WEB-INF 目录用于存放应用程序的配置文件和类文件，以及 META-INF 目录用于存放一些元数据信息。

综上所述，JAR 包主要用于打包独立的 Java 应用程序，而 WAR 包主要用于打包 Java Web 应用程序，用于部署到 Web 容器中运行。


### 实现细节

*数据大屏如何实现？*

数据大屏使用了echarts库和，然后手写的css列表布局。

在页面加载时进行数据的请求，请求到数据之后进行图表的渲染。

*备份和恢复如何实现？*

备份和恢复是通过mysqldump命令进行数据库中某个表的导出。

前端发送了备份请求之后，后端会根据请求中的参数，包括数据库名称，表名称等进行指令的组合 `mysqldump -h" + hostIP + " --databases " + databaseName + " --tables " + tableName + " -u" + userName + " -p" + password + " --default-character-set=UTF8`
然后通过`Process process = Runtime.getRuntime().exec(command);`java 调用命令的类进行指令的执行，然后将执行结果返回。

恢复功能是通过执行指令序列完成的。 当前端把要恢复的表的相关参数传给后端之后，后端会进行指令的拼接，具体来讲就是通过java创建线程调用指令进行mysql的连接，`use database` 然后 `source xxx.sql`

*遇到最难的问题是什么，如何解决的？*

我认为最难的地方是两个字段的统计数据查询和统计图的生成。也就是说我需要实现任意一个表中任意两个字段的对比统计图。

因为我不可能把所有数据的所有表的所有字段的组合都写一遍，因此我需要对任意两个字段的查询进行封装和抽象。

我的实现方式是这样的：

前端会将要统计的某年的两个属性发送给后端，比如我要统计2016年的性别和最高学位的对比柱状图，这里还涉及到了一个问题，就是两个字段谁是第一字段，谁是第二字段，如果性别是第一字段，那么我们统计的是每个性别里最高学位的对比图；如果最高学位是第一字段，那么我们统计的就是每个最高学位中的男女比例对比图。

确定了第一字段和第二字段，然后前端发送请求给后端，然后由后端进行处理。

在后端，我封装了一个字段统计类，属性有列1，列2和数量，其中列1和列2是字符串类型，存储要查询的两个字段名。在查询的时候我使用了变量占位符，在运行的时候将前端需要查询的数据的字段动态的填充在sql模版中进行查询，然后返回字段统计类的列表。最终后端得到的就是一个统计好的字段的列表。

然后后端将这个列表发送给前端。

然后在前端，由于使用的echarts的数据，他对双列柱状图统计的数据格式的要求和从后端返回来的数据不同，因此前端在拿到后端返回的数据之后，还要对数据进行修整。具体来讲就是根据字段的属性，把同一个系列的属性的数据以一个列表的形式集中存放。然后放在一个series中，然后echarts再进行渲染。


## 基于云平台的铁路智能巡检系统

### 介绍

NVIDIA Jetson TX2 8+32G ，arm-a系列

**【原因】**

经过我们的调研发现，存在部分地区的铁路巡检仍然是依靠人力进行检测和维护的，存在“作业效率低、人身安全隐患、无客观标准、原始数据无详实记录、人工成本增加、夜间作业难免漏检”等诸多弊端。

**【创新点、解决的问题】**

本项目构建一个铁路巡检云平台，主要采用巡检车利用深度学习的方法对铁路关键部件和部分缺陷特征进行识别，并将识别信息的信息及GPS信息传输至云端，同时也支持人工巡检数据上报（填写故障信息，拍照上传）；云平台基于铁轨线路图显示线路状况，并将检修任务下达至app，检修人员通过app接收任务，前往目的地检修，从而实现了巡检车、人工——云端——检修人员等三位一体的工作过程。

**【我的工作】**

我的工作主要是实现了数据大屏、管理系统、安卓app的开发。

**遇到最难的问题是如何解决的，从中学会了什么**

把模型部署了开发板之上之后

### 使用技术

**Uni-APP** 基于Vue.js的跨平台应用开发框架，它是由DCloud（一家专注于移动应用开发的技术公司）开发和维护的。Uni-APP允许开发者使用Vue.js来编写一次代码，然后将其发布到多个不同平台，包括iOS、Android、H5（Web）、以及各种小程序平台（如微信小程序、支付宝小程序等）。

也就是说我只需要编写一次基于web 的代码，就可以发布到多个平台进行运行，这意味着相关的人员甚至可以不需要下载安卓app，只需要通过小程序就能进行相关事务的惯例。大大的增强了程序的可扩展性和易用性。

### 实现细节

图像识别是如何实现的：

使用了yolov5模型，

有三种损伤类型：擦伤、裂纹、掉块

因为当时没有找到适合yolov5s的数据集，因此是使用的


Type-I RSDDs数据集，采集自express rails，**包括67张图像**
数据标注、模型训练


## 博客





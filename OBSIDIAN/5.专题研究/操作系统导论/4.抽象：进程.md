```ad-note
为什么题目1的两个简称之间没有进行调度，但题目2的进行调度了，是因为题目2中的进程有IO吗？

```




## process-run.py Options

![[assets/Pasted image 20230511093956.png]]

![[assets/Pasted image 20230511094016.png]]

## 题目

1．用以下标志运行程序：`./process-run.py -l 5:100,5:100`。CPU利用率（CPU使用时间的百分比）应该是多少？为什么你知道这一点？利用 -c标记查看你的答案是否正确。

```sh
$ python3 process-run.py -l 5:100,5:100
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu
  cpu

Process 1
  cpu
  cpu
  cpu
  cpu
  cpu

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will run LATER (when it is its turn)
```

==My Answer==

两个进程都利用5个时间单位的CPU，利用率都是100%

因此总利用率为100%

==Answer==

```sh
$ python3 process-run.py -l 5:100,5:100 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1        RUN:cpu         READY             1
  2        RUN:cpu         READY             1
  3        RUN:cpu         READY             1
  4        RUN:cpu         READY             1
  5        RUN:cpu         READY             1
  6           DONE       RUN:cpu             1
  7           DONE       RUN:cpu             1
  8           DONE       RUN:cpu             1
  9           DONE       RUN:cpu             1
 10           DONE       RUN:cpu             1

Stats: Total Time 10
Stats: CPU Busy 10 (100.00%)
Stats: IO Busy  0 (0.00%)
```

2．现在用这些标志运行：./process-run.py -l 4:100,1:0。这些标志指定了一个包含4条指令的进程（都要使用CPU），并且只是简单地发出I/O并等待它完成。完成这两个进程需要多长时间？利用-c检查你的答案是否正确。

```sh
$ python3 process-run.py -l 4:100,1:0
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu

Process 1
  io
  io_done

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will run LATER (when it is its turn)
```

==My Answer==

参数中第一个进程有4条IO100%的指令，第二条有1个不占用CPU的指令默认5个时间单位，进程调度需要1个时间单位

因此完成时间为：

4（进程1的CPU时间）+1（进程调度）+5（IO）+1（进程调度） = 11

==Answer==

CPU使用了6单位的时间，IO使用了5单位的时间

```sh
$ python3 process-run.py -l 4:100,1:0 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1        RUN:cpu         READY             1
  2        RUN:cpu         READY             1
  3        RUN:cpu         READY             1
  4        RUN:cpu         READY             1
  5           DONE        RUN:io             1
  6           DONE       BLOCKED                           1
  7           DONE       BLOCKED                           1
  8           DONE       BLOCKED                           1
  9           DONE       BLOCKED                           1
 10           DONE       BLOCKED                           1
 11*          DONE   RUN:io_done             1

Stats: Total Time 11
Stats: CPU Busy 6 (54.55%)
Stats: IO Busy  5 (45.45%)
```

解释：

- 1-4 直接执行进程1
- 5 进程调度
- 6-10 IO
- 11 将阻塞的进程2进程调度回CPU继续执行

==Q&A==

【存疑】**为什么指令中进程2明明是一条指令，但是Process 1显示了两项**

- 操作系统中，当IO操作完成时，CPU会进行上下文切换，即从阻塞状态切换到调用该进程的等待队列中等待调度。这是因为当一个进程的最后一条指令需要IO操作时，该进程会被挂起，等待IO操作完成后才能继续执行。在此期间，操作系统会调度其他进程来使用CPU资源。而当IO操作完成后，进程的状态会被更新为就绪状态，等待CPU调度执行，所以会进行上下文切换。
- 因此在IO结束后仍然会使用一个时间单位的CPU

**如果现在CPU处于空闲状态，进程调度方式为先来先服务，这时候来了一批进程，CPU是否会直接调用第一个进程，而不是再花费时间进行进程调度。**

- 如果CPU处于空闲状态，且有进程就绪，进程调度器会立即调用队列中的第一个进程，而不是再花费时间进行进程调度。这是因为先来先服务是一种非抢占式调度算法，它不会在进程运行时强制切换进程，只有在当前进程阻塞或完成后，才会调度下一个就绪进程。因此，如果CPU处于空闲状态，就算进程调度器正在进行调度，也会立即调用队列中的第一个进程来运行。

【存疑】**调度程序需要使用CPU吗**

- 调度程序本身也需要使用CPU资源，因为要进行进程调度和管理相关的数据结构。调度程序在运行时会占用CPU，但是它的执行时间通常很短，只是在选择下一个要执行的进程之后，将CPU控制权交给被选中的进程，即进程切换（Context Switch）的过程中才会执行。此外，调度程序的执行优先级比其他进程低，只有在必要时才会被执行。在多道程序环境下，操作系统通过合理的调度算法和优化，将CPU资源尽可能地分配给用户进程，以最大限度地提高系统的资源利用率和性能。
- 因此可以认为：操作系统在运行两个进程的时候，使用CPU的程序分别为进程1，CPU调度器，进程2。

3．现在交换进程的顺序：./process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c看看你的答案是否正确。

```sh
$ python3 process-run.py -l 1:0,4:100
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
```

==My Answer==

~~1（进程1申请IO）+5（IO）+4（io_done的同时执行进程2） = 10~~

~~CPU和IO时间各一半。~~

==Answer==

```sh
$ python3 process-run.py -l 1:0,4:100 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1

Stats: Total Time 7
Stats: CPU Busy 6 (85.71%)
Stats: IO Busy  5 (71.43%)
```

进程1因为IO阻塞的时候进程2可以直接使用CPU资源。

并且，有IO的进程，在IO之前和IO之后都要使用CPU，**个人理解是**，在之前。OS并不知道这个使用IO的进程是不是要使用IO，因此将其调度到CPU中，当申请IO的时候再将CPU让给其他进程；IO结束之后，OS也不知道进程有没有执行结束，因此会将其调度到CPU中继续执行。

4．现在探索另一些标志。一个重要的标志是-S，它决定了当进程发出I/O时系统如何反应。将标志设置为SWITCH_ON_END，在进程进行I/O操作时，系统将不会切换到另一个进程，而是等待进程完成。当你运行以下两个进程时，会发生什么情况？一个执行I/O，另一个执行CPU工作。（-l 1:0,4:100 -c -S SWITCH_ON_END）

```sh
$ python3 process-run.py -l 1:0,4:100 -S SWITCH_ON_END
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
```

==My Answer==

总时间 = 1（申请IO） + 5（IO） + 1（IO结束） + 4（进程2运行） = 11

==Answer==

```sh
$ python3 process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_END
Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1
  2        BLOCKED         READY                           1
  3        BLOCKED         READY                           1
  4        BLOCKED         READY                           1
  5        BLOCKED         READY                           1
  6        BLOCKED         READY                           1
  7*   RUN:io_done         READY             1
  8           DONE       RUN:cpu             1
  9           DONE       RUN:cpu             1
 10           DONE       RUN:cpu             1
 11           DONE       RUN:cpu             1

Stats: Total Time 11
Stats: CPU Busy 6 (54.55%)
Stats: IO Busy  5 (45.45%)
```


5．现在，运行相同的进程，但切换行为设置，在等待I/O时切换到另一个进程（-l 1:0,4:100 -c -S SWITCH_ON_IO）。现在会发生什么？利用-c来确认你的答案是否正确。


==My Answer==

==Answer==





6．另一个重要的行为是I/O完成时要做什么。利用-I IO_RUN_LATER，当I/O完成时，发出它的进程不一定马上运行。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否被有效利用？



==My Answer==

==Answer==


7．现在运行相同的进程，但使用-I IO_RUN_IMMEDIATE设置，该设置立即运行发出I/O的进程。这种行为有何不同？为什么运行一个刚刚完成I/O的进程会是一个好主意？



==My Answer==

==Answer==



8．现在运行一些随机生成的进程，例如-s 1 -l 3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50。看看你是否能预测追踪记录会如何变化？当你使用-I IO_RUN_IMMEDIATE与-I IO_RUN_LATER时会发生什么？当你使用-S SWITCH_ON_IO与-S SWITCH_ON_END时会发生什么？


==My Answer==

==Answer==

## process-run.py Options

![[assets/Pasted image 20230511093956.png]]

![[assets/Pasted image 20230511094016.png]]

## 题目

### CPU程序

1．用以下标志运行程序：`./process-run.py -l 5:100,5:100`。CPU利用率（CPU使用时间的百分比）应该是多少？为什么你知道这一点？利用 -c标记查看你的答案是否正确。

```sh
$ python3 process-run.py -l 5:100,5:100
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu
  cpu

Process 1
  cpu
  cpu
  cpu
  cpu
  cpu

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will run LATER (when it is its turn)
```

==My Answer==

两个进程都利用5个时间单位的CPU，利用率都是100%

因此总利用率为100%

==Answer==

```sh
$ python3 process-run.py -l 5:100,5:100 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1        RUN:cpu         READY             1
  2        RUN:cpu         READY             1
  3        RUN:cpu         READY             1
  4        RUN:cpu         READY             1
  5        RUN:cpu         READY             1
  6           DONE       RUN:cpu             1
  7           DONE       RUN:cpu             1
  8           DONE       RUN:cpu             1
  9           DONE       RUN:cpu             1
 10           DONE       RUN:cpu             1

Stats: Total Time 10
Stats: CPU Busy 10 (100.00%)
Stats: IO Busy  0 (0.00%)
```

### CPU和IO

2．现在用这些标志运行：./process-run.py -l 4:100,1:0。这些标志指定了一个包含4条指令的进程（都要使用CPU），并且只是简单地发出I/O并等待它完成。完成这两个进程需要多长时间？利用-c检查你的答案是否正确。

```sh
$ python3 process-run.py -l 4:100,1:0
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu

Process 1
  io
  io_done

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will run LATER (when it is its turn)
```

==My Answer==

参数中第一个进程有4条IO100%的指令，第二条有1个不占用CPU的指令默认5个时间单位，进程调度需要1个时间单位

因此完成时间为：

4（进程1的CPU时间）+1（进程调度）+5（IO）+1（进程调度） = 11

==Answer==

CPU使用了6单位的时间，IO使用了5单位的时间

```sh
$ python3 process-run.py -l 4:100,1:0 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1        RUN:cpu         READY             1
  2        RUN:cpu         READY             1
  3        RUN:cpu         READY             1
  4        RUN:cpu         READY             1
  5           DONE        RUN:io             1
  6           DONE       BLOCKED                           1
  7           DONE       BLOCKED                           1
  8           DONE       BLOCKED                           1
  9           DONE       BLOCKED                           1
 10           DONE       BLOCKED                           1
 11*          DONE   RUN:io_done             1

Stats: Total Time 11
Stats: CPU Busy 6 (54.55%)
Stats: IO Busy  5 (45.45%)
```

解释：

- 1-4 直接执行进程1
- 5 进程调度
- 6-10 IO
- 11 将阻塞的进程2进程调度回CPU继续执行

==Q&A==

【存疑】**为什么指令中进程2明明是一条指令，但是Process 1显示了两项**

- 操作系统中，当IO操作完成时，CPU会进行上下文切换，即从阻塞状态切换到调用该进程的等待队列中等待调度。这是因为当一个进程的最后一条指令需要IO操作时，该进程会被挂起，等待IO操作完成后才能继续执行。在此期间，操作系统会调度其他进程来使用CPU资源。而当IO操作完成后，进程的状态会被更新为就绪状态，等待CPU调度执行，所以会进行上下文切换。
- 因此在IO结束后仍然会使用一个时间单位的CPU

**如果现在CPU处于空闲状态，进程调度方式为先来先服务，这时候来了一批进程，CPU是否会直接调用第一个进程，而不是再花费时间进行进程调度。**

- 如果CPU处于空闲状态，且有进程就绪，进程调度器会立即调用队列中的第一个进程，而不是再花费时间进行进程调度。这是因为先来先服务是一种非抢占式调度算法，它不会在进程运行时强制切换进程，只有在当前进程阻塞或完成后，才会调度下一个就绪进程。因此，如果CPU处于空闲状态，就算进程调度器正在进行调度，也会立即调用队列中的第一个进程来运行。

【存疑】**调度程序需要使用CPU吗**

- 调度程序本身也需要使用CPU资源，因为要进行进程调度和管理相关的数据结构。调度程序在运行时会占用CPU，但是它的执行时间通常很短，只是在选择下一个要执行的进程之后，将CPU控制权交给被选中的进程，即进程切换（Context Switch）的过程中才会执行。此外，调度程序的执行优先级比其他进程低，只有在必要时才会被执行。在多道程序环境下，操作系统通过合理的调度算法和优化，将CPU资源尽可能地分配给用户进程，以最大限度地提高系统的资源利用率和性能。
- 因此可以认为：操作系统在运行两个进程的时候，使用CPU的程序分别为进程1，CPU调度器，进程2。

### 交换CPU和IO顺序

3．现在交换进程的顺序：./process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c看看你的答案是否正确。

```sh
$ python3 process-run.py -l 1:0,4:100
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
```

==My Answer==

~~1（进程1申请IO）+5（IO）+4（io_done的同时执行进程2） = 10~~

~~CPU和IO时间各一半。~~

==Answer==

```sh
$ python3 process-run.py -l 1:0,4:100 -c -p
Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1

Stats: Total Time 7
Stats: CPU Busy 6 (85.71%)
Stats: IO Busy  5 (71.43%)
```

进程1因为IO阻塞的时候进程2可以直接使用CPU资源。

并且，有IO的进程，在IO之前和IO之后都要使用CPU，**个人理解是**，在之前。OS并不知道这个使用IO的进程是不是要使用IO，因此将其调度到CPU中，当申请IO的时候再将CPU让给其他进程；IO结束之后，OS也不知道进程有没有执行结束，因此会将其调度到CPU中继续执行。

### IO时进程不切换

4．现在探索另一些标志。一个重要的标志是-S，它决定了当进程发出I/O时系统如何反应。将标志设置为SWITCH_ON_END，在进程进行I/O操作时，系统将不会切换到另一个进程，而是等待进程完成。当你运行以下两个进程时，会发生什么情况？一个执行I/O，另一个执行CPU工作。（-l 1:0,4:100 -c -S SWITCH_ON_END）

```sh
$ python3 process-run.py -l 1:0,4:100 -S SWITCH_ON_END
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
```

==My Answer==

总时间 = 1（申请IO） + 5（IO） + 1（IO结束） + 4（进程2运行） = 11

==Answer==

```sh
$ python3 process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_END
Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1
  2        BLOCKED         READY                           1
  3        BLOCKED         READY                           1
  4        BLOCKED         READY                           1
  5        BLOCKED         READY                           1
  6        BLOCKED         READY                           1
  7*   RUN:io_done         READY             1
  8           DONE       RUN:cpu             1
  9           DONE       RUN:cpu             1
 10           DONE       RUN:cpu             1
 11           DONE       RUN:cpu             1

Stats: Total Time 11
Stats: CPU Busy 6 (54.55%)
Stats: IO Busy  5 (45.45%)
```

### IO时切换进程

5．现在，运行相同的进程，但切换行为设置，在等待I/O时切换到另一个进程（-l 1:0,4:100 -c -S SWITCH_ON_IO）。现在会发生什么？利用-c来确认你的答案是否正确。

```sh
$ python3 process-run.py -l 1:0,4:100 -S SWITCH_ON_IO
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
```

==My Answer==

等待时就绪。

CPU时间是调度+进程2，共1+4+1 = 6

IO时间就是默认的5个单位

==Answer==

```sh
$ python3 process-run.py -l 1:0,4:100 -c -p -S SWITCH_ON_IO
Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1

Stats: Total Time 7
Stats: CPU Busy 6 (85.71%)
Stats: IO Busy  5 (71.43%)
```

### IO程序随后运行

6．另一个重要的行为是I/O完成时要做什么。利用-I IO_RUN_LATER，当I/O完成时，发出它的进程不一定马上运行。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否被有效利用？

```sh
$ python3 process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -p

Produce a trace of what would happen when you run these processes:
Process 0
  io
  io_done
  io
  io_done
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu
  cpu

Process 2
  cpu
  cpu
  cpu
  cpu
  cpu

Process 3
  cpu
  cpu
  cpu
  cpu
  cpu
```

==Answer==

```sh
$ python3 process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -p -c
Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs
  1         RUN:io         READY         READY         READY             1
  2        BLOCKED       RUN:cpu         READY         READY             1             1
  3        BLOCKED       RUN:cpu         READY         READY             1             1
  4        BLOCKED       RUN:cpu         READY         READY             1             1
  5        BLOCKED       RUN:cpu         READY         READY             1             1
  6        BLOCKED       RUN:cpu         READY         READY             1             1
  7*         READY          DONE       RUN:cpu         READY             1
  8          READY          DONE       RUN:cpu         READY             1
  9          READY          DONE       RUN:cpu         READY             1
 10          READY          DONE       RUN:cpu         READY             1
 11          READY          DONE       RUN:cpu         READY             1
 12          READY          DONE          DONE       RUN:cpu             1
 13          READY          DONE          DONE       RUN:cpu             1
 14          READY          DONE          DONE       RUN:cpu             1
 15          READY          DONE          DONE       RUN:cpu             1
 16          READY          DONE          DONE       RUN:cpu             1
 17    RUN:io_done          DONE          DONE          DONE             1
 18         RUN:io          DONE          DONE          DONE             1
 19        BLOCKED          DONE          DONE          DONE                           1
 20        BLOCKED          DONE          DONE          DONE                           1
 21        BLOCKED          DONE          DONE          DONE                           1
 22        BLOCKED          DONE          DONE          DONE                           1
 23        BLOCKED          DONE          DONE          DONE                           1
 24*   RUN:io_done          DONE          DONE          DONE             1
 25         RUN:io          DONE          DONE          DONE             1
 26        BLOCKED          DONE          DONE          DONE                           1
 27        BLOCKED          DONE          DONE          DONE                           1
 28        BLOCKED          DONE          DONE          DONE                           1
 29        BLOCKED          DONE          DONE          DONE                           1
 30        BLOCKED          DONE          DONE          DONE                           1
 31*   RUN:io_done          DONE          DONE          DONE             1

Stats: Total Time 31
Stats: CPU Busy 21 (67.74%)
Stats: IO Busy  15 (48.39%)
```

在进程开始的时候，进程1申请IO，此时234都处于就绪状态。随后进程1的IO操作和进程2的CPU一起执行，当5个时间单位过去之后，进程1仍然处于阻塞态，但是进程34处于就绪态，因此先执行进程3，进程4同理。

等到进程4执行完成之后，进程1得到CPU得以从阻塞态转换成就绪态，此时CPU变成进程1独享。

### IO程序立即运行

7．现在运行相同的进程，但使用-I IO_RUN_IMMEDIATE设置，该设置立即运行发出I/O的进程。这种行为有何不同？为什么运行一个刚刚完成I/O的进程会是一个好主意？

==My Answer==

提高了程序执行效率，缩短了平均周转时间，让IO密集型程序能够和CPU密集型程序并发执行。

==Answer==

```sh
[ostep/cpu-intro] No Coding, No Life (ง •_•)ง
$ python3 process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -p -c
Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs
  1         RUN:io         READY         READY         READY             1
  2        BLOCKED       RUN:cpu         READY         READY             1             1
  3        BLOCKED       RUN:cpu         READY         READY             1             1
  4        BLOCKED       RUN:cpu         READY         READY             1             1
  5        BLOCKED       RUN:cpu         READY         READY             1             1
  6        BLOCKED       RUN:cpu         READY         READY             1             1
  7*   RUN:io_done          DONE         READY         READY             1
  8         RUN:io          DONE         READY         READY             1
  9        BLOCKED          DONE       RUN:cpu         READY             1             1
 10        BLOCKED          DONE       RUN:cpu         READY             1             1
 11        BLOCKED          DONE       RUN:cpu         READY             1             1
 12        BLOCKED          DONE       RUN:cpu         READY             1             1
 13        BLOCKED          DONE       RUN:cpu         READY             1             1
 14*   RUN:io_done          DONE          DONE         READY             1
 15         RUN:io          DONE          DONE         READY             1
 16        BLOCKED          DONE          DONE       RUN:cpu             1             1
 17        BLOCKED          DONE          DONE       RUN:cpu             1             1
 18        BLOCKED          DONE          DONE       RUN:cpu             1             1
 19        BLOCKED          DONE          DONE       RUN:cpu             1             1
 20        BLOCKED          DONE          DONE       RUN:cpu             1             1
 21*   RUN:io_done          DONE          DONE          DONE             1

Stats: Total Time 21
Stats: CPU Busy 21 (100.00%)
Stats: IO Busy  15 (71.43%)
```

### 复杂进程

8．现在运行一些随机生成的进程，例如`-s 1 -l 3:50,3:50`, `-s 2 -l 3:50,3:50`, `-s 3 -l 3:50,3:50`。看看你是否能预测追踪记录会如何变化？当你使用-I IO_RUN_IMMEDIATE与-I IO_RUN_LATER时会发生什么？当你使用-S SWITCH_ON_IO与-S SWITCH_ON_END时会发生什么？

分析：两种命令分别对应了IO之前和之后的两种状态：
- -I 表示 **申请IO**的时候，是在等待IO的时候切换到另一个进程运行，还是等到IO结束后再切换到另一个进程运行。
- -S 表示 在**IO结束**的时候，是立即调度刚刚完成IO的程序运行还是等待正在使用CPU的程序完成之后再调度IO程序的运行。

通过以上几道题的对比，我们发现，等待IO的时候切换到另一个进程运行，并且在进行IO 的程序的IO结束时立即调度刚刚完成的进程运行，是综合效率比较高的。

进程1 `-s 1 -l 3:50,3:50`

无论是改变运行IO程序的顺序，还是改变是否立即运行IO程序，对进程的运行顺序都没有影响

进程1：cpu,io,io
进程2：cpu,cpu,cpu

```sh
  1        RUN:cpu         READY             1
  2         RUN:io         READY             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7        BLOCKED          DONE                           1
  8*   RUN:io_done          DONE             1
  9         RUN:io          DONE             1
 10        BLOCKED          DONE                           1
 11        BLOCKED          DONE                           1
 12        BLOCKED          DONE                           1
 13        BLOCKED          DONE                           1
 14        BLOCKED          DONE                           1
 15*   RUN:io_done          DONE             1
```


进程2 `-s 2 -l 3:50,3:50`

| 条件                | 时间 |
| ------------------- | ---- |
| IO时切换进程        | 16   |
| IO时等待IO完成      | 30   |
| IO结束后返回原程序  |   16   |
| IO结束后等待CPU完成 | 16     |


进程3 `-s 3 -l 3:50,3:50`

| 条件                | 时间 |
| ------------------- | ---- |
| IO时切换进程        | 18   |
| IO时等待IO完成      | 24   |
| IO结束后返回原程序  |   17   |
| IO结束后等待CPU完成 | 18     |

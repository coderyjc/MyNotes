
## 源文本文件解析

[[../../4.归档/生活/QQ使用技巧/QQ消息记录导出|如何导出消息记录可以看这里]]

```text
消息记录（此消息记录为文本格式，不支持重新导入）

================================================================
消息分组:XXX
================================================================
消息对象:XXX
================================================================

```

消息记录中前8行是元信息，标注了好友所在的分组和消息对象（注意，这里的对象显示的是备注名称）

QQ消息记录的格式为：

```text
[yyyy-MM-dd HH:mm:ss] [备注]
[消息内容]
[空行]
```

其中备注名为在当前那个时间段此人的备注信息，并且自己的名字也是

比如：

```
2022-01-01 14:59:09 昵称1-1
测试

2022-01-01 14:59:09 昵称2-1
测试

2022-02-12 14:59:11 昵称2-2
测试

2022-02-12 14:59:11 昵称1-2
测试

```

自己改了名字，并且对方改了名字，消息记录中的名称就全都不一样了

注意：
- 消息记录中的消息并不是压缩成一行的，换行符也会体现在消息记录中。

## 文本预处理

### 去除前8行的元信息

可以手动删除，也可以直接使用Python readlines然后写入`lines[8:]`

得到文件`backup01.txt`

### 分离时间戳和消息文本

使用正则表达式校验文本的一行是否是时间戳，然后进行分离，并分别写入两个文件

相关正则表达式可以看这里[[../../4.归档/工作/工程/正则表达式/【正则表达式】校验时间和日期格式 | 校验时间和日期格式]]

这一步得到的是所有的时间戳，按照行排列；所有的消息内容，去掉换行符变成一行

所有的消息序列

![[assets/Pasted image 20230125220302.png]]

所有的消息内容，变成一行

![[assets/Pasted image 20230125220600.png]]


关键代码：

```python
  with open('./asssets/text/backup01.txt', 'r', encoding='utf-8') as f:
    for line in f:
      if re.search(REGEX_IS_DATETIME, line) is None and line != '\n':
        backup02_text += line
      if re.search(REGEX_IS_DATETIME, line) is not None:
        timeline01 += line[0:line.find(' ', 18)] + '\n'

  fw = open('./asssets/text/backup02.txt', 'w', encoding='utf-8')
  fw.write(backup02_text.replace('\n', ''))
  fw = open('./asssets/text/timeline01.txt', 'w', encoding='utf-8')
  fw.write(timeline01)
```

得到文件`backup02.txt`和`timeline.txt`

### 去除各种符号和数字，只保留汉字

去除所有的表情，图片，英文和空格

```python
  file = open('./asssets/text/backup03.txt', 'r', encoding='utf-8').read()

  # 去除符号
  r = r'[，？。\%、；1234567890.n-】【“”《》,（）！()]'
  file =re.sub(r, '', file)
  # 去除表情
  r = r'\[图片\]'
  file =re.sub(r, '', file)
  # 去除图片
  r = r'\[表情\]'
  file =re.sub(r, '', file)
  # 去除字母
  r = r'[a-zA-Z]'
  file =re.sub(r, '', file)
  # 去除空格
  r = r' '
  file =re.sub(r, '', file)

  fw = open('./asssets/text/backup04.txt', 'w', encoding='utf-8')
  fw.write(file)
```

便于使用分词库进行分词

得到文件`backup03.txt`

## 词频分析

### 分词

安装jieba库中遇见了包安装时候的环境问题 [[../../4.归档/工作/工程/环境问题总结/Python第三方库安装相关 | Python环境配置]]

相关的使用教程在[[../../4.归档/工作/基础/bigdata/python/python-libs/jieba/python-jieba|Python-jieba库]]

分词后要去掉单个字的元组，只保留有多个字的元组

分词关键代码：

```python
  # 使用用户自定义停用词表
  jieba.load_userdict("./asssets/text/dict.txt")
  # 分词
  words_cut = jieba.cut(file)
    # 词频统计
  wordcount = Counter(words_cut)
  words_dict = {}
  # 去掉单个字的元组，保留多个字的元组
  for k,v in dict(wordcount).items():
    if len(k) > 1:
      words_dict[k] = v
  wordcount = Counter(words_dict)
  # top50的词语
  data['most_common_words'] = wordcount.most_common(most_common_words)
```

### 分析

时间序列文件的行数即为发消息的总数 `timeline.txt`

```python
len(open('./asssets/text/timeline.txt', 'r', encoding='utf-8').readlines())
```

分离出来的文本的长度即为总字数（带有标点）`backup02.txt`

```python
len(open('./asssets/text/backup03.txt', 'r', encoding='utf-8').readlines()[0])
```

特定词的个数在`backup03.txt`中用正则表达式匹配即可

```python
len(re.findall(REGEX_IS_WORD_1, content_backup03))
```

## 时间分析

每一项时间序列为 `2022-01-01 14:44:48`

使用`split`可以将每一项都分离开，使用数组下标引用可以分离出所有的年月日，时分秒。

得到一年中每天的记录条数，一年中每一个月的记录数量，每个小时的数量

使用[[../../4.归档/工作/基础/bigdata/python/python-libs/collections/【Python库】collections.Conter|Python的Counter类]]可以方便的进行计数

对于一天中24小时的数据，计数之后将三小时分为一组进行汇总

```python
  # 每3小时为一组，分组汇总聊天记录条数
  message_time_grouped = {"0":0, "1":0, "2":0, "3":0, "4":0, "5":0, "6": 0, "7":0}
  for key, value in dict(counter_time).items():
    message_time_grouped[str(math.floor(int(key) / 3))] += value
  data['message_time_grouped'] = [{"value": value, "name":key} for key, value in message_time_grouped.items()]

```

其中0代表0点到3点，1代表3点到6点，以此类推

注意，这里如果有一天的消息没有，就要置为0, 以下是主要代码

```python
  # 如果某天没有数据，那么要用0占位
  dict_counter_date_day = dict(counter_date_day)
  month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30 ,31]
  for i in range(1, 13):
    for j in range(1, month_days[i - 1] + 1):
      date = '2022-0' + str(i) if i < 10 else '2022-' + str(i)
      date += '-0' + str(j) if j < 10 else '-' + str(j)
      if date not in dict_counter_date_day:
        dict_counter_date_day[date] = 0
  counter_date_day = Counter(sorted(dict_counter_date_day.items(), key = lambda v:v[0]))
```




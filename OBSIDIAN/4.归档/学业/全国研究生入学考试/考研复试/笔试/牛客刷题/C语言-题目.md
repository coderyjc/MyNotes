**参加位运算的数据可以是任何类型的数据。请问这句话的说法是正确的吗？**

> 错误。位运算的操作对象通常是整数类型的数据。对于其他数据类型（如浮点数、字符串等）通常是没有定义或没有实际意义的。


**在 C/C++ 中，若有定义 char a [10], *p=a; ，那么下列赋值语句正确的是( )。**  

A a [] ="abcdefg";

B a="abedefg";

C *p="abcdefg";

D p="abcdefg "

> **双引号做了3件事：**
>  1.申请了空间(在常量区)，存放了字符串
>   2. 在字符串尾加上了'/0'
>   3.返回地址，这里就是返回的地址赋给了p
> **将字符串赋给数组的方法：**
> 1.定义时直接用字符串赋值。 char a[10]＝"hello";但是不能先定义再赋值，即以下非法：char a[10];a[10]＝"hello"; 
> 2.利用strcpy。 char a[10]; strcpy(a,"hello"); 
> 3.利用指针。 char *p; p＝"hello";  

**'\1011'合法吗？**

> 不合法。斜杠后面的数字不能多于3位

**以下叙述中正确的是（）**

A 字符串常量"str1"的类型是:字符串数据类型
B 有定义语句： char str1[] = "str1"; ，数组str1将包含4个元素
C 下面的语句用赋初值方式来定义字符串，其中,'\0'是必须的 char str1[] = {'s', 't', 'r', '1', '\0'};
D 字符数组的每个元素可存放一个字符，并且最后一个元素必须是'\0'字符

> A，字符串常量"str1"实际上是一个字符数组，而不是直接的字符串数据类型。在C中，字符串通常被表示为以空字符('\0')结尾的字符数组。
> B，这种赋值方式默认添加末尾的'\0'因此有5个元素
> C，对
> D，如果使用这种方式 char a[] = {'a', 'b','v'}; 则最后一个元素不必须是'\0'字符
> 因此，B和D是两种赋值方式，B中会默认加上空字符表示字符串结束，而D中手动赋值可以不用加，但是如果你要将这个数组当作字符串使用，最好添加一个空字符

在C语言中，以下代码执行之后，*p的值为（）
```c
void func(int *p){
    static int num = 4;
    p = &num;
    (*p)--;
}
int main(){
    int i = 5;
    int *p = &i;
    func(p);
    printf("%d", *p);
    return 0;
}
```

> 在给定的代码中，函数`func`接收一个指向整数的指针，并将其指向一个静态变量`num`，然后将该变量递减1。但需要注意的是，由于参数`p`是按值传递的，对`p`的修改不会影响到`main`函数中指针`p`的值。
> 因此，在执行完`func(p)`之后，`main`函数中的指针`p`仍然指向变量`i`，并且`i`的值并没有发生变化。因此，`printf`语句输出的是`i`的值，即5。

**void f(void)是正确的C语言函数定义吗**

> 不是。是一个正确的函数声明，而不是定义。

**执行 t = 3;x = y = 2;t = x++ || ++y; 后，t和y的值分别是**

> 1,2。短路运算。在C语言中，短路运算是逻辑运算符（`&&`和`||`）的一种特性。短路运算表示在求值布尔表达式时，如果确定整个表达式的值已经能够确定，就不再继续对剩余部分进行求值。这种特性可以提高程序的效率并防止不必要的计算。

**以下选项中，合法的赋值语句是（）**

A a>1;
B i++;
C a= a+1=5;
D y = int(i);

> B是合法的，D是非法的，C语言中强制转换应该是 (int)i

**求sizeof(s)**

struct s
{
    int x: 3;
    int y: 4;
    int z: 5;
    double a;
}

> 一共16B。位域，x 3bit，y 4bit，z5bit共计3字节（不能跨字节存放），结构体按照最大的成员变量的对齐数对齐，也就是按照8B对齐，不满8B按照8B计算，因此是16B

位域介绍 https://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html

**以下代码的运行结果是**

```c
char a[3];
char b[] = "good";
a = b;
printf("%s", a);
```

> 编译出错。数组的首地址是指针常量而不是指针变量，无法相互赋值。
> 同理  ` float a[10], x;` 语句 a = &x; 是非法的，因为常量不能作为左值






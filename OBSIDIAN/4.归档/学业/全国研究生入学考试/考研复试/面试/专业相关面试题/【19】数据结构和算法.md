## 【19】数据结构和算法


> 红黑树的特点

红黑树是一种自平衡的二叉查找树，具有以下几个主要特点：

1. **平衡性**：红黑树是一种自平衡的二叉查找树，它通过在插入和删除操作时进行节点的颜色变换和旋转操作来保持树的平衡。这种平衡性能够保证红黑树的高度始终保持在对数级别，从而保证了查找、插入和删除操作的时间复杂度始终保持在 O(log n)。
2. **节点颜色**：每个节点都具有颜色，可以是红色或黑色。通过对节点的颜色进行限制和调整，红黑树能够保证树的平衡性。其中，约束条件包括：根节点必须为黑色、红色节点的子节点必须为黑色、从根节点到每个叶子节点的路径上的黑色节点数量必须相等等。
3. **插入和删除操作的调整**：当插入或删除节点时，红黑树会根据当前节点的颜色以及父节点、祖父节点、叔父节点等节点的颜色和位置关系进行相应的调整，以保持树的平衡性。这种调整包括颜色变换和旋转操作，能够在常数时间内完成，保证了红黑树的高效性。
4. **高效的查找、插入和删除操作**：由于红黑树的平衡性和节点颜色约束，其查找、插入和删除操作的时间复杂度都保持在 O(log n)。这使得红黑树成为一种高效的数据结构，适用于需要频繁进行查找、插入和删除操作的场景，如数据库索引、内存管理等。
5. **广泛应用**：红黑树作为一种自平衡的二叉查找树，被广泛应用于计算机领域的各个方面，包括操作系统、编译器、数据库系统等。其高效的查找、插入和删除操作使得它成为一种重要的数据结构，在各种应用场景中发挥着重要作用

> B 树概念

B-树（B-tree）是一种多路平衡查找树，广泛应用于数据库和文件系统中，其特点包括以下几个方面：

1. 树中每个结点至多有m棵子树，即至多含有m-1个关键字
2. 若根结点不是叶结点，则至少有两棵子树。
3. 除根结点外的所有非叶结点至少有「m/2]棵子树，即至少含有「m/2]-1个关键字。
4. 所有非叶结点的结构如下：（这里自己联想一下吧）
5. 所有的叶结点都出现在同一层次上，并且不带信息


> 关键路径

**定义**：在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始：网中也仅存在一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。在AOE网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为**关键路径**，而把关键路径上的活动称为关键活动。

> 算法的控制方法有哪几种？

1. **顺序结构**：顺序结构是最基本的控制方法，即按照代码的顺序依次执行每个语句，没有分支和循环结构。程序从头到尾按照顺序执行，每个语句都会被执行一次。
2. **选择结构**：选择结构根据条件选择不同的执行路径。常见的选择结构包括 if 语句、switch 语句等，根据条件的真假选择不同的分支执行。选择结构可以实现条件判断和分支跳转。
3. **循环结构**：循环结构允许程序重复执行一段代码，直到某个条件不再满足为止。常见的循环结构包括 while 循环、for 循环、do-while 循环等，通过控制循环条件来控制循环的执行次数。
4. **递归**：递归是一种自我调用的方法，通过在函数内部调用自身来解决问题。递归可以将复杂的问题分解成简单的子问题，从而简化问题的解决过程。递归需要有递归基准情况和递归调用条件，以确保递归能够终止

> 双向链表如何逆置

要逆置一个双向链表，可以按照以下步骤进行：

1. **交换头尾指针**：将链表的头指针和尾指针进行交换。原来的头指针变为尾指针，原来的尾指针变为头指针。
2. **遍历链表**：从新的头指针开始，沿着链表向后遍历每个节点。
3. **交换节点的前驱和后继指针**：对于每个节点，交换它的前驱指针和后继指针。这样就可以将链表逆置。
4. **更新头尾指针**：更新头指针和尾指针，使其指向新的头节点和尾节点。

通过以上步骤，就可以实现双向链表的逆置。整个过程可以在不创建新节点的情况下完成，只是通过调整节点的指针来改变链表的顺序。


> 折半查找的思想

折半查找（Binary Search），也称为二分查找，是一种在有序数组中查找特定元素的高效算法。它的基本思想是通过将待查找区间反复地对半划分，缩小搜索范围，直到找到目标元素或者确定目标元素不存在为止。

折半查找的基本思路如下：

1. **初始化**：首先确定查找区间的起始位置和结束位置，通常起始位置为数组的第一个元素下标，结束位置为数组的最后一个元素下标。
2. **确定中间位置**：计算查找区间的中间位置，取中间位置的元素进行比较。
3. **比较目标值**：将目标值与中间位置的元素进行比较。如果目标值等于中间位置的元素，则查找成功；如果目标值小于中间位置的元素，则在左半部分继续查找；如果目标值大于中间位置的元素，则在右半部分继续查找。
4. **更新查找区间**：根据比较结果更新查找区间，缩小查找范围。如果目标值小于中间位置的元素，则更新结束位置为中间位置减一；如果目标值大于中间位置的元素，则更新起始位置为中间位置加一。
5. **重复步骤**：重复步骤 2 到步骤 4，直到找到目标元素或者确定目标元素不存在为止。

折半查找的时间复杂度为 O(log n)，其中 n 表示数组的元素个数。由于每次查找都将查找范围

> 衡量数据结构算法优劣的方法有哪些？

1. **时间复杂度（Time Complexity）**： 时间复杂度是衡量算法效率的重要指标，表示算法执行所需的时间与问题规模之间的关系。一般来说，时间复杂度越低，算法执行效率越高。  
2. **空间复杂度（Space Complexity）**： 空间复杂度是衡量算法所需内存空间与问题规模之间的关系。类似于时间复杂度，空间复杂度也通常用大O符号来表示。较低的空间复杂度意味着算法所需的内存空间较少。
3. 除此之外，我认为还有可读性，稳定性等等。

> 什么叫算法，算法的特点

算法（Algorithm）是对特定问题**求解步骤**的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。

算法的特点如下：

1. 有穷性。一个算法必须总在执行**有穷步之后结束**，且每一步都可在**有穷时间**内完成。
2. 确定性。算法中每条指令必须有**确切的含义**，对于相同的输入只能得出相同的输出。
3. 可行性。算法中描述的操作都可以通过**已经实现的基本运算**执行有限次来实现。
4. 输入。一个算法有**零个或多个输入**，这些输入取自于某个特定的对象的集合。
5. 输出。一个算法有**一个或多个输出**，这些输出是与输入有着某种特定关系的量。

> 顺序表和线性表的比较？

线性表是一种抽象的数据结构，可以通过不同的方式来实现，包括顺序表、链表等。而顺序表是线性表的一种实现方式，因此我认为把这两个东西拿来比较不太合适。

顺序表：
1. **实现方式：** 顺序表通常使用数组来实现，数组的连续内存空间用于存储元素。
2. **特点：**
    - 元素在内存中连续存储，可以通过下标快速访问任意位置的元素。
    - 需要预先分配足够大的内存空间，如果空间不足，需要进行扩容操作。
    - 插入和删除元素的效率较低，需要移动大量元素。
    - 支持随机访问，时间复杂度为O(1)。
    - 适用于元素数量固定或者较少变化的场景。

线性表：
1. **实现方式：** 线性表是一种抽象的数据结构，可以通过不同的方式来实现，包括顺序表、链表等。
2. **特点：**
    - 不同实现方式的线性表有不同的特点和适用场景。
    - 线性表的元素之间存在明确的顺序关系，可以按照这个顺序进行访问和操作。
    - 可以动态调整内存空间，无需预先分配固定大小的内存空间。
    - 插入和删除元素的效率取决于具体的实现方式，链表实现的线性表可以在常数时间内进行插入和删除操作，但查找效率较低。

> 链表有几种结构？

1. **单向链表（Singly Linked List）**： 单向链表中，每个节点包含一个值和一个指向下一个节点的指针。链表的最后一个节点的指针通常指向空值（null），表示链表的末尾。
2. **双向链表（Doubly Linked List）**： 双向链表中，每个节点除了包含一个值之外，还包含指向前一个节点和后一个节点的两个指针。这样的设计使得双向链表可以双向遍历，可以从头节点向后遍历到尾节点，也可以从尾节点向前遍历到头节点。
3. **循环链表（Circular Linked List）**： 循环链表是一种特殊的链表结构，它的最后一个节点指向第一个节点，形成一个环状结构。循环链表可以是单向的或者双向的。
4. **静态链表（Static Linked List）**。静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next。需要预分配空间。

> 模式匹配是什么？

**模式匹配**：用于在一组数据中查找特定模式的过程。这种模式可以是一个字符串、一个数据结构、一组规则等。模式匹配通常用于搜索、替换、识别或验证数据。

举例：

1. **字符串模式匹配**： 在文本处理中，字符串模式匹配是指查找一个字符串（即模式）在另一个字符串（即文本）中出现的位置或匹配的过程。常见的字符串模式匹配算法包括暴力匹配、KMP 算法 算法等。
2. **数据结构模式匹配**： 在数据结构领域，模式匹配可以用于查找特定结构的数据，例如在树、图等数据结构中查找某个特定的子结构或路径。
3. **正则表达式**： 正则表达式是一种描述字符串模式的语言，可以用于在文本中进行模式匹配、替换和提取。正则表达式提供了一种强大而灵活的方式来描述字符串模式，常用于文本处理、数据验证等场景。
4. **模式识别**： 在人工智能和机器学习领域，模式匹配用于识别输入数据中的特定模式，例如图像识别、语音识别等。

> 平衡二叉树

**是什么**：左右子树的高度差的绝对值不超过1的二叉排序树成为平衡二叉树。

插入、删除。

> 介绍一下图的邻接矩阵

**定义**：邻接矩阵是一种用于表示图中顶点之间关系的矩阵。

**用法**：对于*有向图*来说，邻接矩阵是一个n×n的矩阵，其中n是图中顶点的数量。如果图中第i个顶点和第j个顶点之间存在边，则邻接矩阵中的第i行第j列的元素为1；如果不存在边，则为0。对于*无向图*来说，邻接矩阵是一个对称矩阵，即(i, j)和(j, i)位置的值相同。

**优点**：邻接矩阵的优点是容易理解和实现，但是对于稀疏图（边的数量远小于顶点的数量）来说会占用较大的存储空间。

> 什么是贪心算法？

**定义**：贪心算法（Greedy Algorithm）基本思想是把要求解的问题化为多个子问题，并在在每一个子问题中都采取当前状态下最优的选择，从而希望最终得到全局最优解。

**特点**：这种算法的特点是，每一步都选择当前状态下最优的解决方案，而不考虑之后的结果。这种选择保证了局部最优解，但并不一定能够得到全局最优解。也正是因为他只考虑当前状态的最优解，而不受之前状态的影响，使得这个算法更加简单和高效。

**应用**：贪心算法适用于一些特定类型的问题，如*最小生成树*问题、*最短路径*问题等。然而，贪心算法并不适用于所有问题，有些问题可能需要更复杂的*动态规划*或者*回溯*等算法来解决。

*扩展：什么是动态规划？*

动态规划算法是一种通过将大问题拆分为小问题，并记录小问题的解决方案，来避免重复计算的算法。它通常用于解决那些可以分解为重叠子问题的问题，并且具有最优子结构性质。动态规划算法的核心思想是通过记忆化或表格存储已解决的子问题的解，从而避免重复计算，提高问题的解决效率。

相关链接：[[../../../../../../5.专题研究/算法/算法专栏/动态规划算法|动态规划算法]]

*扩展：什么是回溯法？*




*扩展：介绍一下你知道的最小生成树算法（Prim、Kruskal）？*




相关链接：[[../../../../../../5.专题研究/算法/算法专栏/Kruskal算法|Kruskal算法]]、[[../../../../../../5.专题研究/算法/算法专栏/Prim算法|Prim算法]]

*扩展：介绍一下最短路径算法（单源最短路径Dijkstra、动态规划Floyd）？*



相关链接：[[../../../../../../5.专题研究/算法/算法专栏/Dijkstra算法|Dijkstra算法]]、[[../../../../../../5.专题研究/算法/算法专栏/Floyd算法|Floyd算法]]

> Floyd算法

求每对顶点间的最短路径。
1. 设置一个 n 阶方阵 A 记录每对顶点间的路径长度，其中`A[i][j] `表示从顶点 i 到顶点 j 的路径长度；
2. 初始时，若任意两个顶点之间存在边，则该边的权值设为它们的最短路径；若不存在有向边，则把值设为 ∞；
3. 之后在原路径中不断加入其他顶点作为中转点。若增加中转点后，得到的路径比原路径长度更短，则修改原路径。

> 迪杰斯特拉算法的基本思想

**用途**：用来求单源最短路径，即求图中某一顶点到其他顶点的最短路径。

**过程**：设置一个集合 S 记录已经求得的最短路径的顶点。初始时把源点放入 S 中，计算源点到其它顶点的最短路径长度，选择路径最短的顶点加入 S，再根据该顶点重新计算源点到其它顶点的最短路径长度，重复上述操作，直到所有顶点都加入 S。

打个比方，A 到 B 的距离是 10，A 到 C 的距离是 4，C 到 B 的距离是 3，则 A 到 B 的距离应该修改为 7。

> 拓扑排序的基本算法？

拓扑排序的步骤：
（1）在有向图中任意选择一个没有前驱的节点输出
（2）从图中删去该节点以及与它相连的边
（3）重复以上步骤，如果最后所有的顶点都输出，那就说明拓扑排序完成，如果当前图中不存在无前驱的顶点，说明是个有环图。

后者代表该图是有环图，所以可以通过拓扑排序来判断一个图是否存在环。

> 什么是稳定排序？什么是不稳定排序？

**定义**：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。

*扩展：稳定算法和不稳定排序，nlogn排序算法*：

稳定算法：
- **插**入**奇**数个**泡泡**，然后将他们**归并**起来；
- 插（插入）、奇（基数排序）、泡（冒泡排序）、归（归并排序）

不稳定算法：
- “考研压力大，心情**不稳定**，**快些选堆**朋友来聊天” 
- 快 ---- 快速排序；
- 些 ---- 希尔排序（谐音）；
- 选 ---- 选择排序；
- 堆 ---- 堆排序；**这些排序是不稳定的**

时间复杂度nlogn算法：
- 军训排队时，教官说：**快些**以 nlogn 的速度**归队**；
- 快（快速），些（希尔），归（归并），队（堆）


> 什么是归并排序？

**归并排序**（Merge Sort）是一种基于分治法的经典排序算法，它将待排序数组分成两个子数组，分别对子数组进行排序，然后将排好序的子数组合并成一个整体有序的数组。其基本思想是将数组递归地分成较小的子数组，直到子数组的大小为1，然后合并相邻的子数组并排序。


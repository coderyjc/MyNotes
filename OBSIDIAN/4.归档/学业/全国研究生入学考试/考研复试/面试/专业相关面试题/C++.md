## 【10】C++

> java 和 C++在处理内存上的区别？

1. **内存管理**：
    - C++：在 C++ 中，程序员需要显式地进行内存管理，包括手动分配内存（例如使用 `new` 操作符）和手动释放内存（例如使用 `delete` 操作符）。这种手动管理内存的方式使得程序员需要更多地关注内存分配和释放的细节，容易引入内存泄漏和内存错误。
    - Java：在 Java 中，内存管理是由 Java 虚拟机（JVM）自动进行的。Java 使用垃圾收集器（Garbage Collector）来自动检测和释放不再使用的内存对象。程序员不需要显式地管理内存，垃圾收集器会周期性地检查内存中的对象，并回收那些不再被引用的对象，从而减少了内存泄漏和内存错误的风险。
2. **指针和引用**：
    - C++：C++ 支持指针的使用，程序员可以直接操作内存地址和指针。指针的使用提供了更灵活的内存管理和数据结构操作，但也容易导致内存访问错误和悬挂指针。
    - Java：Java 没有直接的指针概念，而是使用引用（Reference）。Java 中的引用类似于 C++ 中的指针，但受到严格的限制，不允许直接操作内存地址，从而减少了内存错误的可能性。

> 面向对象的特征有哪些方面？

面向对象三大特征：继承、封装、多态。

1. **继承（Inheritance）：**
    - 继承是指一个类（子类）可以继承另一个类（父类）的属性和方法，从而扩展或修改父类的功能。通过继承，可以实现代码的复用和层次化结构，减少了重复编码，提高了代码的可扩展性和可维护性。
2. **封装（Encapsulation）：**
    - 封装是指将数据和操作封装在对象内部，隐藏对象的实现细节，只暴露必要的接口供外部访问。通过封装，可以实现数据的保护和隔离，提高了代码的安全性和可维护性。
3. **多态（Polymorphism）：**
    - 多态是指同一个操作可以作用于不同的对象，并根据对象的类型执行不同的行为。提高了代码的灵活性和可扩展性。


> 谈谈对面向对象中多态的理解？接口回调和对象的上转型哪个是对多态的运用？

多态性的核心概念是同一个接口可以有多种实现方式。

多态是面向对象编程的三大特性之一。它提高了代码的复用性扩展性，遵循了设计模式中的开放封闭原则，也就是对扩展开放，对修改关闭。

多态分为两类
- <u>静态多态</u>：函数重载和运算符重载属于静态多态，复用函数名。之所以叫静态多态，是因为在编译阶段就能确定调用的方法。
- <u>动态多态</u>：继承类和虚函数实现运行时多态。因为是在运行时确定调用的方法的。比如，如果一个类定义了虚函数，并且在其派生类中重新实现了该虚函数，那么在调用这个虚函数时，将根据对象的实际类型来决定调用哪个版本的函数。

虚函数更像是一个“规范”。

*扩展：如何遵循开闭原则的？*
1. **对扩展开放**：多态性允许在不修改现有代码的情况下向类中添加新的功能或行为。通过继承和接口实现等方式，可以在不改变现有代码的情况下创建新的类，并为这些类提供不同的行为。从而得到扩展。
2. **对修改关闭**：当需要添加新的行为时，只需要创建一个新的子类或实现一个新的接口，并在其中实现新的行为。这样，就不会影响到现有的类和代码，保持了现有代码的稳定性和可靠性。

> 面向对象的程序设计中，重载与重写的区别与联系？

1. **重载（Overloading）**：
    - 重载指的是在同一个作用域内，可以定义多个相同名称但参数列表不同（包括参数类型、个数、顺序等）的函数，以便根据传递给它们的参数类型或数量选择正确的方法。
    - 重载解析发生在编译时，编译器根据调用的参数列表选择适当的函数或方法，属于静态多态。
2. **重写（Overriding）**：
    - 重写指的是子类可以覆盖其父类中的虚函数，以提供自己的实现版本。重写的方法必须与父类中的虚函数具有相同的名称、参数列表和返回类型。
    - 重写用于实现运行时多态性，当基类指针或引用指向派生类对象，并调用虚函数时，会根据对象的实际类型选择正确的函数

目的都是提高代码的灵活性和可扩展性。

> 说出有 C++中有几种继承方式？

1. **公有继承（Public Inheritance）**：
- 使用 `public` 关键字声明的继承方式。基类的公有成员在派生类中仍然是公有的，保护成员在派生类中仍然是保护的，私有成员在派生类中不可访问。
- 公有继承表示基类的接口对派生类是可见的，派生类可以直接访问基类的公有成员。
2. **私有继承（Private Inheritance）**：
- 使用 `private` 关键字声明的继承方式。基类的所有成员在派生类中都变为私有的，派生类对基类的成员的访问权限受到限制。
- 私有继承表示基类的接口对外是不可见的，派生类对基类的接口的使用完全通过派生类本身来实现。
3. **保护继承（Protected Inheritance）**：
- 使用 `protected` 关键字声明的继承方式。基类的公有成员在派生类中变为保护的，保护成员在派生类中仍然是保护的，私有成员在派生类中不可访问。
- 保护继承表示基类的接口对外是不可见的，但对派生类是可见的。

> 指针与引用的区别和联系？

**区别：**
1. **定义和声明**：指针是一个变量，存储另一个变量的地址。定义指针时需要使用星号，引用是一个别名，它是已存在变量的别名。在定义引用时，不需要使用星号。
2. **初始化**：指针可以在声明时不进行初始化，也可以在稍后通过取地址操作或使用`nullptr`（C++11及以后版本）进行初始化。引用在声明时必须进行初始化，一旦初始化之后，不能再引用其他变量。
3. **空值（Null）**：指针可以指向空值，表示不指向任何有效的内存地址。引用不能指向空值，必须始终引用某个已存在的变量。
4. **访问的方式**：指针可以通过解引用操作符（`*`）来访问所指向的对象；引用则直接使用原始变量的名称来访问对象，无需解引用操作符。

**联系：**
1. **内存地址**：指针和引用都涉及到内存地址的概念，它们提供了对变量在内存中的位置进行操作的能力。
2. **传递参数**：指针和引用都可以用于传递参数，通过引用传递和指针传递，可以实现在函数中修改调用者提供的变量的值。
3. **用途**：
    - 指针通常用于动态内存分配、数组操作、函数指针等场景。
    - 引用通常用于函数参数传递、函数返回值、操作符重载等场景。

> 虚函数是什么？

虚函数（Virtual function）是面向对象编程中的一个重要概念，主要用于实现多态性（polymorphism）。

当一个函数被声明为虚函数时，它可以在派生类中被重写（override），并且在运行时根据实际对象的类型来调用相应的函数。这使得在程序中使用基类指针或引用来操作派生类对象时可以根据对象的实际类型来调用适当的函数。

> 什么是静态函数、静态变量？

1. 静态函数。静态函数是在函数声明前面加上关键字 `static` 定义的函数。只能在当前文件中使用，不能被其他文件访问，因此作用域被限制在当前源文件内。
2. 静态变量。静态变量是在变量声明前面加上关键字 `static` 定义的变量。作用域也是在当前文件中。静态变量在程序生命周期只被初始化一次，但是可以被修改。

> 函数覆盖和函数重载的概念，二者的区别？

**函数覆盖（Function Overriding）**：函数覆盖是指在派生类中重新定义（覆盖）基类中已有的同名函数。
**函数重载（Function Overloading）**：函数重载是指在同一个作用域内定义多个同名函数，它们具有不同的参数列表（类型或个数）。

区别：

1. 函数覆盖实现了运行时多态性，而函数重载实现了编译时多态性。函数覆盖实现了运行时的多态性，即通过基类的指针或引用调用被派生类覆盖的函数时，实际执行的是派生类中的版本。函数重载实现了编译时的多态性，编译器会根据参数列表的不同选择合适的函数进行调用。
2. 函数覆盖是在派生类中重新定义基类的函数，而函数重载是在同一作用域内定义多个具有相同函数名但不同参数列表的函数。

> 面向对象需要建立哪三个模型？

对象模型、动态模型和功能模型

- **对象模型**描述了系统中的静态结构，即系统中的对象、对象之间的关系以及对象的属性和方法。对象模型通常通过类图、对象图等形式来表示。
- **动态模型**描述了系统中的动态行为，即系统在运行时对象之间的交互和状态变化。动态模型通常通过时序图、活动图等形式来表示。
- **功能模型**描述了系统的功能特征，即系统提供的功能以及用户与系统之间的交互。功能模型通常通过用例图、功能分解图等形式来表示。


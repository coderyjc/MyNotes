#Java/基础知识

## Java开发环境

### Java语言的特性

#### 1.简单性（相对于C++）

在Java语言当中真正操作内存的是JVM（Java Virtual Machine）Java虚拟机

所有的java程序都是运行在Java虚拟机当中的, Java语言**屏蔽了指针概念**，程序员*不能直接操作指针*，或者说程序员不能直接操作内存。这种方式有优点也有缺点：

优点：不容易导致内存泄漏

缺点：效率问题(但是可以通过更换更强大的硬件来解决)

#### 2.完全面向对象

面向对象三大特性: 封装，继承，多态

面向对象更容易让人理解，人类通常是以对象的方式认知世界的。

#### 3.健壮性


Java中有一种机制：自动垃圾回收机制（GC机制 Garbage Collection）

Java 程序启动了一个单独的垃圾回收线程，时刻监测内存使用情况，在特定时机会回收/释放垃圾数据，这样会让内存时刻处于最好的状态, 关于这个机制, 我们会在Java进阶篇中讲解.

相对于C语言来说，java语言是健壮的, 因为Java不容易导致内存的泄漏, C++或者C语言需要程序员自己分配内存, 在使用不当时很容易导致内存泄漏。

> 内存泄漏: 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。(来自百度百科: [内存泄漏](https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/6181425))

**JVM**负责调度GC机制。程序员不需要干涉。

缺点：内存无法得到及时的清理, (但是我们可以手动调用清理机制)

#### 4.java完美支持多线程并发。

#### 5.可移植性/跨平台

java语言只要编写一次，可以做到到处运行。

例如：java程序编写完之后，可以运行在windows操作系统上，不需要做任何改动可以直接运行在Linux操作系统上，同样也可以运行到MaC OS上面。

一次编写，到处运行。（平台改变了，程序不需要改。）

JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？

- 优点：一次编写到处运行，可以**跨平台**。
- 缺点：麻烦。对于运行java程序来说必须先有一个JVM，也就是需要安装JRE。

### JDK、JRE、JVM的区别

- JDK（Java Development Kit）:Java开发工具箱

- JRE（Java Runtime Environment，Java 运行环境）:java运行环境

- JVM（Java Virtual Machine）:java虚拟机

- JDK包括JRE，JRE包括JVM。

JVM是不能独立安装的。JRE和JDK都可以独立安装。

安装JDK的时候，JRE就自动安装了，同时JRE内部的JVM也就自动安装了。安装JRE的时候，JVM也就自动安装了。

问题：假设你在软件公司开发了一个新的软件，现在要去客户那边给客户把项目部署一下，把项目跑起来，你需要安装JDK吗？

- 只是把项目跑起来的话，只需要安装JRE就行了。

问题：为什么安装JDK的时候会自带一个JRE？

- 因为开发完程序之后，要运行这个程序，让这个程序运行起来，需要JRE，所以JDK安装的时候内部自带一个JRE。

Java体系的技术被划分为三大块：

- JavaSE：标准版
- JavaEE：企业版
- JavaME：微型版

### 对Java的加载与执行的理解

java程序从编写到最终运行经历了哪些过程？

java程序非常重要的两个阶段：

- 编译阶段
- 运行阶段

注意：java程序员直接编写的java代码（普通文本）是无法执行被JVM识别的。java程序员编写的java代码这种普通文本必须经过一个编译，将这个“普通文本代码”变成“字节码”，JVM能够识别“字节码”。java代码这种普通文本变成字节码的过程，被称为：编译。（不同的操作系统上编译生成的字节码也是一样的）

java代码这种普通文本被称为：java源代码。（你编写的代码是源代码）源代码不能直接执行，需要先进行编译，生成源代码对应的“字节码”JVM可以识别的是字节码。

编译阶段和运行阶段可以在不同的操作系统上完成吗？

在windows上编译，编译之后生成了“字节码”，把“字节码”放到linux上运行**完全可以**，因为Java是跨平台的。可以做到一次编写到处运行。

java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？

**完全可以**执行，因为<u>源代码不参与程序的执行过程</u>。参与程序执行过程的是字节码。但是最好不要删除源代码。因为有可能执行结果不是你需要的，当执行结果不是你需要的时候，你可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。

- 放源代码的文件扩展名必须是：xxx.java
- 并且需要注意的是：编译生成的字节码文件扩展名是：xxx.class
- .java文件就是源文件，这个文件中编写源代码。
- .class文件就是字节码文件，这个文件是编译源代码而得到的。
- 1个java源文件是可以编译生成多个class文件的。
- 最终运行的是class文件。

问题：字节码文件是二进制文件吗？

字节码文件不是二进制文件。如果是二进制的话，就不需要JVM了。因为操作系统可以直接执行二进制。

java程序从开发到最终运行经历了什么？

- 编译期：（可以在windows上）
	- 第一步：在硬盘的某个位置（随意），新建一个xxx.java文件
	- 第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件
	- 第三步：在xxx.java文件中编写“符合java语法规则的”源代码。
	- 第四步：保存（一定要将xxx.java文件保存一下）
	- 第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。
	- 第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）
- 运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）
	- 第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）
	- 第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码
	- 第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）
	- 第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和
	硬件进行交互。

注意：在以上的过程中，需要使用两个非常重要的命令？

- javac 命令，负责编译
- java 命令，负责运行

xxx.java源文件经过编译之后生成了A.class、B.class、C.class等文件，那么我们称A是一个类、B是一个类、C是一个类。其中A、B、C是类的名字。

源文件中编写的代码叫做：源代码。

以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？

- 新建java文件
- 打开java文件
- 写java源代码
- 保存
- javac命令编译
- java命令运行

编写、编译、运行

### Hello World

第一步：安装文本编辑器

第二步：安装JDK（先下载JDK）安装JDK13，直接下一步就行。

JDK13安装的时候内置了一个JRE，独立于JDK之外的JRE并没有生成。对于java13来说，如果你希望生成一个独立于JDK之外的JRE的话需要执行特殊的命令。

注意：
JDK8安装的时候，不仅JDK内置了一个JRE，而且还会在JDK目录之外独立的生成一个单独的JRE。（以前低版本的时候，JRE实际上是有2个。）一个是JDK内置的，一个是独立于JDK之外的。

JDK的bin目录下有：

- javac.exe 负责编译
- java.exe 负责运行

第三步：写代码

第四步：编译

第五步：运行

#### 编译

怎么编译？使用什么命令？这个命令怎么用？

- 需要使用的命令是：C:\Program Files\Java\jdk-13.0.2\bin\javac.exe
- 这个命令需要先测试一下，打开DOS命令窗口，看看javac命令是否可用。

C:\Users\Administrator>javac

'javac' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这说明：windows操作系统没有发现“javac.exe”命令在哪里。windows操作系统没有找到javac.exe文件在哪。

为什么ipconfig、ping等命令可以使用呢？为什么javac用不了？

- 我们发现windows操作系统中有这样一个环境变量，名字叫做：`path`，并且发现`path`环境变量的值是：
  `C:\Windows\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\`我们还发现了在：C:\Windows\System32 这个目录下存在：ipconfig.exe

注意：修改完环境变量之后，DOS命令窗口必须关闭重新打开才会起作用。

将path环境变量中的:C:\windows\system32; 删除之后再测试：:\Users\Administrator>ipconfig
'ipconfig' 不是内部或外部命令，也不是可运行的程序或批处理文件。

配置环境变量path的步骤：

- 桌面计算机上右键-->属性-->高级系统设置-->环境变量

怎么修改path环境变量？

- 找到path，鼠标双击！path环境变量当中都是路径，路径和路径之间必须采用“半角的分号”分隔。

让javac.exe能用，我们配置哪个路径到path中？将C:\Program Files\Java\jdk-13.0.2\bin配置到path当中。

注意：

- 环境变量包括“系统变量”和“用户变量”
- 系统变量：范围比较大，系统变量会让计算机所有用户都起作用。
- 用户变量：范围比较小，这个变量只是作用于当前用户。

怎么查看编译器版本？

```bash
C:\Users\Administrator><u>javac -version</u>
javac 13.0.2
```

怎么查看java虚拟机的版本？

```bash
C:\Users\Administrator><u>java -version</u>
java version "13.0.2" 2020-01-14
Java(TM) SE Runtime Environment (build 13.0.2+8)
Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
```

**问题1**：path环境变量的作用是什么？

path环境变量的作用就是给windows操作系统指路的。<u>告诉windows操作系统去哪里找这个命令文件。</u>path环境变量中有很多很多的路径，路径和路径之间用半角分号分隔。

path=A;B;C;D......path是环境变量的名字。A;B;C;D......是环境变量path的值。

**问题2**：path环境变量是java中的机制，还是windows操作系统中的机制？path环境变量是隶属于java的吗？path环境变量和java有关系吗？

path环境变量本质上是隶属于windows操作系统的，和java没有关系。java只不过用了一下path环境变量。

#### 运行

运行的前提是：class文件（字节码）生成了。没有字节码文件程序是无法运行的。

假设该文件的名字叫做：HelloWorld.class

那么HelloWorld被称为类名；如果文件名是Test.class，那么Test就是一个类名。

怎么运行，使用哪个命令？使用JDK的bin目录下的：java.exe命令来运行。

先在DOS命令窗口中测试java.exe这个命令是否可用！java -version

"java.exe"这个命令怎么用，语法格式是什么？java 类名

java HelloWorld.class 对不对？不对！正确的写法是：java HelloWorld

千万千万要注意：java这个命令，后面跟的是“类名”，而绝对不能跟“文件路径”，因为java命令后面跟的不是文件，是一个“类名”。

对于这个类：Test.class ，应该：java Test

#### java HelloWorld”的执行过程以及原理

D:\course\JavaProjects\02-JavaSE\chapter01>java HelloWorld 敲完回车，都发生了什么？？？？？

第一步：

会先启动**JVM**（java虚拟机）

第二步：

JVM启动之后，JVM会去启动“类加载器classloader”

类加载器的作用：

- 加载类的。本质上类加载器负责去硬盘上**找“类”对应的“字节码”文件**。
- 假设是“java HelloWorld”，那么类加载器会去硬盘上搜索：HelloWorld.class文件。
- 假设是“java Test”，那么类加载器会去硬盘上搜索：Test.class文件。
  .......

第三步：

类加载器如果在硬盘上找不到对应的字节码文件，会报错，报什么错？

- 错误: 找不到或无法加载主类

类加载器如果在硬盘上找到了对应的字节码文件，类加载器会将该字节码文件装载到JVM当中，JVM启动“解释器”将字节码解释为“101010000...”这种二进制码，操作系统执行二进制码和硬件交互。

默认情况下，类加载器去硬盘上找“字节码”文件的时候，默认从哪找？

- 默认情况下类加载器（classloader）会从当前路径下找。

能不能给类加载器指定一个路径，让类加载器去指定的路径下加载字节码文件？

- 答案：可以的。但是我们需要设置一个环境变量，叫做：classpath

classpath是一个环境变量，是干啥的？

- 答案：是给“类加载器”指路的。

classpath环境变量**不属于**windows操作系统，classpath环境变量**隶属于java**

classpath环境变量是java特有的。

classpath=A路径;B路径;C路径.....

classpath是一个变量名，A路径;B路径;C路径.....是变量值

我们把classpath配置一下，这个环境变量在windows中没有，需要新建。

`计算机-->右键-->属性-->高级系统设置-->环境变量-->新建...`

注意：变量名不能随意写：大小写无所谓，但必须叫做：classpath

我目前是随意配置的：（重启CMD）classpath=D:\course

非常重要的一个特点，必须记住：配置了classpath=D:\course之后，类加载器只会去D:\course目录下找“xxx.class”文件，不再从当前路径下找了。

到目前为止：classpath环境变量不需要配置。但你必须理解classpath环境变量是干什么的！

你一定要理解classpath环境变量的作用是什么？

- 是给类加载器指路的。
- 在没有配置环境变量classpath的时候，默认从当前路径下加载。
- 如果配置了环境变量classpath的话，就只能从指定的路径下加载了。

path java_home classpath，这3个环境变量path需要配置，后面两个暂时不配置。


在高版本的JDK当中，有这样的一个新特性，可以直接这样一步到位：

java x/y/z/xxx.java

java后面直接加java源文件的路径。

这个特性是为了简化开发而提出，但实际上底层的实现原理还是和以前一样的，以上命令在执行过程中，还是会先进行编译，然后再运行。并且以上的运行方式，编译生成的class文件在硬盘上不存在，看不到。

#### 对于第一个程序的解释

```java
public class HelloWorld{ //类体开始
    //public：公开的
    //class：一个类
    //HelloWorld：类名
    //表示一个共有的类HelloWorld

    public static void main(String[] args){ //方法体开始
        //整个这一块的代码被称为：main方法（程序的入口，sUN公司java语言规定的）
        //也就是说：JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序不能执行
        //main方法也可以叫做主方法。
        //注意：方法必须放到类体中，不能放到类体外面。
        System.out.print("Hello "); //作用：向控制台输出一句话
        //如果println里面的事字符串，就应该用英文创引号括起来
        //
        System.out.println("World!");
    } //方法体结束

}//类体结束

//----------------------------------------------------------------------

//以下程序可以编译通过，但是无法运行，符合语法规则。

public class Test2{
}

/*
>java Test2
错误: 在类 Test2 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/

//---------------------------------------------------------------------

/*
没有语法错误，没有入口，能够编译通过，但是不能运行，因为没有main方法。

错误: 在类 Test3 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
*/
public class Test3{
    static void main(String[] args){
    
    }
}

//---------------------------------------------------------------------

public class Test4{
	// 注意：args可以改名字，随意，对于主方法来说只有这个位置可以改，其它位置不能动
	public static void main(String[] fdsafdsafdsafdsa){
		System.out.println("hello world");
	}
}

//---------------------------------------------------------------------

// 以下程序符合java语法规则吗？不符合！
// 不是不运行，是编译报错。编译过不去，运行肯定不行。

public class Test5{

	// 类体当中应该是方法，而不是直接的java语句
	// 这里可以写吗？不可以！
	System.out.println("hello1");
	
	// 主方法，入口
	public static void main(String[] args){
	
	}

	// 这里可以写吗？不可以！
	System.out.println("hello2");
}

//---------------------------------------------------------------------

// main方法中什么也不写行吗？可以！
// 以下程序编译和运行可以吗？可以！
public class Test6{
	// 入口
	public static void main(String[] args){
	}
}

//---------------------------------------------------------------------

public class Test7{
	
	public static void main(String[] args){

		// 这个不加双引号行吗？ 可以，因为它是数字。
		System.out.println(100);

		// 是数字，加双引号行吗？
		System.out.println("100");

		// 以上性质一样吗？不一样：一个是字符串，一个是数字。
		// 但最终输出到控制台上一个样子，没啥区别。

		// 这里扩展一下：对于数字来说能进行加减乘除吗？
		// + - * / 能用吗 ？ 都可以！
		System.out.println(100 + 200); // 300
		System.out.println(200 - 100); // 100
		System.out.println(200 * 100); // 20000
		System.out.println(200 / 100); // 2
	}
}

class A{

}
class B{

}
class C{

}
class D{

} //编译成功并且生成了 四个类 A.class B.class C.class D.class
/*
	1、这个内容没有为什么，只能经过测试，然后根据测试结果进行记忆。

	2、第一个结论？
		一个java源文件中可以定义多个class。
	
	3、第二个结论？
		public的类不是必须的。可以没有。

	4、第三个结论？
		在源文件中只要有一个class的定义，那么必然会对应生成一个class文件。
	
	5、第四个结论？
		public的类可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。
	
	6、第五个结论？
		public的类有也只能有1个。
*/
class A{

}

/*
	Test8.java:20: 错误: 类 B 是公共的, 应在名为 B.java 的文件中声明
	public class B{
			 ^
	1 个错误
*/
/*
public class B{

}
*/

// 如果定义public的类你只能这样写
public class Test8{
}

class C{

}

class D{

}

//错误: 类重复: Test8
/*
public class Test8{
}
*/

//---------------------------------------------------------------------

// 编译通过了
// 能执行吗？
// 想从哪个入口进去执行，你就加载哪个类就行了！
// 例如：java T1
// 例如：java T2

// 测试不代表以后就这样写，一般一个软件的执行入口是一个。不会出现多个的。
// 以下只是一个测试罢了。
class T1{
	// 想从这个入口进去执行怎么办？java T1
	public static void main(String[] args){
		System.out.println("T1.....");
	}
}

class T2{
	// 想从这个入口进去执行怎么办？java T2
	public static void main(String[] args){
		System.out.println("T2.....");
	}
}
```

```java
/**
javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档当中。
*/
```

### Tips

- 终止程序用System.exit()  方法
- 函数调用：object.method(parameters)

## 标识符与关键字

### 标识符

规则1：标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，不能含有其它符号（比如空格）。

规则2：标识符不能以数字开头

规则3：关键字不能做标识符。例如：public class static void 这些蓝色的字体都是关键字，关键字是不能做标识符的。

规则4：标识符是严格区分大小写的。大写A和小写a不一样。

规则5：标识符理论上是没有长度限制的。

```java
public class BiaoShiFuTest{
	// main是一个方法的名称，属于标识符
	// 但是这个标识符不能修改，因为这个main是SUN固定死的。
	public static void main(String[] args){
	}

	//doSome是一个方法名，可以改成其他的名字
	public static void doSome(){
		// k是一个变量名
		int k = 100;
		// nianLing 是一个变量名
		int nianLing = 20;
	}
}

```

---

```java
/*
	class 123ABC{
	}

*/
```

以上代码编译报错，错误信息是：

- 错误: 需要<标识符>

- 错误原因：编译器检测到class这个单词，那么编译器会从class这个单词后面找类名，而类名是标识符，编译器找了半天没有找到标识符，因为123ABC不是标识符，所以编译器提示的错误信息是：需要<标识符>

解决办法：将123ABC修改为合法的标识符。

```java

class Y123ABC{
}

```

---

```java
class Hello World{
}
```

类名是标识符，标识符“中”不能有空格

编译器错误信息是：

- 错误: 需要'{'
- 编译器检测到class，然后找class后面的标识符，编译器找到了一个合法的标识符叫做“Hello”，然后编译器继续往后找“{”，结果没有找到“{”，所以报错了。

解决办法：

- 办法1：是把World删除
- 办法2：把空格删除

```java
class Hello{
}

class HelloWorld                   {
}

class _A{
}

class _$1Aa你{
}
```


>题目：
>
>创建一个java文件，起名 123.java可以吗？
>
>	可以，完全可以，在windows操作系统中文件名叫做：123.java 没毛病。
>
> 123其实并不是标识符。只是一个文件名。
>
> 只不过在123.java文件中无法定义public的类。
	

标识符除了命名规则之外，还有命名规范：

1、命名规则和命名规范有什么区别？

- 命名规则是语法，不遵守就会编译报错。

- 命名规范只是说，大家尽量按照统一的规范来进行命名，不符合规范也行，代码是可以编译通过的，但是你的代码风格和大家不一样，这个通常也是不允许的。

规则类似于现实世界中的法律。规范类似于现实世界中的道德。

统一按照规范进行的话，代码的可读性很好。	代码很容易让其它开发人员理解。

2、具体的命名规范是哪些？

规范1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）

规范2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低...）驼峰有利于单词与单词之间很好的进行分隔,	BiaoShiFuTest，这个很好，一眼就能看出来是4个单词。

规范3：类名、接口名有特殊要求: 类名和接口名首字母大写，后面每个单词首字母大写。StudentTest、UserTest ，这是类名、接口名。

规范4：变量名、方法名有特殊要求。

- 变量名和方法名首字母小写，后面每个单词首字母大写。nianLing（NianLing这样就不符合了。）mingZi（MingZi这样也不符合了。）

规范5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。

- USER_AGE ：用户年龄

- MATH_PI：固定不变的常量3.1415926.....

```java
public class IdentifierTest{
	public static void main(String[] args){
		// 主要看两个汉语拼音，可读性很强。
		// nianLing和mingZi都是黑色字体的标识符。
		int nianLing = 20;
		String mingZi = "zhangsan";
	}
}
```


### 关键字

什么是关键字？在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。

切记：java语言中的所有关键字都是全部小写。注意：java语言中是严格区分大小写的。public和Public不一样。Class和class不一样。static和Static也不一样。

### Tips

- java 中整型的范围与运行代码的机器无关

- 从java7开始，加上前缀0b或者0B就可以写二进制数，比如0b10100

- 还可以为数字加上下划线，如1_0000_0000,等价于100000000

- 在C/C++中，int和long等类型的大小与平台直接相关，int型在16位的平台上占用2字节的大小，在32位的平台上占用4字节的大小，在Java中，占用的大小是固定的，与平台无关。

- Java中没有任何的无符号整型

- Java无法精确打印出2.0-1.1的结果的原因（0.89999999而不是0.9）

  - 浮点数采用二进制数表示，但是二进制系统中无法精确的表示分数1/10

- 强烈建议不要使用char类型，除非确实需要处理UTF-16的代码单元

- 不提倡在一行中声明多个变量，逐一声明变量可以提高程序的可读性

## 变量与数据类型

### 变量

字面量：字面量就是数据、数据就是字面量、是一个东西。在java语言中“数据”被称为“字面量”。

```
10 100 123 ：整型
1.34 3.14 2.0：浮点型
true false ：布尔型
'a' '国'：字符型
"a" "abc"  "国" "中国"：字符串型
10：整数，是一个数字
"10"：它不是数字，是一个字符串，或者说，它属于“文字类”的。性质完全不同，在计算机中的对应的二进制码也是完全不同的。
```

其中字符型和字符串型都是描述了现实世界中的文字，需要注意的是：

- 所有的字符型只能使用单引号括起来。

- 所有的字符串型只能使用双引号括起来。

- 字符型一定是单个字符才能成为“字符型”	

在语法级别上怎么区分字符型和字符串型？

- 主要看是双引号还是单引号。

- 单引号的一定是字符型。

- 双引号的一定是字符串型。

什么是变量？

变量就是一个存数据盒子。在内存中的最基本的存储单元。是存数据用的，而且这个数据是可变的，所以叫做变量。（盒子大小谁来决定？数据类型）

变量的使用

变量的三要素？

数据类型、变量名、值  （值就是数据，就是字面量。）`int i = 100;`

```java
// 1. java中的变量必须先声明，再赋值才能访问（必须手动赋值。）
int k; 
System.out.println(k); //这样是不行的。

// 2. 可以在一行上声明多个变量：

int a, b, c = 100;
// c变量赋值100，a,b变量只声明了没有赋值。
int a = 10, b = 20, c = 100;
// 也可以这样每个都赋值。

// 3.声明和赋值可以分开，也可以一起做！

int i;
i = 100; // 先声明再赋值
int k = 200; // 声明的同时赋值
```

在“同一个域”当中，变量名不能重名！但可以重新赋值
```java
{
    int i = 100;
    //double i = 2.0; // 重名了编译器会报错，不允许。
    i = 300; // 可以重新赋值。
}
```

什么叫做同一个域？一个大括号代表一个域。

变量的分类

根据位置进行分类：记住就行

```java
//在方法体当中声明的变量叫做局部变量。

public static void m1(){
//局部变量，方法执行结束之后内存释放。
    int k = 100;
    int i = 200;
}

//在方法体外以及类体内声明的变量叫做成员变量。
public class T{
public static void x(){

}
	// 成员变量
	int i = 200;
}

//变量的作用域
//出了大括号就不认识了。别的先别管。
{
	int i = 100;
	{
		//在这里可以访问i
	}
}
{
	//在这里是无法访问i变量。
}
```

变量的作用域？

1、什么是作用域？变量的有效范围。

2、关于变量的作用域，可一句话：出了大括号就不认识了。（死记这句话。）

3、java中有一个很重要的原则：就近原则。（不仅java中是这样，其它编程语言都有这个原则。）哪个离我近，就访问哪个。

```java
public class VarTest08{

	// 成员变量
	int i = 10000;

	public static void main(String[] args){
		// 局部变量
		int i = 100; // 这个i的有效范围是main方法。
		System.out.println(i); // 这个i是多少？

		// 同一个域当中，这是不允许的。
		//int i = 90;  

		for(int n = 0; n < 10; n++){ // 这里声明的n变量只属于for域。for结束后n释放没了。
			// 这里没有编写代码。
		}

		// for循环执行结束之后，在这里访问n变量可以吗？
		//System.out.println(n);  //错误: 找不到符号

		int k; // 属于main域。
		for(k = 0; k < 10; k++){

		}
	}

	// 这个方法怎么定义先不用管，后面会学习。
	public static void x(){
		// 在这个位置上能访问i吗？不能
		// 错误: 找不到符号
		// System.out.println(i); // i是无法访问的。

		// 可以定义一个变量起名i吗？
		// 这个i的有效范围是x方法。
		// 局部变量
		int i = 200; // 所以这个i和main方法中的i不在同一个域当中。不冲突。
	}
}
```


### 数据类型

数据类型有什么用？

- 数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。

数据类型在java语言中包括两种：

- 第一种：基本数据类型(8小种)基本数据类型又可以划分为4大类8小种：
  - 第一类：整数型 byte,short,int,long （没有小数的）
  - 第二类：浮点型 float,double （带有小数的）
  - 第三类：布尔型 boolean：只有两个值true和false，true表示真，false表示假
  - 第四类：字符型 char：java中规定字符型字面量必须使用单引号括起来。属于文字。
- 第二种：引用数据类型
  - 字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。
- java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。

整数型：byte short int long有什么区别？

浮点型：float和double有什么区别？

区别：占用的空间大小不同。

| 类型 | 占用字节数量(byte) | 取值范围|
| ---- | ------------------ |-----|
| byte | 1 | -128 ~ 127|
| short | 2 | -32768 ~ 32767 |
| int | 4   | -2147483648 ~ 2147483647|
| long | 8  | -2^63~2^63-1 |
| float | 4 | -2^31~2^31-1|
| double | 8  | -2^63~2^63-1|
| boolean | 1 | true、false |
|char | 2 | 0 ~ 65535 |

short和char实际上容量相同，不过char可以表示更大的数字。

因为char表示的是文字，文件没有正负之分，所以char可以表示更大的数字。

其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0;对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。

什么是字符编码？

字符编码是人为的定义的一套转换表。在字符编码中规定了一系列的文字对应的二进制。字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。字符编码是人为规定的。

字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。

关于字符编码的发展过程？

- 起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了战争而开发的，计算导弹的轨道....
- 后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文对应的字符编码方式是：ASCII码。

在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。具体的实现包括：UTF-8 UTF-16 UTF-32....

ASCII（'a'是97 'A'是65 '0'是48...）

#### 字符型：char

1、char占用2个字节。

2、char的取值范围：[0-65535]

3、char采用unicode编码方式。

4、char类型的字面量使用单引号括起来。

5、char可以存储一个汉字。

```java
public class CharTest01{
	public static void main(String[] args){
		// char可以存储1个汉字吗？
		// 可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。
		char c1 = '中';
		System.out.println(c1);

		char c2 = 'a';
		System.out.println(c2);

		// 0如果加上单引号的话，0就不是数字0了，就是文字0，它是1个字符。
		char c3 = '0';
		System.out.println(c3);

		// 错误: 不兼容的类型: String无法转换为char
		//char c4 = "a";

		// 错误: 未结束的字符文字
		//char c5 = 'ab';

		// 错误: 未结束的字符文字
		//char c6 = '1.08';

	}
}

```

转义字符

```java

/*
	关于java中的转义字符
*/
public class CharTest02{
	public static void main(String[] args){


		System.out.println("s");
		// 编译报错。
		//System.out.println(""");
		//System.out.println("\"");

		// 这个可以输出吗？
		// 这个不需要专门进行转义。
		// 这个 ' 在这里只是一个普通的字符，不具备特殊含义。
		System.out.println("'");

		//以下都有问题
		//System.out.println(''');
		//System.out.println(""");

		// 可以的。
		System.out.println("'这样呢'");

		// 编译报错，因为：4e2d 是一个字符串
		// 错误: 未结束的字符文字
		//char x = '4e2d';

		// 反斜杠u表示后面的是一个字符的unicode编码。
		// unicode编码是十六进制的。
		char x = '\u4e2d';
		System.out.println(x); // '中'
	}
}

/*
	1、整数能否直接赋值给char
	2、char x = 97;
		这个java语句是允许的，并且输出的结果是'a'
		经过这个测试得出两个结论：
			第一个结论：当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。

			第二个结论：当一个整数没有超出byte short char的取值范围的时候，
			这个整数可以直接赋值给byte short char类型的变量。
*/
public class CharTest03{
	public static void main(String[] args){
	
		char c1 = 'a';
		System.out.println(c1);

		// 这里会做类型转换吗？
		// 97是int类型（这是java中规定，默认当做int处理）
		// c2是char类型
		//char c2 = (char)97; // 不需要这样做。
		char c2 = 97;
		System.out.println(c2); // 'a'

		// char类型取值范围：[0~65535]
		char c3 = 65535; // 实际上最终是一个“看不懂”的字符。
		System.out.println(c3);

		//错误: 不兼容的类型: 从int转换到char可能会有损失
		//char c4 = 65536;

		// 怎么解决以上问题？
		char c4 = (char)65536;

		byte x = 1;
		short s = 1;
		char c = 1;

	}
}
```

#### 整数型：byte short int long

byte b = 127; // 可以直接赋值short s = 32767; // 可以直接赋值

char // 没有超出char的取值范围可以直接赋值给char变量吗?

浮点型：float double

布尔型：boolean

```java
/*
	开发的时候不用斤斤计较，直接选择使用int就行了。
*/
public class IntTest01{
	public static void main(String[] args){

		// 二进制（JDK8的新特性，低版本不支持。）
		int d = 0b10;
		System.out.println(d); // 2
	}
}


```

##### 过大整数的问题

在java中有一条非常重要的结论，必须记住：

- 在任何情况下，整数型的“字面量/数据”默认被当做int类型处理。（记住就行）果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L/l,	建议使用大写L，因为小写l和1分不清。

```java
public class IntTest02{
	public static void main(String[] args){

		// 分析这个代码存在类型转换吗，以下代码什么意思？
		// 不存在类型转换
		// 100 这个字面量被当做int类型处理
		// a变量是int类型，所以不存在类型的转换。
		// int类型的字面量赋值给int类型的变量。
		int a = 100;
		System.out.println(a);

		// 分析这个程序是否存在类型转换？
		// 分析：200这个字面量默认被当做int类型来处理
		// b变量是long类型，int类型占4个字节，long类型占8个字节
		// 小容量可以自动转换成大容量，这种操作被称为：自动类型转换。
		long b = 200;
		System.out.println(b);

		// 分析这个是否存在类型转换？
		// 这个不存在类型转换。
		// 在整数型字面量300后面添加一个L之后，300L联合起来就是一个long类型的字面量
		// c变量是long类型，long类型赋值给long类型不存在类型转换。
		long c = 300L;
		System.out.println(c);

		// 题目：
		// 可以吗？存在类型转换吗？
		// 2147483647默认被当做int来处理
		// d变量是long类型，小容量可以自动赋值给大容量，自动类型转换
		long d = 2147483647; // 2147483647是int最大值。
		System.out.println(d);

		// 编译器会报错吗？为什么？
		// 在java中，整数型字面量一上来编译器就会将它看做int类型
		// 而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。
		// 记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648
		// 只不过2147483648本身已经超出了int范围。
		// 错误: 整数太大
		//long e = 2147483648;

		// 怎么解决这个问题呢？
		long e = 2147483648L;
		System.out.println(e);

	}
}

```

##### 自动类型转换和强制类型转换

1、小容量可以直接赋值给大容量，称为自动类型转换。

2、大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。但需要注意的是：加强制类型转换符之后，虽然编译通过了，但是运行的时候可能会损失精度。

```java
public class IntTest03{
	public static void main(String[] args){
		
		// 不存在类型转换
		// 100L是long类型字面量，x是long类型字面量。
		long x = 100L;

		// x是long类型，占用8个字节，而y变量是int类型，占用4个字节
		// 在java语言中，大容量可以“直接”赋值给小容量吗？不允许，没有这种语法。
		// 编译错误信息：错误: 不兼容的类型: 从long转换到int可能会有损失
		// int y = x;

		// 大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。
		// 底层是怎么进行强制类型转换的呢？
		// long类型100L：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
		// 以上的long类型100L强转为int类型，会自动将“前面”的4个字节砍掉：00000000 00000000 00000000 01100100
		int y = (int)x; // 这个(int)就是强制类型转换符，加上去就能编译通过。
						// 但是要记住：编译虽然过了，但是运行时可能损失精度。
		System.out.println(y); // 100

		// 定义变量a int类型，赋值100
		int a = 100;
		System.out.println(a);

		int b = a; // 将变量a中保存的值100复制一份给b变量。
		System.out.println(b);

	}
}

```

##### 强制类型转换的精度损失

java中有一个语法规则：

- 当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量。short 同理。
	
这种语法机制是为了方便写代码，而存在的。

```java
public class IntTest04{
	public static void main(String[] args){
		// 分析：以下代码编译可以通过吗？
		// 300 被默认当做int类型
		// b变量是byte类型
		// 大容量转换成小容量，要想编译通过，必须使用强制类型转换符
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//byte b = 300;

		// 要想让以上的程序编译通过，必须加强制类型转换符
		// 虽然编译通过了，但是可能精度损失。
		// 300这个int类型对应的二进制：00000000 00000000 00000001 00101100
		// byte占用1个字节，砍掉前3个字节，结果是：00101100 (44)
		byte b = (byte)300;
		System.out.println(b); // 44

		// 这个编译能通过吗？
		// 1是int类型，默认被当做int类型来看。
		// x是byte类型，1个字节，大容量无法直接转换成小容量。
		// 按说是编译报错的。
		byte x = 1;
		byte y = 127;
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		byte z = 128;

		// 当整数型字面量没有超出short类型取值范围的时候，该字面量可以直接赋值给short
		// 类型的变量。
		short s = 1;
		short s1 = 32767;
		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s2 = 32768;
		System.out.println(s);

	}
}
```

##### byte, char, short 混合运算

```java
/*
	结论：byte、char、short做混合运算的时候，各自先转换成int再做运算。
*/
public class IntTest06{
	public static void main(String[] args){

		char c1 = 'a';
		byte b = 1;

		// 注意：这里的"+"是负责求和的
		System.out.println(c1 + b); // 98

		// 错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = c1 + b; // 编译器不知道这个加法最后的结果是多少。只知道是int类型。

		// 这样修改行吗？
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		//short s = (short)c1 + b;

		short s = (short)(c1 + b);

		//short k = 98;

		int a = 1;
		//错误: 不兼容的类型: 从int转换到short可能会有损失
		// short x = 1; 可以
		short x = a; // 不可以，编译器只知道a是int类型，不知道a中存储的是哪个值。
		System.out.println(x);
	}
}
```
##### 多种类型混合运算

```java
/*
	结论：多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。

	char+short+byte 这个除外。
	因为char + short + byte混合运算的时候，会各自先转换成int再做运算。
*/
public class IntTest07{
	public static void main(String[] args){
		
		long a = 10L;
		char c = 'a';
		short s = 100;
		int i = 30;

		// 求和
		System.out.println(a + c + s + i); //237

		// 错误: 不兼容的类型: 从long转换到int可能会有损失
		// 计算结果是long类型
		//int x = a + c + s + i;

		int x = (int)(a + c + s + i);
		System.out.println(x);

		// 以下程序执行结果是？
		// java中规定，int类型和int类型最终的结果还是int类型。
		int temp = 10 / 3; // / 是除号。（最终取整）
		System.out.println(temp); // 3.33333吗？结果是：3

		// 在java中计算结果不一定是精确的。
		int temp2 = 1 / 2;
		System.out.println(temp2); // 0

	}
}
```

#### 浮点型数据

关于java语言中的浮点型数据

浮点型包括：

|类型| 大小| 解释 |
|---|---|---|
|float	|	4个字节|	float是单精度|
|double	|	8个字节|	double是双精度,更精确|
	
比如说：
- 10.0 / 3 如果采用float来存储的话结果可能是：3.33333

- 10.0 / 3 如果采用double来存储的话结果可能是：3.3333333333333


>	但是需要注意的是，如果用在银行方面或者说使用在财务方面，double也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门使用在财务软件方面：java.math.BigDecimal （不是基本数据类型，属于引用数据类型。）
	
float和double存储数据的时候都是存储的近似值。

- 因为现实世界中有这种无限循环的数据，例如：3.3333333333333....数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源表示无限的数据，只能存储近似值。

long类型占用8个字节。float类型占用4个字节。

哪个容量大？

- 注意：任意一个浮点型都比整数型空间大。float容量 > long容量。
	
java中规定，任何一个浮点型数据默认被当做double来处理。如果想让这个浮点型字面量被当做float类型来处理，那么请在字面量后面添加F/f。

1.0 那么1.0默认被当做double类型处理。		1.0F 这才是float类型。（1.0f）

```java

public class FloatTest01{
	public static void main(String[] args){

		// 这个不存在类型转换
		// 3.1415926是double类型
		// pi是double类型
		double pi = 3.1415926;
		System.out.println(pi);

		// 这个可以吗？
		//错误: 不兼容的类型: 从double转换到float可能会有损失
		//float f = 3.14;

		// 怎么修改以上的代码呢？
		// 第一种方式:在字面量后面添加F/f
		//float f = 3.14f;
		//float f = 3.14F;

		// 第二种方式：强制类型转换，但可能损失精度。谨慎使用。
		float f = (float)3.14;
		System.out.println(f);

		// 分析这个程序，可以编译通过吗？
		// 错误: 不兼容的类型: 从double转换到int可能会有损失
		// 原理：先将5转换成double类型，然后再做运算，结果是double
		// 大容量无法直接赋值给小容量，需要强转。
		//int i = 10.0 / 5;

		// 怎么修改
		int i = (int)10.0 / 5;
		System.out.println(i); // 2

		// 可以这样修改吗？强转的时候只留下整数位。
		int x = (int)(10.0 / 5);
		System.out.println(x); // 2
	}
}

```

#### 布尔类型

1、在java语言中boolean类型只有两个值，没有其他值：true和false。不像C或者C++，C语言中1和0也可以表示布尔类型。

2、boolean类型在实际开发中使用在哪里呢？		使用在逻辑判断当中，通常放到条件的位置上（充当条件）

```java
public class BooleanTest01{
	public static void main(String[] args){
		//错误: 不兼容的类型: int无法转换为boolean
		//boolean xingBie = 1;
	}
}
```

#### 类型转换

在类型转换的时候需要遵循哪些规则？

- 第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；

- 第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；

- 第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：byte < short(char) < int < long < float < double，其中 short和 char都占用两个字节，但是char 可以表示更大的正整数；

- 第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；

- 第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；

- 第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；

### 运算符

- 算术运算符：+ - * / % ++ --

- 关系运算符： > >= < <= == !=

- 逻辑运算符：& | ! && ||

- 赋值运算符：= += -= *= /= %=

- 三目运算符：布尔表达式 ? 表达式 1 : 表达式 2 

- 字符串连接运算符：+

#### 逻辑运算符


逻辑运算符：
- &	逻辑与（可以翻译成并且）
- |	逻辑或（可以翻译成或者）
- !	逻辑非（取反）
- &&	短路与
- ||	短路或
- 	用普通话描述的话：100 大于 99 并且 100 大于 98；用代码描述的话：100 > 99 & 100 > 98 --> true

true & true --> true

非常重要：逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。这是逻辑运算符的特点。	

- 100 & true 不行，语法错误。

- 100 & 200 不行，没有这种语法。

- true & false 这样可以。

100 > 90 & 100 > 101 --> false

- & 两边都是true，结果才是true

- | 有一边是true，结果就是true


短路与&& 和 逻辑与 &有什么区别？

- 首先这两个运算符的运算结果没有任何区别，完全相同。只不过“短路与&&”会发生短路现象。

什么是短路现象呢？

- 右边表达式不执行，这种现象叫做短路现象。

什么时候使用&&，什么时候使用& ？

- 从效率方面来说，&&比&的效率高一些。因为逻辑与&不管第一个表达式结果是什么，第二个表达式一定会执行。

以后的开发中，短路与&&和逻辑与还是需要同时并存的。

- 大部分情况下都建议使用短路与&&，只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会选择逻辑与&。


```java

System.out.println(true & true); // true
System.out.println(true & false); // false
System.out.println(false & false); // false

System.out.println(true && true); // true
System.out.println(true && false); // false
System.out.println(false && false); // false

// 接下来需要理解一下什么是短路现象，什么时候会发生“短路”。
int x = 10;
int y = 11;
// 逻辑与&什么时候结果为true（两边都是true，结果才是true）
// 左边的 x>y 表达式结果已经是false了，其实整个表达式的结
// 果已经确定是false了，按道理来说右边的表达式不应该执行。
System.out.println(x > y & x > y++); 

// 通过这个测试得出：x > y++ 这个表达式执行了。
System.out.println(y); // 12

//测试短路与&&
int m = 10;
int n = 11;
// 使用短路与&&的时候，当左边的表达式为false的时候，右边的表达式不执行
// 这种现象被称为短路。
System.out.println(m > n && m > n++);
System.out.println(n); // 11
```

问题：什么时候发生短路或现象？|| 短路或

“或”的时候只要有一边是true，结果就是true。

所以，当左边的表达式结果是true的时候，右边的表达式不需要执行，此时会短路。

#### 赋值运算符

扩展的赋值运算符？

- +=

- -=

- *=

- /=

- %=

使用扩展赋值运算符的时候，永远都不会改变运算结果类型。

`byte x = 100;`
`x += 1;`

x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。不管后面是多大的数字。

```java
public class OperatorTest04{
	public static void main(String[] args){

		// 研究：
		// i += 10 和 i = i + 10 真的是完全一样吗？
		// 答案：不一样，只能说相似，其实本质上并不是完全相同。
		byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
		System.out.println(x); // 100

		// 分析：这个代码是否能够编译通过？
		// 错误: 不兼容的类型: 从int转换到byte可能会有损失
		//x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？

		// 使用扩展赋值运算符可以吗？
		// 可以的，所以得出结论：x += 1 和 x = x + 1不一样。
		// 其实 x += 1 等同于：x = (byte)(x + 1);
		x += 1;
		System.out.println(x); // 101

		// 早就超出byte的取值范围了。
		x += 199; // x = (byte)(x + 199);
		System.out.println(x); // 44 （当然会自动损失精度了。）

		int y = 100;
		y += 100;
		System.out.println(y); // 200

		y -= 100; // x = x - 100;
		System.out.println(y); // 100

		y *= 10; // x = x * 10;
		System.out.println(y); // 1000

		y /= 30; // x = x / 30;
		System.out.println(y); // 33

		y %= 10; // x = x % 10;
		System.out.println(y); // 3
		
	}
}

```

一个特例


```java


// 大家讨论最多的一个问题。
// 如果只是针对于面试题的话，建议死记硬背。
public class Homework01{
	public static void main(String[] args){
		int i = 10;
		i = i++;
		// 大部分同学都会认为这个i一定是11
		// 这个i变量最终的结果是10（惊讶）
		// 首先，第一点：这种代码以后不会有人写。
		// 其次：第二点：没必要讨论这个问题，因为在C++中运行结果确实是11.
		// java中运行结果是10
		// c++中运行结果是11
		// 为什么？因为java和c++的编译器是不同的人开发的。原理不同。
		System.out.println(i);
		
		// 在java语言中i++，这种表达式在执行的时候，会提前先将i变量找一个临时
		// 变量存储一下。(C++中并没有这样做。)
		/*
		int k = 10;
		k = k++;
		*/
		int k = 10;
		// k = k++;对应的是下面三行代码
		int temp = k;
		k++;
		k = temp;
		System.out.println(k);
	}
}

```

#### 字符串链接运算符

+ 运算符：

1、+ 运算符在java语言中有两个作用。

- 	作用1：求和

- 	作用2：字符串拼接

2、什么时候求和？什么时候进行字符串的拼接呢？

- 当 + 运算符两边都是数字类型的时候，求和。

- 当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。

3、一定要记住：字符串拼接完之后的结果还是一个字符串。


#### 接收用户键盘输入

输出信息到控制台：`System.out.println(...);`

2、在java中怎么接收键盘的输入呢？

`java.util.Scanner s = new java.util.Scanner(System.in); `

接收一个整数		`int num = s.nextInt();`
		
接收一个字符串		`String str = s.next();`

```java
public class KeyInput{
	public static void main(String[] args){

		// 创建一个键盘扫描器对象
		// s 变量名，可以修改。其它不能改。 
		java.util.Scanner s = new java.util.Scanner(System.in); //这行代码写一次就行了。

		// 接收用户的输入，从键盘上接收一个int类型的数据
		// 解释这行代码，尽量让大家明白：代码执行到这里的时候，会暂停下来
		// 等待用户的输入，用户可以从键盘上输入一个整数，然后回车，回车之后
		// i变量就有值了。并且i变量中保存的这个值是用户输入的数字。
		// i变量就是接收键盘数据的。
		int i = s.nextInt(); // i是变量名，s是上面的变量名
		System.out.println("您输入的数字是：" + i);

		// 代码执行到此处又会停下来，等待用户的输入。
		// 敲完回车，s.nextInt();代码执行结束。
		int j = s.nextInt();
		System.out.println("您输入的数字是：" + j);

		// 如果输入的不是数字，那么会出异常：InputMismatchException
		int m = s.nextInt();
		System.out.println("您输入的数字是：" + m);

		// 我怎么从键盘上接收一个字符串呢？
		// 程序执行到此处会停下来，等待用户的输入，用户可以输入字符串。
		String str = s.next();
		System.out.println("您输入了：" + str);

		// 完整的。
		System.out.print("请输入用户名：");
		String name = s.next();
		System.out.println("欢迎"+name+"回来");
	}
}
```

### Tips

- 在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层的变量，这样可能会导致程序设计的错误，所以在Java中不能这样做。

- Java的引用相当于C++的指针而不是引用，因为：

  - C++中没有空引用

  - 引用不能被赋值

- java中的null引用相当与C++中的NULL指针

## 控制语句和方法

### 控制语句

- 选择语句
	- if
	- switch
		- switch语句本质上是只支持int和String，但是byte,short,char也可以使用在switch语句当中，因为byte short char可以进行**自动类型转换**。
- 循环语句
	- for
	- while
	- do...while
- 转向语句
	- break
	- continue
	- return

**记住 ：Java的 int 和 boolean 不能转换 ！！！**

```java
/*
怎么用break;语句终止指定的循环呢？
	第一步：你需要给循环起一个名字，例如：
		a: for(){
			b:for(){
			}
		}
	第二步：终止：break a;
*/
public class BreakTest01{

	public static void main(String[] args){

		// 这种语法很少用，了解一下即可。
		a:for(int k = 0; k < 2; k++){ 
			b:for(int i = 0; i < 10; i++){
				if(i == 5){
					break a; // 终止指定的循环。
				}
				System.out.println("i ===> " + i); 
			}
		}

		System.out.println("呵呵");

	}
}// continue 也可以这样终止，但是开发中也很少用
```

### 方法

方法定义的先后顺序没有关系。都可以。

方法怎么定义，语法机制是什么？

```java
[修饰符列表] 返回值类型 方法名(形式参数列表){
	方法体; 
}
```

注意：
- [] 符号叫做中括号，以上中括号[]里面的内容表示不是必须的，是可选的。

- 方法体由Java语句构成。

- 方法定义之后需要去调用，不调用是不会执行的。

关于修饰符列表：
- 修饰符列表不是必选项，是可选的。目前为止，大家统一写成：public static

关于返回值类型：

- 第一：返回值类型可以是任何类型，只要是java中合法的数据类型就行，数据类型包括基本数据类型和引用数据类型，也就是说返回值类型可以是：byte short int long float double boolean char String......

- 第二：方法就是为了完成某个特定的功能，方法结束之后大部分情况下都是有一个结果的，而体现结果的一般都是数据。数据得有类型。这就是返回值类型。方法执行结束之后的返回值实际上是给调用者了。谁调用就返回给谁。
	
- 第三：当一个方法执行结束不返回任何值的时候，返回值类型也不能空白，必须写上void关键字。所以void表示该方法执行结束后不返回任何结果。

- 第四：如果返回值类型“不是void”，那么你在方法体执行结束的时候必须使用"return 值;"这样的语句来完成“值”的返回，如果没有“return 值;”这样的语句那么编译器会报错。return 值; 这样的语句作用是什么？作用是“返回值”，返回方法的执行结果。
	
- 第五：只要有“return”关键字的语句执行，当前方法必然结束。return只要执行，当前所在的方法结束，记住：不是整个程序结束。

- 第六：如果返回值类型是void，那么在方法体当中不能有“return 值;”这样的语句。但是可以有“return;”语句。这个语句“return;”的作用就是用来终止当前方法的。
	
- 第七：除了void之外，剩下的都必须有“return 值;”这样的语句。

形式参数列表

- 简称：形参

- 注意：形式参数列表中的每一个参数都是“局部变量”，方法结束之后内存释放。

- 形参的个数是：0~N个。

- public static void sumInt(){}

- public static void sumInt(int x){}

- 形参有多个的话使用“逗号,”隔开。逗号是英文的。形参的数据类型起决定性作用，形参对应的变量名是随意的。
	

方法体：

- 由Java语句构成。java语句以“;”结尾。方法体当中编写的是代码，完成某个特定功能。

- 在方法体中的代码遵循自上而下的顺序依次逐行执行。

- 在方法体中处理业务逻辑代码的时候需要数据，数据来源就是这些形参。
	

怎么调用呢

- 类名.方法名(实际参数列表);	

- 实参和形参的类型必须一一对应，个数也要一一对应。

你定义了一个/抽取了一个方法出来，而这个方法确无法完成某个功能，那么你抽取的这个方法毫无意义。般一个方法就是一个“功能单元”。假设在以后的开发中，某个功能是可以独立抽取出来的，建议定义为方法，这样以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码。

“类名.”是可以省略

- a()方法调用b()方法的时候，a和b方法都在同一个类中，“类名.”可以省略。如果不在同一个类中“类名.”不能省略。

```java
	// 在同一个域当中，"return语句"下面不能再编写其它代码。编写之后编译报错。
	public static int m(){
		boolean flag = true;
		if(flag){
			return 1;
			//错误: 无法访问的语句
			//System.out.println("hello1");
		}
		// 这行代码和上面的代码hello1的区别是：不在同一个域当中。
		//System.out.println("hello2");
		return 0;
		// 错误: 无法访问的语句
		//System.out.println("hello3");
	}
```


#### 重载

注意：如果功能不相似，坚决要让方法名不一致。

重载条件

- 条件1：在同一个类当中
- 条件2：方法名相同
- 条件3：形式参数列表不同（类型、个数、顺序）

注意：方法重载和返回值类型无关，和修饰符列表无关。

在java语言中，是怎么进行方法区分的？

- 首先java编译器会通过**方法名**进行区分。
- 但是在java语言中允许方法名相同的情况出现。
- 如果方法名相同的情况下，编译器会通过**方法的参数类型**进行方法的区分。


#### 递归

- 方法自身调用自身。

- 使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。
- StackOverflowError  原因：一直压栈，没有弹栈，栈内存不够用。

- 能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。JVM发生错误之后只有一个结果，就是退出JVM。当然，只有极少数情况下，只能用递归，其它代码解决不了问题。

- 当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？
也不一定。可能递归的太深了。栈内存不够了。因为一直在压栈。

- 在实际的开发中，不建议轻易的选择递归，能用for循环while循环代替的，尽量使用循环来做。因为循环的效率高，耗费的内存少。递归耗费的内存比较大，另外递归的使用不当，会导致JVM死掉。(但在极少数的情况下，不用递归，这个程序没法实现。)所以：递归我们还是要认真学习的。

> - 在实际的开发中，假设有一天你真正的遇到了：StackOverflowError 你怎么解决这个问题，可以谈一下你的思路吗？
> - 我来谈一下我的个人思路：
>   - 第一步：先检查递归的结束条件对不对。如果递归结束条件不对，必须对条件进一步修改，直到正确为止。
>   - 第二步：假设递归条件没问题，怎么办？这个时候需要手动的调整JVM的栈内存初始化大小。可以将栈内存的空间调大点。（可以调整大一些。）				
>   - 第三步：调整了大小，如果运行时还是出现这个错误，没办法，只能继续扩大栈的内存大小。

(java -X)这个可以查看调整堆栈大小的参数

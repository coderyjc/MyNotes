这个直接快排一把梭

---

关于快排的一些说法：

```ad-question
title:必须先从后向前找吗？
是的，因为第一个位置作为基准数的时候，已经被记下来了，所以这个位置就是【自由的，可以被覆盖的】这个时候从后向前找，找到比基准数字小的数的时候可以直接覆盖到第一个位置。
覆盖到第一个位置之后，此时这个位置的数就有了一个【备份】，这时候再从前向后找，找到一个比基准值大的数字的时候，可以直接覆盖到这个【备份位置】上。
直到左右指针重合，这时候指向的位置一定是有一个备份的，因此可以把基准值直接填上去。
```




---

代码解释

```cpp

void quickSort(int num[], int start, int end){
  int i = start, j = end;
  if(i >= j) return;
  int val = num[i];
  while (i < j) {
    // back to front, find small
    while(i < j && num[j] > val) j--;
    // find it
    if(i < j) num[i++] = num[j];
    // front to back, find bigger
    while(i < j && num[i] < val) i++;
    // find it
    if(i < j) num[j--] = num[i];
  }

  // i == j
  num[i] = val;
  quickSort(num, start, i - 1);
  quickSort(num, j + 1, end);
}
```

以上代码中，10,14行中，i和j在使用完之后需要移动。
